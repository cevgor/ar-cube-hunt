<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π —Ä–µ–π–¥–µ—Ä ‚Äî —É–ª—É—á—à–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>

  <!-- Three + postprocessing (–Ω–µ –º–æ–¥—É–ª—å–Ω—ã–µ –≤–µ—Ä—Å–∏–∏, —Ä–∞–±–æ—Ç–∞—é—Ç —Å r128) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
  <script src="https://threejs.org/examples/js/shaders/GammaCorrectionShader.js"></script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0;user-select:none}
    html,body{width:100%;height:100%;background:#020812}
    #gameContainer{position:fixed;inset:0;z-index:1}
    #ui{position:fixed;inset:0;pointer-events:none;z-index:10;font-family:'Courier New',monospace;color:#0ff}
    .screen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none}
    .hidden{display:none}
    .hud{pointer-events:auto;position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.6);padding:10px;border:1px solid rgba(0,255,255,0.14);backdrop-filter:blur(4px)}
    .resources{pointer-events:auto;position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.6);padding:10px;border:1px solid rgba(0,255,255,0.14)}
    .btn{pointer-events:auto;background:transparent;border:1px solid #0ff;padding:8px 14px;color:#0ff;margin:8px;border-radius:8px;cursor:pointer}
    .simple-controls{pointer-events:auto;position:absolute;bottom:30px;display:flex;gap:18px}
    .control-btn{width:72px;height:72px;border-radius:14px;background:rgba(0,255,255,0.06);border:1px solid rgba(0,255,255,0.12);display:flex;align-items:center;justify-content:center;font-size:28px;color:#0ff;cursor:pointer}
    .scanlines{position:fixed;inset:0;pointer-events:none;background:repeating-linear-gradient(to bottom, rgba(255,255,255,0.0) 0px, rgba(255,255,255,0.02) 2px, rgba(255,255,255,0.0) 3px);opacity:0.25;mix-blend-mode:overlay}
    .loading{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);color:#0ff;padding:10px;background:rgba(0,0,0,0.6);border-radius:8px}
    /* HUD flash */
    .damage-flash{position:fixed;inset:0;background:#ff0000;opacity:0;pointer-events:none;mix-blend-mode:screen;transition:opacity 250ms}
  </style>
</head>
<body>
  <div id="gameContainer"></div>
  <div id="ui">
    <div class="scanlines"></div>
    <div id="menuScreen" class="screen">
      <h1 style="font-size:3rem;color:#0ff;text-shadow:0 0 20px #0ff">–ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –†–ï–ô–î–ï–†</h1>
      <button id="startBtn" class="btn" style="pointer-events:auto">–°–¢–ê–†–¢</button>
    </div>

    <div id="gameScreen" class="screen hidden">
      <div class="hud" id="hudBox">
        <div>‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: <span id="healthValue">100</span></div>
        <div>üõ° –©–ò–¢: <span id="shieldValue">100</span></div>
        <div>‚≠ê –ó–í–Å–ó–î–´: <span id="starsValue">0</span></div>
        <div>üíé –ö–†–ò–°–¢–ê–õ–õ–´: <span id="fragmentsValue">0</span></div>
      </div>

      <div class="resources" id="resBox">
        <div>üèÜ –û–ß–ö–ò: <span id="scoreValue">0</span></div>
        <div>üéØ –ú–ò–°–°–ò–Ø: <span id="missionValue">0/5</span></div>
      </div>

      <div class="simple-controls">
        <div id="leftBtn" class="control-btn">‚Üê</div>
        <div id="shieldBtn" class="control-btn">üõ°</div>
        <div id="shootBtn" class="control-btn">üí•</div>
        <div id="rightBtn" class="control-btn">‚Üí</div>
      </div>
    </div>

    <div id="gameOver" class="screen hidden">
      <div style="background:rgba(0,0,0,0.85);padding:20px;border-radius:12px;border:1px solid #f33;color:#f33">
        <h2>–ö–û–†–ê–ë–õ–¨ –£–ù–ò–ß–¢–û–ñ–ï–ù</h2>
        <div>–°—á—ë—Ç: <span id="finalScore">0</span></div>
        <div style="margin-top:10px"><button id="restartBtn" class="btn" style="pointer-events:auto">–†–ï–°–¢–ê–†–¢</button></div>
      </div>
    </div>

    <div id="damageFlash" class="damage-flash"></div>
    <div id="loading" class="loading">–ó–ê–ì–†–£–ó–ö–ê...</div>
  </div>

  <script>
  // --------------------------
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å—Ü–µ–Ω—ã, —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ –∏ –ø–æ—Å—Ç-—ç—Ñ—Ñ–µ–∫—Ç–æ–≤
  // --------------------------
  let scene, camera, renderer, composer;
  let clock = new THREE.Clock();
  let ship;
  let starsPoints;
  let engineParticlesPool = [];
  let bulletsPool = [];
  let activeBullets = [];
  let activeExplosions = [];
  let asteroids = [], enemyShips = [], starFields = [], crystals = [], planets = [];
  let nebulas = [];
  let gameState = {
    health:100, stars:0, fragments:0, score:0,
    speed:2.0, rotationSpeed:0.03, isShieldActive:false, shieldEnergy:100,
    gameActive:false, touchControls:{left:false,right:false,shoot:false},
    upgrades:{engine:1,shield:1,weapon:1}, mission:{type:'collect',target:5,progress:0,reward:100}
  };
  const MAX_BULLETS = 60;
  const MAX_ENGINE_PARTICLES = 80;

  function initRenderer() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 6000);
    camera.position.set(0,8,25);

    renderer = new THREE.WebGLRenderer({antialias:true, alpha:false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    // –±–æ–ª–µ–µ —Å–≤–µ—Ç–ª—ã–π —Ñ–æ–Ω, –Ω–æ –Ω–µ –±–µ–ª—ã–π
    renderer.setClearColor(0x08121a, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('gameContainer').appendChild(renderer.domElement);

    // –ü–æ—Å—Ç—ç—Ñ—Ñ–µ–∫—Ç—ã ‚Äî composer + bloom
    composer = new THREE.EffectComposer(renderer);
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.9);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 0.9;
    bloomPass.radius = 0.5;
    composer.addPass(bloomPass);

    // gamma correction
    const gammaPass = new THREE.ShaderPass(THREE.GammaCorrectionShader);
    composer.addPass(gammaPass);
  }

  function addLights() {
    const amb = new THREE.AmbientLight(0x8aaacc, 0.9);
    scene.add(amb);

    const dir = new THREE.DirectionalLight(0xffffff, 1.2);
    dir.position.set(20,30,10);
    dir.castShadow = true;
    dir.shadow.mapSize.width = dir.shadow.mapSize.height = 2048;
    scene.add(dir);

    // rim light / backlight
    const rim = new THREE.DirectionalLight(0x66bbff, 0.6);
    rim.position.set(-10, -5, -20);
    scene.add(rim);

    // small front fill
    const fill = new THREE.PointLight(0xaaffff, 0.4, 500);
    fill.position.set(0,5,50);
    scene.add(fill);
  }

  // --------------------------
  // –ó–≤—ë–∑–¥–Ω–æ–µ –Ω–µ–±–æ (Points) ‚Äî —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π
  // --------------------------
  function createStarfield() {
    const starCount = 3000;
    const positions = new Float32Array(starCount * 3);
    const colors = new Float32Array(starCount * 3);
    const sizes = new Float32Array(starCount);

    for (let i=0;i<starCount;i++){
      const i3 = i*3;
      positions[i3] = (Math.random()-0.5)*4000;
      positions[i3+1] = (Math.random()-0.5)*2000;
      positions[i3+2] = (Math.random()-0.5)*6000 - 1000;
      const c = Math.random();
      if (c < 0.7) { colors[i3]=1; colors[i3+1]=1; colors[i3+2]=1; }
      else if (c < 0.9) { colors[i3]=0.8; colors[i3+1]=0.9; colors[i3+2]=1; }
      else { colors[i3]=1; colors[i3+1]=0.9; colors[i3+2]=0.6; }
      sizes[i] = Math.random()*2 + 0.5;
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    geom.setAttribute('size', new THREE.BufferAttribute(sizes,1));

    const mat = new THREE.PointsMaterial({
      vertexColors:true,
      size:2.2,
      sizeAttenuation:true,
      transparent:true,
      opacity:0.95,
      blending:THREE.AdditiveBlending
    });

    starsPoints = new THREE.Points(geom, mat);
    scene.add(starsPoints);
  }

  // --------------------------
  // Nebulas (–ø—Ä–æ—Å—Ç—ã–µ –±–æ–ª—å—à–∏–µ —Å—Ñ–µ—Ä—ã —Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å—é)
  // --------------------------
  function createNebulas() {
    for (let i=0;i<4;i++){
      const g = new THREE.SphereGeometry(400 + Math.random()*300, 32, 32);
      const mat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().setHSL(Math.random(),0.6,0.45),
        transparent:true,
        opacity:0.06,
        side:THREE.BackSide,
        depthWrite:false
      });
      const m = new THREE.Mesh(g, mat);
      m.position.set((Math.random()-0.5)*2000, (Math.random()-0.5)*1200, (Math.random()-0.5)*3000 - 800);
      scene.add(m);
      nebulas.push(m);
    }
  }

  // --------------------------
  // –ö–æ—Ä–∞–±–ª—å (Group) + –ø—É–ª —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è (–ø—É–ª)
  // --------------------------
  function createShip() {
    const group = new THREE.Group();

    const hull = new THREE.ConeGeometry(3.5,10,6);
    const matHull = new THREE.MeshStandardMaterial({color:0x0088ff, metalness:0.5, roughness:0.25, emissive:0x002244, emissiveIntensity:0.6});
    const hullMesh = new THREE.Mesh(hull, matHull);
    hullMesh.rotation.x = -Math.PI/2;
    hullMesh.castShadow = true;
    group.add(hullMesh);

    const wingGeom = new THREE.BoxGeometry(7,0.8,3);
    const wingMat = new THREE.MeshStandardMaterial({color:0x0066aa, metalness:0.4, roughness:0.4, emissive:0x001122});
    const leftWing = new THREE.Mesh(wingGeom, wingMat); leftWing.position.set(-5,0,0); group.add(leftWing);
    const rightWing = leftWing.clone(); rightWing.position.set(5,0,0); group.add(rightWing);

    const engineGeom = new THREE.CylinderGeometry(0.9,1.2,2.6,12);
    const engineMat = new THREE.MeshStandardMaterial({color:0xff6f00, emissive:0xff3800, emissiveIntensity:0.9, metalness:0.1, roughness:0.3});
    const leftEngine = new THREE.Mesh(engineGeom, engineMat); leftEngine.rotation.x = Math.PI/2; leftEngine.position.set(-2.5,0,4); group.add(leftEngine);
    const rightEngine = leftEngine.clone(); rightEngine.position.set(2.5,0,4); group.add(rightEngine);

    group.position.set(0,0,15);
    scene.add(group);
    ship = group;

    // prepare engine particles pool (shared geometry)
    const particleGeom = new THREE.BufferGeometry();
    const positions = new Float32Array(MAX_ENGINE_PARTICLES*3);
    const colors = new Float32Array(MAX_ENGINE_PARTICLES*3);
    for (let i=0;i<MAX_ENGINE_PARTICLES;i++){
      const i3 = i*3;
      positions[i3]= (Math.random()-0.5)*1.5;
      positions[i3+1]= (Math.random()-0.5)*1.5;
      positions[i3+2]= 3 + Math.random()*5;
      colors[i3]=1; colors[i3+1]=0.5 + Math.random()*0.5; colors[i3+2]=0;
    }
    particleGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    particleGeom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const particleMat = new THREE.PointsMaterial({size:2.8, vertexColors:true, transparent:true, opacity:0.95, blending:THREE.AdditiveBlending});
    const particles = new THREE.Points(particleGeom, particleMat);
    particles.frustumCulled = false; // —á—Ç–æ–±—ã –Ω–µ "–∏—Å—á–µ–∑–∞–ª–∏"
    ship.add(particles);
    engineParticlesPool.push({points:particles, geom:particleGeom});
  }

  // --------------------------
  // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ (–∞—Å—Ç–µ—Ä–æ–∏–¥—ã, –≤—Ä–∞–≥–∏, —Ä–µ—Å—É—Ä—Å—ã)
  // --------------------------
  function makeAsteroid(size=6, x=0,y=0,z=-200) {
    const geom = new THREE.IcosahedronGeometry(size, 1);
    const mat = new THREE.MeshStandardMaterial({color:0xaaaaaa, metalness:0.1, roughness:0.6, emissive:0x111111});
    const m = new THREE.Mesh(geom, mat);
    m.position.set(x,y,z);
    m.userData = {rotationSpeed:{x:(Math.random()-0.5)*0.02,y:(Math.random()-0.5)*0.02,z:(Math.random()-0.5)*0.02}, radius:size};
    m.castShadow = true;
    scene.add(m);
    asteroids.push(m);
  }

  function generateAsteroids(count=20) {
    for (let i=0;i<count;i++){
      if (Math.random()<0.25) continue;
      const sz = Math.random()*6 + 2;
      const x=(Math.random()-0.5)*800;
      const y=(Math.random()-0.5)*200;
      const z = -200 - Math.random()*1600;
      makeAsteroid(sz,x,y,z);
    }
  }

  function generateEnemyShips(count=8) {
    for (let i=0;i<count;i++){
      if (Math.random()<0.4) continue;
      const geom = new THREE.OctahedronGeometry(5,0);
      const mat = new THREE.MeshStandardMaterial({color:0xff5533, emissive:0x660000, metalness:0.3, roughness:0.4});
      const e = new THREE.Mesh(geom, mat);
      e.position.set((Math.random()-0.5)*600, (Math.random()-0.5)*150, -300 - Math.random()*1200);
      e.userData = {health:25, speed:0.5 + Math.random()*0.6};
      e.castShadow = true;
      scene.add(e);
      enemyShips.push(e);
    }
  }

  function generateStarFields(count=12) {
    for (let i=0;i<count;i++){
      const geom = new THREE.SphereGeometry(3+Math.random()*3,12,12);
      const mat = new THREE.MeshStandardMaterial({color:0xffee66, emissive:0xffdd55, emissiveIntensity:0.8, metalness:0.2, roughness:0.2});
      const m = new THREE.Mesh(geom,mat);
      m.position.set((Math.random()-0.5)*700, (Math.random()-0.5)*180, -250 - Math.random()*1300);
      m.userData = {rotationSpeed:(Math.random()-0.5)*0.03, collected:false};
      scene.add(m);
      starFields.push(m);
    }
  }

  function generateCrystals(count=10) {
    for (let i=0;i<count;i++){
      const geom = new THREE.OctahedronGeometry(2.6,0);
      const mat = new THREE.MeshStandardMaterial({color:0xff00ff, emissive:0x880088, emissiveIntensity:0.9, metalness:0.1, roughness:0.3});
      const m = new THREE.Mesh(geom,mat);
      m.position.set((Math.random()-0.5)*750, (Math.random()-0.5)*200, -200 - Math.random()*1400);
      m.userData = {rotationSpeed:(Math.random()-0.5)*0.02, collected:false};
      scene.add(m);
      crystals.push(m);
    }
  }

  function generatePlanets(count=3) {
    const planetData = [
      {name:"–ö–†–ò–û–ù–ò–°", color:0x88ccff, size:25, dialog:"–õ–µ–¥—è–Ω–æ–π –≥–∏–≥–∞–Ω—Ç"},
      {name:"–ü–ò–†–û–°", color:0xff6633, size:30, dialog:"–í—É–ª–∫–∞–Ω–∏—á–µ—Å–∫–∏–π –º–∏—Ä"},
      {name:"–í–ï–†–î–ê–ù–¢", color:0x44ff88, size:22, dialog:"–ë–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ç–Ω—ã–π"}
    ];
    for (let i=0;i<count;i++){
      const p = planetData[Math.floor(Math.random()*planetData.length)];
      const geom = new THREE.SphereGeometry(p.size, 32,32);
      const mat = new THREE.MeshStandardMaterial({color:p.color, emissive:new THREE.Color(p.color).multiplyScalar(0.2), roughness:0.5});
      const m = new THREE.Mesh(geom,mat);
      m.position.set((Math.random()-0.5)*1000, (Math.random()-0.5)*300, -600 - Math.random()*2000);
      m.userData = {size:p.size, planetData:p};
      scene.add(m);
      planets.push(m);
    }
  }

  // --------------------------
  // –ü—É–ª—ã –ø—É–ª—å (recycle)
  // --------------------------
  function initBulletPool() {
    const geom = new THREE.SphereGeometry(0.7,8,8);
    const mat = new THREE.MeshBasicMaterial({color:0xffff66, emissive:0xffff66});
    for (let i=0;i<MAX_BULLETS;i++){
      const m = new THREE.Mesh(geom, mat);
      m.visible = false;
      m.userData = {velocity:new THREE.Vector3(), lifetime:0};
      scene.add(m);
      bulletsPool.push(m);
    }
  }

  function getBulletFromPool() {
    for (let i=0;i<bulletsPool.length;i++){
      if (!bulletsPool[i].visible) return bulletsPool[i];
    }
    return null;
  }

  // --------------------------
  // –°—Ç—Ä–µ–ª—å–±–∞ ‚Äî –±–µ—Ä—ë–º –ø—É–ª—å –∏–∑ –ø—É–ª–∞
  // --------------------------
  function shoot() {
    if (!gameState.gameActive || !ship) return;
    const b = getBulletFromPool();
    if (!b) return;
    b.visible = true;
    b.position.copy(ship.position);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
    b.userData.velocity.copy(dir).multiplyScalar(18 * (1 + (gameState.upgrades.weapon-1)*0.25));
    b.userData.lifetime = 80;
    activeBullets.push(b);
    // muzzle flash ‚Äî –±—ã—Å—Ç—Ä—ã–π scale –ø—É–ª–∞ –º–∞–ª–µ–Ω—å–∫–æ–π —Å—Ñ–µ—Ä—ã
    const flash = new THREE.Mesh(new THREE.SphereGeometry(1.8,8,8), new THREE.MeshBasicMaterial({color:0xffffaa, transparent:true, opacity:0.9}));
    flash.position.copy(ship.position).add(dir.clone().multiplyScalar(-8));
    scene.add(flash);
    setTimeout(()=>scene.remove(flash),80);
  }

  // --------------------------
  // –í—Ä–∞–≥–∏ —Å—Ç—Ä–µ–ª—è—é—Ç –ª–∞–∑–µ—Ä–∞–º–∏ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ)
  // --------------------------
  function createEnemyLaser(from, to) {
    const dir = to.clone().sub(from).normalize();
    const geom = new THREE.CylinderGeometry(0.18,0.18,12,8);
    const mat = new THREE.MeshBasicMaterial({color:0xff6666});
    const laser = new THREE.Mesh(geom, mat);
    laser.position.copy(from);
    laser.lookAt(to);
    laser.rotateX(Math.PI/2);
    laser.userData = {velocity:dir.clone().multiplyScalar(12), lifetime:60};
    scene.add(laser);
    // interval-based movement simplified into activeExplosions array for update
    activeExplosions.push({type:'laser', mesh:laser});
  }

  // --------------------------
  // –≠—Ñ—Ñ–µ–∫—Ç—ã: –≤–∑—Ä—ã–≤ (–ø—Ä–æ—Å—Ç–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Å —Ç–æ—á–∫–∞–º–∏) ‚Äî —Å –ø—É–ª–æ–º
  // --------------------------
  function createExplosion(pos, size=18) {
    const particleCount = 22;
    const positions = new Float32Array(particleCount*3);
    const colors = new Float32Array(particleCount*3);
    const geom = new THREE.BufferGeometry();
    for (let i=0;i<particleCount;i++){
      const i3 = i*3;
      positions[i3] = pos.x + (Math.random()-0.5)*size;
      positions[i3+1] = pos.y + (Math.random()-0.5)*size;
      positions[i3+2] = pos.z + (Math.random()-0.5)*size;
      colors[i3]=1; colors[i3+1]=0.4+Math.random()*0.4; colors[i3+2]=0;
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const mat = new THREE.PointsMaterial({size:3.2, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending});
    const pts = new THREE.Points(geom, mat);
    pts.userData = {life:1.0};
    pts.position.set(0,0,0);
    scene.add(pts);
    activeExplosions.push({type:'points', mesh:pts});
  }

  // --------------------------
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è (–º–µ–Ω—è–µ–º positions attr)
  // --------------------------
  function updateEngineParticles(delta) {
    engineParticlesPool.forEach(entry => {
      const positions = entry.geom.attributes.position.array;
      for (let i=0;i<positions.length;i+=3){
        positions[i+2] += (1.0 + Math.random()*1.0) * (1 + (gameState.touchControls.shoot?0.5:0)) * (1 + (gameState.upgrades.engine-1)*0.15);
        if (positions[i+2] > 18) {
          positions[i] = (Math.random()-0.5)*1.8;
          positions[i+1] = (Math.random()-0.5)*1.8;
          positions[i+2] = 2 + Math.random()*5;
        }
      }
      entry.geom.attributes.position.needsUpdate = true;
      // pulsate emissive intensity
      entry.points.material.opacity = 0.7 + Math.abs(Math.sin(perfTime*6))*0.3;
    });
  }

  // --------------------------
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ–≥–æ ‚Äî game loop
  // --------------------------
  let perfTime = 0;
  function update(delta) {
    perfTime += delta;
    if (!gameState.gameActive) return;

    // –¥–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è –≤–ø–µ—Ä—ë–¥
    if (ship) {
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
      ship.position.add(dir.clone().multiplyScalar(gameState.speed * (1 + (gameState.upgrades.engine-1)*0.15) * delta * 60));
      // —Ä—É—á–Ω–∞—è —Ä–æ—Ç–∞—Ü–∏—è
      if (gameState.touchControls.left) ship.rotation.y += gameState.rotationSpeed * delta * 60;
      if (gameState.touchControls.right) ship.rotation.y -= gameState.rotationSpeed * delta * 60;

      // –∫–∞–º–µ—Ä–∞ —Å–ª–µ–¥—É–µ—Ç
      const cameraOffset = new THREE.Vector3(0,8,25).applyQuaternion(ship.quaternion);
      camera.position.copy(ship.position).add(cameraOffset);
      const lookDir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
      camera.lookAt(ship.position.clone().add(lookDir.multiplyScalar(90)));
    }

    // update engine particles
    updateEngineParticles(delta);

    // move stars slowly to simulate flight
    if (starsPoints) {
      starsPoints.position.z += 0.15 * delta * 60;
      if (starsPoints.position.z > 2000) starsPoints.position.z = -2000;
    }

    // nebulas rotate
    nebulas.forEach(n => n.rotation.y += 0.0005 * delta * 60);

    // bullets update
    for (let i=activeBullets.length-1;i>=0;i--){
      const b = activeBullets[i];
      b.position.add(b.userData.velocity.clone().multiplyScalar(delta*60));
      b.userData.lifetime--;
      // collision with enemies
      for (let j=enemyShips.length-1;j>=0;j--){
        const e = enemyShips[j];
        if (b.position.distanceTo(e.position) < 8) {
          e.userData.health -= 10 * (1 + (gameState.upgrades.weapon-1)*0.2);
          b.visible = false;
          activeBullets.splice(i,1);
          if (e.userData.health <= 0) {
            createExplosion(e.position.clone(), 16);
            scene.remove(e);
            enemyShips.splice(j,1);
            gameState.fragments += 8;
            gameState.score += 50;
            generateEnemyShips(1);
          }
          break;
        }
      }
      // remove bullets out of range
      if (b.userData.lifetime <= 0 || b.position.distanceTo(ship.position) > 600) {
        b.visible = false;
        const idx = activeBullets.indexOf(b);
        if (idx>=0) activeBullets.splice(idx,1);
      }
    }

    // asteroids
    for (let i=asteroids.length-1;i>=0;i--){
      const a = asteroids[i];
      a.rotation.x += a.userData.rotationSpeed.x * delta * 60;
      a.rotation.y += a.userData.rotationSpeed.y * delta * 60;
      a.rotation.z += a.userData.rotationSpeed.z * delta * 60;
      a.position.z += 0.6 * delta * 60;
      // collision
      if (ship && ship.position.distanceTo(a.position) < (a.userData.radius + 6)) {
        if (gameState.isShieldActive) {
          gameState.shieldEnergy -= 15;
        } else {
          gameState.health -= 12;
          flashDamage();
        }
        createExplosion(a.position.clone(), a.userData.radius*1.5);
        scene.remove(a); asteroids.splice(i,1); generateAsteroids(1);
      }
      if (a.position.z > ship.position.z + 500) { scene.remove(a); asteroids.splice(i,1); generateAsteroids(1); }
    }

    // enemy ships
    for (let i=enemyShips.length-1;i>=0;i--){
      const e = enemyShips[i];
      const dx = ship.position.x - e.position.x;
      const dz = ship.position.z - e.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < 220) {
        e.position.x += dx * 0.008 * e.userData.speed * delta * 60;
        e.position.z += dz * 0.008 * e.userData.speed * delta * 60;
      } else {
        e.position.z += 0.2 * delta * 60;
      }
      // enemy fire
      if (Math.random() < 0.002 && dist < 200) {
        createEnemyLaser(e.position.clone(), ship.position.clone());
      }
      if (ship && e.position.distanceTo(ship.position) < 12) {
        if (gameState.isShieldActive) gameState.shieldEnergy -= 20;
        else { gameState.health -= 18; flashDamage(); }
        createExplosion(e.position.clone(), 12);
        scene.remove(e); enemyShips.splice(i,1); generateEnemyShips(1);
      }
      if (e.position.z > ship.position.z + 450) { scene.remove(e); enemyShips.splice(i,1); generateEnemyShips(1); }
    }

    // starfields collect
    for (let i=starFields.length-1;i>=0;i--){
      const s = starFields[i];
      s.rotation.y += s.userData.rotationSpeed * delta * 60;
      if (ship && ship.position.distanceTo(s.position) < 10 && !s.userData.collected) {
        s.userData.collected = true;
        gameState.stars++; gameState.score += 15;
        createCollectEffect(s.position.clone());
        setTimeout(()=>{ scene.remove(s); starFields.splice(i,1); generateStarFields(1); }, 300);
      }
      if (s.position.z > ship.position.z + 400) { scene.remove(s); starFields.splice(i,1); generateStarFields(1); }
    }

    // crystals
    for (let i=crystals.length-1;i>=0;i--){
      const c = crystals[i];
      c.rotation.y += c.userData.rotationSpeed * delta * 60;
      if (ship && ship.position.distanceTo(c.position) < 8 && !c.userData.collected) {
        c.userData.collected = true;
        gameState.fragments += 3; gameState.score += 25;
        createCollectEffect(c.position.clone());
        setTimeout(()=>{ scene.remove(c); crystals.splice(i,1); generateCrystals(1); }, 300);
      }
      if (c.position.z > ship.position.z + 400) { scene.remove(c); crystals.splice(i,1); generateCrystals(1); }
    }

    // planets rotation and landing
    for (let i=planets.length-1;i>=0;i--){
      const p = planets[i];
      p.rotation.y += 0.001 * delta * 60;
      if (ship && ship.position.distanceTo(p.position) < p.userData.size + 24) {
        // landing: pause game and show planet UI (simplified)
        gameState.gameActive = false;
        showScreen('menuScreen'); // –ù–∞ –º–µ—Å—Ç–æ –ø–ª–∞–Ω–µ—Ç–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ –¥–æ–±–∞–≤—å —Å–≤–æ–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
      }
      if (p.position.z > ship.position.z + 700) { scene.remove(p); planets.splice(i,1); generatePlanets(1); }
    }

    // shield regen
    if (!gameState.isShieldActive && gameState.shieldEnergy < 100) gameState.shieldEnergy = Math.min(gameState.shieldEnergy + 0.12*delta*60, 100);

    // update active laser/explosion points
    for (let i=activeExplosions.length-1;i>=0;i--){
      const obj = activeExplosions[i];
      if (obj.type === 'laser') {
        obj.mesh.position.add(obj.mesh.userData.velocity.clone().multiplyScalar(delta*60));
        obj.mesh.userData.lifetime--;
        if (obj.mesh.userData.lifetime <= 0) { scene.remove(obj.mesh); activeExplosions.splice(i,1); }
        if (ship && obj.mesh.position.distanceTo(ship.position) < 8) {
          if (gameState.isShieldActive) gameState.shieldEnergy -= 8;
          else { gameState.health -= 8; flashDamage(); }
          createExplosion(obj.mesh.position.clone(), 10);
          scene.remove(obj.mesh); activeExplosions.splice(i,1);
        }
      } else if (obj.type === 'points') {
        obj.mesh.userData.life -= 0.02 * delta * 60;
        obj.mesh.material.opacity = Math.max(0, obj.mesh.userData.life);
        if (obj.mesh.userData.life <= 0) { scene.remove(obj.mesh); activeExplosions.splice(i,1); }
      }
    }

    // level progression score
    gameState.score += 0.02 * delta * 60 * gameState.speed;

    // check mission completion and death
    if (gameState.mission.progress >= gameState.mission.target) {
      completeMission();
    }
    if (gameState.health <= 0) {
      gameOver();
    }

    // UI update
    updateUI();
  }

  function createCollectEffect(pos) {
    // small sparkle effect (points)
    createExplosion(pos, 6);
  }

  function flashDamage() {
    const el = document.getElementById('damageFlash');
    el.style.transition = 'opacity 60ms';
    el.style.opacity = '0.55';
    setTimeout(()=>{ el.style.opacity = '0'; }, 140);
  }

  function updateUI(){
    document.getElementById('healthValue').textContent = Math.max(0, Math.round(gameState.health));
    document.getElementById('shieldValue').textContent = Math.round(gameState.shieldEnergy);
    document.getElementById('starsValue').textContent = gameState.stars;
    document.getElementById('fragmentsValue').textContent = gameState.fragments;
    document.getElementById('scoreValue').textContent = Math.round(gameState.score);
    document.getElementById('missionValue').textContent = `${gameState.mission.progress}/${gameState.mission.target}`;
  }

  function completeMission(){
    gameState.stars += gameState.mission.reward;
    gameState.score += gameState.mission.reward*10;
    gameState.mission = {type:Math.random()>0.5?'collect':'destroy', target:5+Math.floor(Math.random()*6), progress:0, reward:100+Math.floor(Math.random()*100)};
    const msg = document.createElement('div');
    msg.style.cssText = 'position:fixed;left:50%;top:20%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#0ff;padding:10px 18px;border-radius:8px;border:1px solid #0ff';
    msg.textContent = 'üéâ –ú–∏—Å—Å–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!';
    document.body.appendChild(msg);
    setTimeout(()=>document.body.removeChild(msg),2400);
  }

  function gameOver() {
    gameState.gameActive = false;
    document.getElementById('finalScore').textContent = Math.round(gameState.score);
    showScreen('gameOver');
  }

  // --------------------------
  // —ç–∫—Ä–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª
  // --------------------------
  function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden'));
    document.getElementById(id).classList.remove('hidden');
  }

  // --------------------------
  // Controls (touch + keyboard)
  // --------------------------
  function setupControls() {
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const shootBtn = document.getElementById('shootBtn');
    const shieldBtn = document.getElementById('shieldBtn');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');

    function addHold(btn, name){
      btn.addEventListener('touchstart', e=>{ e.preventDefault(); gameState.touchControls[name]=true; });
      btn.addEventListener('touchend', e=>{ e.preventDefault(); gameState.touchControls[name]=false; });
      btn.addEventListener('mousedown', e=>{ e.preventDefault(); gameState.touchControls[name]=true; });
      btn.addEventListener('mouseup', e=>{ e.preventDefault(); gameState.touchControls[name]=false; });
      btn.addEventListener('mouseleave', e=>{ gameState.touchControls[name]=false; });
    }
    addHold(leftBtn, 'left'); addHold(rightBtn,'right'); addHold(shootBtn,'shoot');

    shieldBtn.addEventListener('click', ()=>{ activateShield(); });
    startBtn.addEventListener('click', ()=>{ startGame(); });
    restartBtn.addEventListener('click', ()=>{ startGame(); });

    window.addEventListener('keydown', e=>{
      if (!gameState.gameActive) return;
      if (e.key==='a' || e.key==='ArrowLeft') gameState.touchControls.left=true;
      if (e.key==='d' || e.key==='ArrowRight') gameState.touchControls.right=true;
      if (e.key===' ') gameState.touchControls.shoot=true;
      if (e.key==='s') activateShield();
    });
    window.addEventListener('keyup', e=>{
      if (e.key==='a' || e.key==='ArrowLeft') gameState.touchControls.left=false;
      if (e.key==='d' || e.key==='ArrowRight') gameState.touchControls.right=false;
      if (e.key===' ') gameState.touchControls.shoot=false;
    });
  }

  function activateShield(){
    if (gameState.shieldEnergy >= 25 && !gameState.isShieldActive) {
      gameState.isShieldActive = true;
      gameState.shieldEnergy -= 25;
      // visual sphere
      const geom = new THREE.SphereGeometry(10, 16,16);
      const mat = new THREE.MeshBasicMaterial({color:0x00ffff, transparent:true, opacity:0.28, side:THREE.DoubleSide});
      const s = new THREE.Mesh(geom, mat);
      ship.add(s);
      setTimeout(()=>{ ship.remove(s); gameState.isShieldActive=false; }, 3000);
    }
  }

  // --------------------------
  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≤—Å–µ–≥–æ –∏ –∑–∞–ø—É—Å–∫
  // --------------------------
  function startGame(){
    gameState.health=100; gameState.stars=0; gameState.fragments=0; gameState.score=0;
    gameState.speed=2; gameState.isShieldActive=false; gameState.shieldEnergy=100; gameState.gameActive=true;
    gameState.upgrades={engine:1,shield:1,weapon:1};
    gameState.mission={type:Math.random()>0.5?'collect':'destroy', target:5, progress:0, reward:100};
    if (ship) { ship.position.set(0,0,15); ship.rotation.set(0,0,0); }

    // clear scene objects arrays
    asteroids.forEach(o=>scene.remove(o)); asteroids=[];
    enemyShips.forEach(o=>scene.remove(o)); enemyShips=[];
    starFields.forEach(o=>scene.remove(o)); starFields=[];
    crystals.forEach(o=>scene.remove(o)); crystals=[];
    planets.forEach(o=>scene.remove(o)); planets=[];
    // bullets pool stays
    // generate new content
    generateAsteroids(28); generateEnemyShips(12); generateStarFields(18); generateCrystals(12); generatePlanets(4);
    showScreen('gameScreen');
  }

  // --------------------------
  // init and loop
  // --------------------------
  function init() {
    initRenderer(); addLights(); createStarfield(); createNebulas(); createShip();
    initBulletPool(); setupControls();

    // small delay
    document.getElementById('loading').style.display='none';
    showScreen('menuScreen');

    onWindowResize();
    animate();
  }

  function onWindowResize(){
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onWindowResize);

  function animate(){
    requestAnimationFrame(animate);
    const delta = Math.min(clock.getDelta(), 0.05);
    // shoot auto if hold
    if (gameState.touchControls.shoot && gameState.gameActive) {
      if (!gameState._lastShotTime || performance.now() - gameState._lastShotTime > (300 / (1+ (gameState.upgrades.weapon-1)*0.2))) {
        shoot();
        gameState._lastShotTime = performance.now();
      }
    }
    update(delta);
    composer.render(delta);
  }

  // –∑–∞–ø—É—Å–∫
  window.addEventListener('load', init);
  </script>
</body>
</html>
