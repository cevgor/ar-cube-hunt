<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Z.E.R.O.: Last Breach</title>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
:root {
  --neon: #00ffea;
  --accent: #ff6b6b;
  --bg: #05060a;
  --text: #ffffff;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Arial', sans-serif;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
}

#app {
  width: 100%;
  height: 100%;
  position: relative;
}

/* ========= SCREENS ========= */
.screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.screen.active {
  display: flex;
}

/* ========= MAIN MENU ========= */
#mainMenu {
  background: linear-gradient(135deg, #0a0b14 0%, #15182a 100%);
}

.menu-container {
  text-align: center;
  padding: 2rem;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 20px;
  border: 2px solid var(--neon);
  box-shadow: 0 0 30px rgba(0, 255, 234, 0.3);
  backdrop-filter: blur(10px);
}

.game-title {
  font-size: 4rem;
  background: linear-gradient(45deg, var(--neon), #ff00ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 1rem;
  text-shadow: 0 0 20px rgba(0, 255, 234, 0.5);
}

.game-subtitle {
  font-size: 1.2rem;
  color: var(--neon);
  margin-bottom: 2rem;
  opacity: 0.8;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  width: 300px;
}

.menu-btn {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  background: linear-gradient(45deg, #1a1f38, #2d3758);
  border: 2px solid var(--neon);
  color: var(--neon);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.menu-btn:hover {
  background: linear-gradient(45deg, #2d3758, #1a1f38);
  box-shadow: 0 0 20px rgba(0, 255, 234, 0.5);
  transform: translateY(-2px);
}

/* ========= GAME SCREEN ========= */
#gameScreen {
  background: #000;
}

#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

/* ========= GAME UI ========= */
#gameUI {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 500;
}

/* Health Bar */
.health-container {
  position: absolute;
  top: 20px;
  left: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid var(--neon);
}

.health-bar {
  width: 200px;
  height: 20px;
  background: #333;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 5px;
}

.health-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b6b, #ff2b2b);
  transition: width 0.3s ease;
  width: 100%;
}

.health-text {
  color: var(--neon);
  font-size: 1.1rem;
}

/* Ammo & Wave */
.stats-container {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid var(--neon);
  text-align: right;
}

.ammo-text, .wave-text {
  color: var(--neon);
  font-size: 1.1rem;
  margin-bottom: 5px;
}

/* Weapon Selector */
.weapon-selector {
  position: absolute;
  bottom: 120px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px;
  border-radius: 10px;
  border: 2px solid var(--neon);
}

.weapon-btn {
  width: 60px;
  height: 60px;
  background: #1a1f38;
  border: 2px solid transparent;
  border-radius: 8px;
  color: var(--neon);
  cursor: pointer;
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  transition: all 0.3s ease;
}

.weapon-btn.active {
  border-color: var(--neon);
  box-shadow: 0 0 10px rgba(0, 255, 234, 0.5);
}

/* Controls */
.controls-container {
  position: absolute;
  bottom: 20px;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
}

/* Left Controls (Movement) */
.left-controls {
  display: flex;
  gap: 10px;
}

.control-btn {
  width: 70px;
  height: 70px;
  background: rgba(0, 255, 234, 0.2);
  border: 2px solid var(--neon);
  border-radius: 50%;
  color: var(--neon);
  font-size: 1.5rem;
  cursor: pointer;
  pointer-events: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.control-btn:active {
  background: rgba(0, 255, 234, 0.4);
  transform: scale(0.95);
}

/* Right Controls (Actions) */
.right-controls {
  display: flex;
  gap: 10px;
  align-items: flex-end;
}

.action-btn {
  width: 80px;
  height: 80px;
  background: rgba(255, 107, 107, 0.2);
  border: 2px solid var(--accent);
  border-radius: 50%;
  color: var(--accent);
  font-size: 1.8rem;
  cursor: pointer;
  pointer-events: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.action-btn:active {
  background: rgba(255, 107, 107, 0.4);
  transform: scale(0.95);
}

.reload-btn {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid var(--text);
  color: var(--text);
}

/* Crosshair */
.crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  pointer-events: none;
}

.crosshair::before,
.crosshair::after {
  content: '';
  position: absolute;
  background: var(--neon);
}

.crosshair::before {
  width: 2px;
  height: 20px;
  left: 50%;
  transform: translateX(-50%);
}

.crosshair::after {
  width: 20px;
  height: 2px;
  top: 50%;
  transform: translateY(-50%);
}

/* ========= PAUSE MENU ========= */
#pauseMenu {
  background: rgba(0, 0, 0, 0.9);
}

/* ========= SETTINGS ========= */
#settingsMenu {
  background: rgba(0, 0, 0, 0.9);
}

.settings-container {
  background: rgba(0, 0, 0, 0.8);
  padding: 2rem;
  border-radius: 20px;
  border: 2px solid var(--neon);
  width: 90%;
  max-width: 500px;
}

.setting-item {
  margin: 1rem 0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.setting-label {
  color: var(--neon);
  font-size: 1.1rem;
}

.setting-slider {
  width: 200px;
}

/* ========= ACHIEVEMENTS ========= */
.achievement-popup {
  position: fixed;
  top: 50px;
  right: 20px;
  background: linear-gradient(45deg, #1a1f38, #2d3758);
  border: 2px solid var(--neon);
  border-radius: 10px;
  padding: 1rem;
  color: var(--neon);
  transform: translateX(400px);
  transition: transform 0.5s ease;
  z-index: 1000;
}

.achievement-popup.show {
  transform: translateX(0);
}

.achievement-title {
  font-weight: bold;
  margin-bottom: 0.5rem;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .game-title {
    font-size: 2.5rem;
  }
  
  .control-btn, .action-btn {
    width: 60px;
    height: 60px;
    font-size: 1.2rem;
  }
  
  .weapon-btn {
    width: 50px;
    height: 50px;
    font-size: 0.7rem;
  }
}
</style>
</head>
<body>
<div id="app">
  <!-- Main Menu -->
  <div id="mainMenu" class="screen active">
    <div class="menu-container">
      <h1 class="game-title">Z.E.R.O.</h1>
      <p class="game-subtitle">LAST BREACH</p>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="startGame()">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        <button class="menu-btn" onclick="showScreen('settingsMenu')">–ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button class="menu-btn" onclick="showAchievements()">–î–û–°–¢–ò–ñ–ï–ù–ò–Ø</button>
      </div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="gameScreen" class="screen">
    <canvas id="gameCanvas"></canvas>
    
    <!-- Game UI -->
    <div id="gameUI">
      <!-- Health -->
      <div class="health-container">
        <div class="health-bar">
          <div class="health-fill" id="healthFill"></div>
        </div>
        <div class="health-text" id="healthText">100 HP</div>
      </div>

      <!-- Stats -->
      <div class="stats-container">
        <div class="ammo-text" id="ammoText">12/60</div>
        <div class="wave-text" id="waveText">–í–æ–ª–Ω–∞: 1</div>
      </div>

      <!-- Weapon Selector -->
      <div class="weapon-selector">
        <div class="weapon-btn active" data-weapon="0" onclick="switchWeapon(0)">
          <span>üî´</span>
          <span>–ü–∏—Å—Ç–æ–ª–µ—Ç</span>
        </div>
        <div class="weapon-btn" data-weapon="1" onclick="switchWeapon(1)">
          <span>üî´</span>
          <span>–ê–≤—Ç–æ–º–∞—Ç</span>
        </div>
        <div class="weapon-btn" data-weapon="2" onclick="switchWeapon(2)">
          <span>üî´</span>
          <span>–î—Ä–æ–±–æ–≤–∏–∫</span>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls-container">
        <!-- Left Controls -->
        <div class="left-controls">
          <div class="control-btn" id="moveForward">‚Üë</div>
          <div class="control-btn" id="moveLeft">‚Üê</div>
          <div class="control-btn" id="moveBack">‚Üì</div>
          <div class="control-btn" id="moveRight">‚Üí</div>
        </div>

        <!-- Right Controls -->
        <div class="right-controls">
          <div class="action-btn reload-btn" onclick="reloadWeapon()">‚Üª</div>
          <div class="action-btn" onclick="shoot()">üî´</div>
          <div class="action-btn" onclick="useSpecialAbility()">‚ö°</div>
        </div>
      </div>

      <!-- Crosshair -->
      <div class="crosshair"></div>
    </div>
  </div>

  <!-- Pause Menu -->
  <div id="pauseMenu" class="screen">
    <div class="menu-container">
      <h2>–ü–ê–£–ó–ê</h2>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="resumeGame()">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button class="menu-btn" onclick="showScreen('mainMenu')">–í –ú–ï–ù–Æ</button>
      </div>
    </div>
  </div>

  <!-- Settings Menu -->
  <div id="settingsMenu" class="screen">
    <div class="settings-container">
      <h2>–ù–ê–°–¢–†–û–ô–ö–ò</h2>
      <div class="setting-item">
        <span class="setting-label">–ì—Ä–æ–º–∫–æ—Å—Ç—å</span>
        <input type="range" class="setting-slider" id="volumeSlider" min="0" max="1" step="0.1" value="0.8">
      </div>
      <div class="setting-item">
        <span class="setting-label">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</span>
        <input type="range" class="setting-slider" id="sensitivitySlider" min="0.1" max="2" step="0.1" value="1">
      </div>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="saveSettings()">–°–û–•–†–ê–ù–ò–¢–¨</button>
        <button class="menu-btn" onclick="showScreen('mainMenu')">–ù–ê–ó–ê–î</button>
      </div>
    </div>
  </div>
</div>

<script>
// ========= GAME STATE =========
const GameState = {
  currentScreen: 'mainMenu',
  isRunning: false,
  isPaused: false,
  player: {
    health: 100,
    maxHealth: 100,
    position: { x: 0, y: 1.6, z: 0 },
    rotation: { x: 0, y: 0 }
  },
  weapons: [
    { type: 'pistol', ammo: 12, maxAmmo: 60, damage: 25, fireRate: 500 },
    { type: 'rifle', ammo: 30, maxAmmo: 180, damage: 15, fireRate: 100 },
    { type: 'shotgun', ammo: 8, maxAmmo: 32, damage: 40, fireRate: 800 }
  ],
  currentWeapon: 0,
  wave: 1,
  enemies: [],
  score: 0,
  achievements: new Set()
};

// ========= THREE.JS VARIABLES =========
let scene, camera, renderer;
let playerMesh, weaponMesh;
let enemies = [];
let obstacles = [];

// ========= INITIALIZATION =========
function initGame() {
  initThreeJS();
  initEventListeners();
  loadSettings();
  loadAchievements();
}

function initThreeJS() {
  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0b14);
  scene.fog = new THREE.Fog(0x0a0b14, 10, 100);

  // Camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 1.6, 0);

  // Renderer
  renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(50, 50, 25);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  // Create player
  createPlayer();
  createWeapon();
  generateMap();
}

function createPlayer() {
  const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
  const material = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  playerMesh = new THREE.Mesh(geometry, material);
  playerMesh.castShadow = true;
  scene.add(playerMesh);
}

function createWeapon() {
  const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.4);
  const material = new THREE.MeshStandardMaterial({ color: 0x333333 });
  weaponMesh = new THREE.Mesh(geometry, material);
  weaponMesh.position.set(0.3, -0.2, -0.5);
  camera.add(weaponMesh);
}

function generateMap() {
  // Ground
  const groundGeometry = new THREE.PlaneGeometry(100, 100);
  const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Random obstacles (buildings, trees)
  for (let i = 0; i < 20; i++) {
    const size = Math.random() * 3 + 2;
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshStandardMaterial({ 
      color: Math.random() * 0xffffff 
    });
    const obstacle = new THREE.Mesh(geometry, material);
    
    obstacle.position.set(
      (Math.random() - 0.5) * 80,
      size / 2,
      (Math.random() - 0.5) * 80
    );
    
    obstacle.castShadow = true;
    obstacle.receiveShadow = true;
    scene.add(obstacle);
    obstacles.push(obstacle);
  }

  // Boundary walls
  createBoundaryWalls();
}

function createBoundaryWalls() {
  const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
  
  // Create four walls around the map
  const walls = [
    { position: [0, 5, -50], size: [100, 10, 2] }, // North
    { position: [0, 5, 50], size: [100, 10, 2] },  // South
    { position: [-50, 5, 0], size: [2, 10, 100] }, // West
    { position: [50, 5, 0], size: [2, 10, 100] }   // East
  ];

  walls.forEach(wallData => {
    const geometry = new THREE.BoxGeometry(...wallData.size);
    const wall = new THREE.Mesh(geometry, wallMaterial);
    wall.position.set(...wallData.position);
    scene.add(wall);
    obstacles.push(wall);
  });
}

// ========= GAME LOGIC =========
function startGame() {
  showScreen('gameScreen');
  GameState.isRunning = true;
  GameState.wave = 1;
  GameState.player.health = 100;
  GameState.score = 0;
  
  // Clear previous enemies
  enemies.forEach(enemy => scene.remove(enemy.mesh));
  enemies = [];
  
  // Start first wave
  spawnWave();
  gameLoop();
}

function spawnWave() {
  const enemyCount = GameState.wave * 3 + 5;
  
  for (let i = 0; i < enemyCount; i++) {
    setTimeout(() => {
      if (GameState.isRunning && !GameState.isPaused) {
        spawnEnemy();
      }
    }, i * 500);
  }
}

function spawnEnemy() {
  const geometry = new THREE.CapsuleGeometry(0.5, 1, 4, 8);
  const material = new THREE.MeshStandardMaterial({ 
    color: GameState.wave > 5 ? 0xff0000 : 0xff6b6b 
  });
  const enemyMesh = new THREE.Mesh(geometry, material);
  
  // Random position around player
  const angle = Math.random() * Math.PI * 2;
  const distance = 15 + Math.random() * 10;
  enemyMesh.position.set(
    Math.cos(angle) * distance,
    1,
    Math.sin(angle) * distance
  );
  
  enemyMesh.castShadow = true;
  scene.add(enemyMesh);
  
  const enemy = {
    mesh: enemyMesh,
    health: GameState.wave > 5 ? 100 : 50,
    speed: 0.02,
    damage: GameState.wave > 5 ? 20 : 10
  };
  
  enemies.push(enemy);
}

function updateEnemies() {
  enemies.forEach((enemy, index) => {
    // Move towards player
    const direction = new THREE.Vector3()
      .subVectors(playerMesh.position, enemy.mesh.position)
      .normalize();
    
    enemy.mesh.position.addScaledVector(direction, enemy.speed);
    
    // Check collision with player
    const distance = enemy.mesh.position.distanceTo(playerMesh.position);
    if (distance < 1.5) {
      takeDamage(enemy.damage);
      
      // Knockback
      const knockback = direction.clone().multiplyScalar(-2);
      enemy.mesh.position.add(knockback);
    }
    
    // Simple enemy death
    if (enemy.health <= 0) {
      scene.remove(enemy.mesh);
      enemies.splice(index, 1);
      GameState.score += GameState.wave > 5 ? 50 : 25;
      
      // Check for achievements
      checkAchievements();
    }
  });
  
  // Check if wave is complete
  if (enemies.length === 0) {
    GameState.wave++;
    document.getElementById('waveText').textContent = `–í–æ–ª–Ω–∞: ${GameState.wave}`;
    
    if (GameState.wave === 5) {
      unlockAchievement('first_boss');
    }
    
    setTimeout(spawnWave, 2000);
  }
}

function takeDamage(amount) {
  GameState.player.health -= amount;
  updateHealthBar();
  
  if (GameState.player.health <= 0) {
    gameOver();
  }
}

function updateHealthBar() {
  const healthFill = document.getElementById('healthFill');
  const healthText = document.getElementById('healthText');
  const healthPercent = (GameState.player.health / GameState.player.maxHealth) * 100;
  
  healthFill.style.width = `${healthPercent}%`;
  healthText.textContent = `${Math.max(0, Math.round(GameState.player.health))} HP`;
}

function shoot() {
  if (!GameState.isRunning || GameState.isPaused) return;
  
  const weapon = GameState.weapons[GameState.currentWeapon];
  
  if (weapon.ammo <= 0) {
    // Play empty sound
    return;
  }
  
  weapon.ammo--;
  updateAmmoDisplay();
  
  // Weapon animation
  weaponMesh.position.z = -0.7;
  setTimeout(() => {
    weaponMesh.position.z = -0.5;
  }, 100);
  
  // Check for hits
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(new THREE.Vector2(), camera);
  
  const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh));
  
  if (intersects.length > 0) {
    const enemy = enemies.find(e => e.mesh === intersects[0].object);
    if (enemy) {
      enemy.health -= weapon.damage;
      
      // Hit effect
      enemy.mesh.material.color.set(0xffff00);
      setTimeout(() => {
        enemy.mesh.material.color.set(GameState.wave > 5 ? 0xff0000 : 0xff6b6b);
      }, 100);
    }
  }
}

function reloadWeapon() {
  const weapon = GameState.weapons[GameState.currentWeapon];
  const ammoNeeded = weapon.maxAmmo - weapon.ammo;
  
  if (ammoNeeded > 0) {
    // Reload animation
    weaponMesh.rotation.x = -Math.PI / 4;
    setTimeout(() => {
      weapon.ammo = weapon.maxAmmo;
      updateAmmoDisplay();
      weaponMesh.rotation.x = 0;
    }, 1000);
  }
}

function useSpecialAbility() {
  // Shockwave ability - push back all enemies
  enemies.forEach(enemy => {
    const direction = new THREE.Vector3()
      .subVectors(enemy.mesh.position, playerMesh.position)
      .normalize();
    
    enemy.mesh.position.addScaledVector(direction, 5);
    enemy.health -= 10;
  });
  
  // Visual effect
  const shockwaveGeometry = new THREE.SphereGeometry(1, 16, 16);
  const shockwaveMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ffff,
    transparent: true,
    opacity: 0.5
  });
  const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
  shockwave.position.copy(playerMesh.position);
  scene.add(shockwave);
  
  setTimeout(() => {
    scene.remove(shockwave);
  }, 500);
}

// ========= ACHIEVEMENTS =========
function loadAchievements() {
  const saved = localStorage.getItem('zero_achievements');
  if (saved) {
    GameState.achievements = new Set(JSON.parse(saved));
  }
}

function saveAchievements() {
  localStorage.setItem('zero_achievements', JSON.stringify([...GameState.achievements]));
}

function unlockAchievement(id) {
  if (!GameState.achievements.has(id)) {
    GameState.achievements.add(id);
    saveAchievements();
    showAchievementPopup(id);
    
    // Send to Telegram if available
    if (window.Telegram && Telegram.WebApp) {
      Telegram.WebApp.sendData(JSON.stringify({ achievement: id }));
    }
  }
}

function showAchievementPopup(id) {
  const achievements = {
    'first_kill': { title: '–ü–µ—Ä–≤—ã–π –∫—Ä–æ–≤—å!', desc: '–£–±–µ–π—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –∑–æ–º–±–∏' },
    'first_boss': { title: '–û—Ö–æ—Ç–Ω–∏–∫ –Ω–∞ –±–æ—Å—Å–æ–≤', desc: '–ü–æ–±–µ–¥–∏—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –±–æ—Å—Å–∞' },
    'wave_10': { title: '–ù–µ—É–¥–µ—Ä–∂–∏–º—ã–π', desc: '–î–æ–π–¥–∏—Ç–µ –¥–æ 10 –≤–æ–ª–Ω—ã' },
    'perfect_health': { title: '–ù–µ—É—è–∑–≤–∏–º—ã–π', desc: '–ü—Ä–æ–π–¥–∏—Ç–µ –≤–æ–ª–Ω—É –±–µ–∑ –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞' }
  };
  
  const achievement = achievements[id];
  if (achievement) {
    // Create and show popup
    const popup = document.createElement('div');
    popup.className = 'achievement-popup show';
    popup.innerHTML = `
      <div class="achievement-title">${achievement.title}</div>
      <div>${achievement.desc}</div>
    `;
    
    document.body.appendChild(popup);
    
    setTimeout(() => {
      popup.remove();
    }, 3000);
  }
}

function checkAchievements() {
  if (GameState.score >= 100 && !GameState.achievements.has('first_kill')) {
    unlockAchievement('first_kill');
  }
  
  if (GameState.wave >= 10 && !GameState.achievements.has('wave_10')) {
    unlockAchievement('wave_10');
  }
}

function showAchievements() {
  alert('–î–æ—Å—Ç–∏–∂–µ–Ω–∏—è –∑–∞–≥—Ä—É–∂–∞—é—Ç—Å—è...');
  // –ó–¥–µ—Å—å –º–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π —ç–∫—Ä–∞–Ω –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
}

// ========= UI MANAGEMENT =========
function showScreen(screenName) {
  document.querySelectorAll('.screen').forEach(screen => {
    screen.classList.remove('active');
  });
  
  document.getElementById(screenName).classList.add('active');
  GameState.currentScreen = screenName;
  
  if (screenName === 'gameScreen' && !GameState.isRunning) {
    startGame();
  }
}

function switchWeapon(index) {
  GameState.currentWeapon = index;
  
  // Update UI
  document.querySelectorAll('.weapon-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
  
  updateAmmoDisplay();
}

function updateAmmoDisplay() {
  const weapon = GameState.weapons[GameState.currentWeapon];
  document.getElementById('ammoText').textContent = 
    `${weapon.ammo}/${weapon.maxAmmo}`;
}

// ========= SETTINGS =========
function loadSettings() {
  const saved = localStorage.getItem('zero_settings');
  if (saved) {
    const settings = JSON.parse(saved);
    document.getElementById('volumeSlider').value = settings.volume || 0.8;
    document.getElementById('sensitivitySlider').value = settings.sensitivity || 1;
  }
}

function saveSettings() {
  const settings = {
    volume: parseFloat(document.getElementById('volumeSlider').value),
    sensitivity: parseFloat(document.getElementById('sensitivitySlider').value)
  };
  
  localStorage.setItem('zero_settings', JSON.stringify(settings));
  showScreen('mainMenu');
}

// ========= INPUT HANDLING =========
function initEventListeners() {
  // Keyboard
  document.addEventListener('keydown', handleKeyDown);
  document.addEventListener('keyup', handleKeyUp);
  
  // Touch controls
  initTouchControls();
  
  // Window resize
  window.addEventListener('resize', onWindowResize);
}

const keys = {
  w: false, a: false, s: false, d: false,
  ArrowUp: false, ArrowLeft: false, ArrowDown: false, ArrowRight: false
};

function handleKeyDown(event) {
  if (keys.hasOwnProperty(event.key)) {
    keys[event.key] = true;
  }
  
  // Weapon switching
  if (event.key >= '1' && event.key <= '3') {
    switchWeapon(parseInt(event.key) - 1);
  }
  
  // Shooting
  if (event.key === ' ') {
    shoot();
  }
  
  // Reload
  if (event.key === 'r') {
    reloadWeapon();
  }
  
  // Pause
  if (event.key === 'Escape') {
    togglePause();
  }
}

function handleKeyUp(event) {
  if (keys.hasOwnProperty(event.key)) {
    keys[event.key] = false;
  }
}

function initTouchControls() {
  // Movement buttons
  const moveButtons = ['moveForward', 'moveLeft', 'moveBack', 'moveRight'];
  
  moveButtons.forEach(buttonId => {
    const button = document.getElementById(buttonId);
    
    button.addEventListener('touchstart', (e) => {
      e.preventDefault();
      keys[getKeyFromButton(buttonId)] = true;
    });
    
    button.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys[getKeyFromButton(buttonId)] = false;
    });
  });
}

function getKeyFromButton(buttonId) {
  const mapping = {
    'moveForward': 'w',
    'moveLeft': 'a',
    'moveBack': 's',
    'moveRight': 'd'
  };
  return mapping[buttonId];
}

// ========= GAME LOOP =========
function gameLoop() {
  if (!GameState.isRunning || GameState.isPaused) return;
  
  updatePlayerMovement();
  updateEnemies();
  renderer.render(scene, camera);
  
  requestAnimationFrame(gameLoop);
}

function updatePlayerMovement() {
  const moveSpeed = 0.1;
  const moveVector = new THREE.Vector3();
  
  if (keys.w || keys.ArrowUp) moveVector.z -= moveSpeed;
  if (keys.s || keys.ArrowDown) moveVector.z += moveSpeed;
  if (keys.a || keys.ArrowLeft) moveVector.x -= moveSpeed;
  if (keys.d || keys.ArrowRight) moveVector.x += moveSpeed;
  
  // Simple collision detection
  const newPosition = playerMesh.position.clone().add(moveVector);
  let canMove = true;
  
  obstacles.forEach(obstacle => {
    const obstacleBox = new THREE.Box3().setFromObject(obstacle);
    const playerBox = new THREE.Box3().setFromCenterAndSize(
      newPosition, 
      new THREE.Vector3(1, 2, 1)
    );
    
    if (obstacleBox.intersectsBox(playerBox)) {
      canMove = false;
    }
  });
  
  if (canMove) {
    playerMesh.position.add(moveVector);
    camera.position.add(moveVector);
  }
}

function togglePause() {
  GameState.isPaused = !GameState.isPaused;
  
  if (GameState.isPaused) {
    showScreen('pauseMenu');
  } else {
    showScreen('gameScreen');
  }
}

function resumeGame() {
  GameState.isPaused = false;
  showScreen('gameScreen');
  gameLoop();
}

function gameOver() {
  GameState.isRunning = false;
  alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞! –í–∞—à —Å—á–µ—Ç: ${GameState.score}\n–ü—Ä–æ–π–¥–µ–Ω–æ –≤–æ–ª–Ω: ${GameState.wave}`);
  showScreen('mainMenu');
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ========= INITIALIZE GAME =========
window.addEventListener('load', () => {
  initGame();
  
  // Initialize Telegram WebApp
  if (window.Telegram && Telegram.WebApp) {
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();
  }
});
</script>
</body>
</html>
