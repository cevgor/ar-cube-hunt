<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ö–æ—Å–º–∏—á–µ—Å–∫–∏–π —Ä–µ–π–¥–µ—Ä ‚Äî —Ñ–∏–Ω–∞–ª—å–Ω—ã–π</title>

  <!-- three.js r128 (CDN) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- –ø–æ—Å—Ç-—ç—Ñ—Ñ–µ–∫—Ç—ã (–ø—Ä–∏–º–µ—Ä–Ω—ã–µ —Å—Å—ã–ª–∫–∏ ‚Äî –µ—Å–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∑—è—Ç—Å—è, –∏–≥—Ä–∞ –≤—Å—ë —Ä–∞–≤–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç –±–µ–∑ bloom) -->
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://threejs.org/examples/js/shaders/GammaCorrectionShader.js"></script>

  <style>
    *{box-sizing:border-box;margin:0;padding:0;user-select:none}
    html,body{width:100%;height:100%;background:#07121a;font-family:'Courier New',monospace}
    #gameContainer{position:fixed;inset:0;z-index:1}
    #ui{position:fixed;inset:0;pointer-events:none;z-index:10;color:#0ff}
    .screen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;pointer-events:none;opacity:1;transition:opacity 360ms ease}
    .hidden{opacity:0;pointer-events:none}
    .visible{opacity:1;pointer-events:auto}
    .menu-card{background:linear-gradient(135deg, rgba(0,20,40,0.85), rgba(0,10,20,0.6));padding:28px;border-radius:14px;border:1px solid rgba(0,255,255,0.09);box-shadow:0 8px 40px rgba(0,255,255,0.03)}
    .title{font-size:3rem;color:#0ff;text-shadow:0 0 20px rgba(0,255,255,0.22);margin-bottom:18px;text-align:center}
    .btn{pointer-events:auto;background:transparent;border:1px solid rgba(0,255,255,0.16);padding:10px 18px;color:#0ff;margin:8px;border-radius:8px;cursor:pointer}
    .hud{pointer-events:auto;position:absolute;left:12px;top:12px;background:rgba(0,0,0,0.55);padding:10px;border-radius:8px;border:1px solid rgba(0,255,255,0.08)}
    .resources{pointer-events:auto;position:absolute;right:12px;top:12px;background:rgba(0,0,0,0.55);padding:10px;border-radius:8px;border:1px solid rgba(0,255,255,0.08)}
    .simple-controls{pointer-events:auto;position:absolute;bottom:26px;display:flex;gap:16px}
    .control-btn{width:70px;height:70px;border-radius:12px;background:rgba(0,255,255,0.04);border:1px solid rgba(0,255,255,0.08);display:flex;align-items:center;justify-content:center;font-size:26px;color:#0ff;cursor:pointer}
    .scanlines{position:fixed;inset:0;pointer-events:none;background:repeating-linear-gradient(to bottom, rgba(255,255,255,0.0) 0px, rgba(255,255,255,0.02) 2px, rgba(255,255,255,0.0) 3px);opacity:0.22;mix-blend-mode:overlay}
    .loadingWrap{display:flex;flex-direction:column;align-items:center;gap:12px}
    .loadingText{color:#0ff;letter-spacing:1px}
    .dots{display:inline-block}
    .dot{display:inline-block;width:8px;height:8px;background:#0ff;border-radius:50%;margin:0 4px;opacity:0.08;transform:translateY(0)}
    .dot.a{animation:dotPulse 900ms infinite ease-in-out}
    .dot.b{animation:dotPulse 900ms 130ms infinite ease-in-out}
    .dot.c{animation:dotPulse 900ms 260ms infinite ease-in-out}
    @keyframes dotPulse {
      0%{opacity:0.08;transform:translateY(0)}
      50%{opacity:1;transform:translateY(-6px)}
      100%{opacity:0.08;transform:translateY(0)}
    }
    .damage-flash{position:fixed;inset:0;background:#ff2b2b;opacity:0;pointer-events:none;mix-blend-mode:screen;transition:opacity 150ms}
    @media (max-height:600px){ .title{font-size:2.1rem} .control-btn{width:62px;height:62px;font-size:22px} }
  </style>
</head>
<body>
  <div id="gameContainer"></div>

  <div id="ui">
    <div class="scanlines"></div>

    <!-- Loading/menu -->
    <div id="menuScreen" class="screen visible">
      <div class="menu-card">
        <div class="title" id="logoPulse">–ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –†–ï–ô–î–ï–†</div>
        <div style="text-align:center;color:#9ff;margin-bottom:10px">–ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ —á–µ—Ä–µ–∑ –≥–∞–ª–∞–∫—Ç–∏–∫—É</div>

        <div style="display:flex;justify-content:center;gap:12px">
          <button id="startBtn" class="btn">–°–¢–ê–†–¢</button>
          <button id="optsBtn" class="btn">–ù–ê–°–¢–†–û–ô–ö–ò</button>
        </div>

        <div style="margin-top:14px;text-align:center;">
          <div class="loadingWrap">
            <div class="loadingText">–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤<span class="dots" id="loadingDots"><span class="dot a"></span><span class="dot b"></span><span class="dot c"></span></span></div>
          </div>
        </div>
      </div>
    </div>

    <!-- Game screen -->
    <div id="gameScreen" class="screen hidden">
      <div class="hud" id="hud">
        <div>‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: <span id="healthValue">100</span></div>
        <div>üõ° –©–ò–¢: <span id="shieldValue">100</span></div>
      </div>

      <div class="resources" id="res">
        <div>‚≠ê <span id="starsValue">0</span></div>
        <div>üíé <span id="fragmentsValue">0</span></div>
        <div>üèÜ <span id="scoreValue">0</span></div>
      </div>

      <div class="simple-controls">
        <div id="leftBtn" class="control-btn">‚Üê</div>
        <div id="shieldBtn" class="control-btn">üõ°</div>
        <div id="shootBtn" class="control-btn">üí•</div>
        <div id="rightBtn" class="control-btn">‚Üí</div>
      </div>
    </div>

    <!-- Game over -->
    <div id="gameOver" class="screen hidden">
      <div class="menu-card" style="text-align:center;color:#f66">
        <h2>–ö–û–†–ê–ë–õ–¨ –£–ù–ò–ß–¢–û–ñ–ï–ù</h2>
        <div>–°—á—ë—Ç: <span id="finalScore">0</span></div>
        <div style="margin-top:12px"><button id="restartBtn" class="btn">–†–ï–°–¢–ê–†–¢</button></div>
      </div>
    </div>

    <div id="damageFlash" class="damage-flash"></div>
  </div>

  <script>
  // ========== –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫ (–ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∞–ª–µ—Ä—Ç) ==========
  window.onerror = function(message, source, lineno, colno, error) {
    try { alert("–û—à–∏–±–∫–∞: " + message + "\n" + source + ":" + lineno); } catch(e){ console.error(message, source, lineno, e); }
  };

  // ========== WebAudio: –ø—Ä–æ—Å—Ç—ã–µ –∑–≤—É–∫–∏ (engine start + shoot) ==========
  const AudioEngine = (function(){
    let ctx = null;
    function ensureCtx(){
      if (!ctx) {
        try { ctx = new (window.AudioContext || window.webkitAudioContext)(); }
        catch(e){ ctx = null; }
      }
      return ctx;
    }

    function playEngineStart(){
      const c = ensureCtx(); if (!c) return;
      const now = c.currentTime;
      const o = c.createOscillator();
      const g = c.createGain();
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(120, now);
      o.frequency.exponentialRampToValueAtTime(420, now + 0.18);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.06);
      g.gain.exponentialRampToValueAtTime(0.001, now + 0.55);
      o.connect(g); g.connect(c.destination);
      o.start(now); o.stop(now + 0.6);
    }

    function playShoot(){
      const c = ensureCtx(); if (!c) return;
      const now = c.currentTime;
      const o1 = c.createOscillator();
      const o2 = c.createOscillator();
      const g = c.createGain();
      o1.type = 'square'; o1.frequency.setValueAtTime(800, now); o1.frequency.exponentialRampToValueAtTime(240, now+0.12);
      o2.type = 'triangle'; o2.frequency.setValueAtTime(1200, now); o2.frequency.exponentialRampToValueAtTime(360, now+0.12);
      g.gain.setValueAtTime(0.2, now); g.gain.exponentialRampToValueAtTime(0.001, now+0.18);
      o1.connect(g); o2.connect(g); g.connect((c.destination));
      o1.start(now); o2.start(now); o1.stop(now+0.18); o2.stop(now+0.18);
    }

    return { playEngineStart, playShoot };
  })();

  // ========== –û—Å–Ω–æ–≤–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å—Ü–µ–Ω—ã ==========
  let scene, camera, renderer, composer;
  let ship;
  let clock = new THREE.Clock();
  let starsPoints;
  let engineParticlesPool = [];
  let bulletsPool = [];
  let activeBullets = [];
  let activeEffects = [];
  let asteroids = [], enemyShips = [], starFields = [], crystals = [], planets = [], nebulas = [];
  let gameState = {
    health:100, stars:0, fragments:0, score:0,
    speed:2.0, rotationSpeed:0.03, isShieldActive:false, shieldEnergy:100,
    gameActive:false, touchControls:{left:false,right:false,shoot:false},
    upgrades:{engine:1,shield:1,weapon:1}, mission:{type:'collect',target:5,progress:0,reward:100}
  };

  // –û–ø—Ü–∏–∏ (—Ü–≤–µ—Ç–∞ / –Ω–µ–æ–Ω —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã)
  const COLORS = { neon:0x00ffff };

  // ========= –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –†–µ–Ω–¥–µ—Ä–µ—Ä–∞ –∏ –ø–æ—Å—Ç-—ç—Ñ—Ñ–µ–∫—Ç–æ–≤ (–±–µ–∑ –ø–∞–¥–µ–Ω–∏—è –µ—Å–ª–∏ —Ñ–∞–π–ª—ã –Ω–µ –¥–æ—Å—Ç—É–ø–Ω—ã) =========
  function initRenderer(){
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 6000);
    camera.position.set(0, 8, 25);

    renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setClearColor(0x08121a, 1);
    renderer.shadowMap.enabled = true;
    document.getElementById('gameContainer').appendChild(renderer.domElement);

    // composer - –≤ try: –µ—Å–ª–∏ –Ω–µ –∑–∞–≥—Ä—É–∑–∏–ª–∏—Å—å —Å–∫—Ä–∏–ø—Ç—ã –ø–æ—Å—Ç-—ç—Ñ—Ñ–µ–∫—Ç–æ–≤, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –±–µ–∑ –Ω–∏—Ö
    try {
      composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.4, 0.9);
      bloomPass.threshold = 0.1; bloomPass.strength = 0.8; bloomPass.radius = 0.4;
      composer.addPass(bloomPass);
      const gammaPass = new THREE.ShaderPass(THREE.GammaCorrectionShader);
      composer.addPass(gammaPass);
    } catch(e){
      composer = null;
      console.warn("Postprocessing modules not available, continuing without composer.", e);
    }
  }

  function addLights(){
    const amb = new THREE.AmbientLight(0x8aaacc, 0.95); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 1.1); dir.position.set(20,30,10); dir.castShadow = true; scene.add(dir);
    const rim = new THREE.DirectionalLight(0x66bbff, 0.45); rim.position.set(-10, -5, -20); scene.add(rim);
    const fill = new THREE.PointLight(0xaaffff, 0.35, 500); fill.position.set(0,5,50); scene.add(fill);
  }

  // ========= –ó–≤—ë–∑–¥—ã, —Ç—É–º–∞–Ω–Ω–æ—Å—Ç–∏ =========
  function createStarfield(){
    const starCount = 2500;
    const pos = new Float32Array(starCount*3);
    const cols = new Float32Array(starCount*3);
    for (let i=0;i<starCount;i++){
      const i3 = i*3;
      pos[i3] = (Math.random()-0.5)*4000;
      pos[i3+1] = (Math.random()-0.5)*2000;
      pos[i3+2] = (Math.random()-0.5)*6000 - 1000;
      const c = Math.random();
      if (c<0.7){ cols[i3]=1; cols[i3+1]=1; cols[i3+2]=1; }
      else if (c<0.9){ cols[i3]=0.8; cols[i3+1]=0.9; cols[i3+2]=1; }
      else { cols[i3]=1; cols[i3+1]=0.9; cols[i3+2]=0.6; }
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(pos,3));
    geom.setAttribute('color', new THREE.BufferAttribute(cols,3));
    const mat = new THREE.PointsMaterial({ vertexColors:true, size:2.0, transparent:true, blending:THREE.AdditiveBlending, opacity:0.93 });
    starsPoints = new THREE.Points(geom, mat); scene.add(starsPoints);
  }

  function createNebulas(){
    for (let i=0;i<3;i++){
      const g = new THREE.SphereGeometry(400 + Math.random()*300, 32, 32);
      const mat = new THREE.MeshBasicMaterial({ color:new THREE.Color().setHSL(Math.random(),0.6,0.45), transparent:true, opacity:0.06, side:THREE.BackSide, depthWrite:false });
      const m = new THREE.Mesh(g, mat);
      m.position.set((Math.random()-0.5)*2000, (Math.random()-0.5)*1200, (Math.random()-0.5)*3000 - 800);
      scene.add(m); nebulas.push(m);
    }
  }

  // ========= –ö–æ—Ä–∞–±–ª—å + —á–∞—Å—Ç–∏—Ü—ã –¥–≤–∏–≥–∞—Ç–µ–ª—è (–ø—É–ª) =========
  function createShip(){
    const group = new THREE.Group();
    const hullGeo = new THREE.ConeGeometry(3.5, 10, 6);
    const hullMat = new THREE.MeshStandardMaterial({ color:0x0088ff, metalness:0.5, roughness:0.25, emissive:0x002244, emissiveIntensity:0.7 });
    const hull = new THREE.Mesh(hullGeo, hullMat); hull.rotation.x = -Math.PI/2; hull.castShadow=true; group.add(hull);

    const wingGeo = new THREE.BoxGeometry(7,0.8,3);
    const wingMat = new THREE.MeshStandardMaterial({ color:0x0066aa, metalness:0.4, roughness:0.4, emissive:0x001122 });
    const lw = new THREE.Mesh(wingGeo, wingMat); lw.position.set(-5,0,0); group.add(lw);
    const rw = lw.clone(); rw.position.set(5,0,0); group.add(rw);

    const engineGeo = new THREE.CylinderGeometry(0.9,1.2,2.6,12);
    const engineMat = new THREE.MeshStandardMaterial({ color:0xff6f00, emissive:0xff3800, emissiveIntensity:0.95, metalness:0.1, roughness:0.3 });
    const le = new THREE.Mesh(engineGeo, engineMat); le.rotation.x = Math.PI/2; le.position.set(-2.5,0,4); group.add(le);
    const re = le.clone(); re.position.set(2.5,0,4); group.add(re);

    group.position.set(0,0,15);
    scene.add(group); ship = group;

    // –ø—Ä–æ—Å—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ —á–∞—Å—Ç–∏—Ü (–æ–¥–Ω–∞ —Ç–æ—á–µ—á–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ –≤–Ω—É—Ç—Ä–∏ ship)
    const maxP = 80;
    const pGeom = new THREE.BufferGeometry();
    const positions = new Float32Array(maxP*3);
    const colors = new Float32Array(maxP*3);
    for (let i=0;i<maxP;i++){
      const j=i*3;
      positions[j] = (Math.random()-0.5)*1.6;
      positions[j+1] = (Math.random()-0.5)*1.6;
      positions[j+2] = 2 + Math.random()*5;
      colors[j]=1; colors[j+1]=0.5 + Math.random()*0.5; colors[j+2]=0;
    }
    pGeom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    pGeom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const pMat = new THREE.PointsMaterial({ size:2.6, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending });
    const pSys = new THREE.Points(pGeom, pMat);
    ship.add(pSys); engineParticlesPool.push({points:pSys, geom:pGeom});
  }

  // ========= –ü—É–ª—ã –ø—É–ª—å =========
  const MAX_BULLETS = 80;
  function initBulletPool(){
    const geom = new THREE.SphereGeometry(0.7,8,8);
    const mat = new THREE.MeshBasicMaterial({ color:0xffff66, emissive:0xffff66 });
    for (let i=0;i<MAX_BULLETS;i++){
      const m = new THREE.Mesh(geom, mat);
      m.visible = false; m.userData = { velocity:new THREE.Vector3(), lifetime:0 };
      scene.add(m); bulletsPool.push(m);
    }
  }
  function getBullet(){
    for (let i=0;i<bulletsPool.length;i++) if (!bulletsPool[i].visible) return bulletsPool[i];
    return null;
  }

  // ========= –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ (—É–ø—Ä–æ—â—ë–Ω–Ω–æ) =========
  function makeAsteroid(sz,x,y,z){
    const geom = new THREE.IcosahedronGeometry(sz,1);
    const mat = new THREE.MeshStandardMaterial({ color:0xaaaaaa, metalness:0.08, roughness:0.6, emissive:0x111111 });
    const m = new THREE.Mesh(geom, mat);
    m.position.set(x,y,z);
    m.userData = { rotationSpeed:{x:(Math.random()-0.5)*0.02,y:(Math.random()-0.5)*0.02,z:(Math.random()-0.5)*0.02}, radius:sz };
    scene.add(m); asteroids.push(m);
  }
  function generateAsteroids(n=18){ for (let i=0;i<n;i++){ if (Math.random()<0.24) continue; makeAsteroid(2 + Math.random()*6, (Math.random()-0.5)*800, (Math.random()-0.5)*200, -200 - Math.random()*1500); } }

  function generateEnemyShips(n=10){
    for (let i=0;i<n;i++){
      if (Math.random()<0.36) continue;
      const g = new THREE.OctahedronGeometry(4 + Math.random()*2,0);
      const m = new THREE.Mesh(g, new THREE.MeshStandardMaterial({ color:0xff5533, emissive:0x440000, metalness:0.28, roughness:0.4 }));
      m.position.set((Math.random()-0.5)*600, (Math.random()-0.5)*150, -300 - Math.random()*1200);
      m.userData = { health:20 + Math.floor(Math.random()*20), speed:0.5 + Math.random()*0.7 };
      scene.add(m); enemyShips.push(m);
    }
  }

  function generateStarFields(n=12){
    for (let i=0;i<n;i++){
      const geom = new THREE.SphereGeometry(3 + Math.random()*3, 12,12);
      const mat = new THREE.MeshStandardMaterial({ color:0xffee66, emissive:0xffdd55, emissiveIntensity:0.8, metalness:0.2, roughness:0.2 });
      const m = new THREE.Mesh(geom, mat);
      m.position.set((Math.random()-0.5)*700, (Math.random()-0.5)*180, -250 - Math.random()*1300);
      m.userData = { rotationSpeed:(Math.random()-0.5)*0.03, collected:false };
      scene.add(m); starFields.push(m);
    }
  }

  function generateCrystals(n=10){
    for (let i=0;i<n;i++){
      const geom = new THREE.OctahedronGeometry(2.6, 0);
      const mat = new THREE.MeshStandardMaterial({ color:0xff00ff, emissive:0x880088, emissiveIntensity:0.9, metalness:0.1, roughness:0.3 });
      const m = new THREE.Mesh(geom, mat);
      m.position.set((Math.random()-0.5)*750, (Math.random()-0.5)*200, -200 - Math.random()*1400);
      m.userData = { rotationSpeed:(Math.random()-0.5)*0.02, collected:false };
      scene.add(m); crystals.push(m);
    }
  }

  function generatePlanets(n=3){
    const planetData = [
      { name:"–ö–†–ò–û–ù–ò–°", color:0x88ccff, size:25 },
      { name:"–ü–ò–†–û–°", color:0xff6633, size:30 },
      { name:"–í–ï–†–î–ê–ù–¢", color:0x44ff88, size:22 }
    ];
    for (let i=0;i<n;i++){
      const p = planetData[Math.floor(Math.random()*planetData.length)];
      const geom = new THREE.SphereGeometry(p.size, 24, 24);
      const mat = new THREE.MeshStandardMaterial({ color:p.color, emissive:new THREE.Color(p.color).multiplyScalar(0.2), roughness:0.5 });
      const m = new THREE.Mesh(geom, mat);
      m.position.set((Math.random()-0.5)*1000, (Math.random()-0.5)*300, -600 - Math.random()*2000);
      m.userData = { size:p.size, planetData:p };
      scene.add(m); planets.push(m);
    }
  }

  // ========= –°—Ç—Ä–µ–ª—å–±–∞ (–ø—É–ª) =========
  function shoot(){
    if (!gameState.gameActive || !ship) return;
    const b = getBullet(); if (!b) return;
    b.visible = true;
    b.position.copy(ship.position);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
    b.userData.velocity.copy(dir).multiplyScalar(18 * (1 + (gameState.upgrades.weapon-1)*0.25));
    b.userData.lifetime = 80;
    activeBullets.push(b);
    AudioEngine.playShoot();
    // muzzle: small flash
    const flash = new THREE.Mesh(new THREE.SphereGeometry(1.6,8,8), new THREE.MeshBasicMaterial({ color:0xffffcc, transparent:true, opacity:0.95 }));
    flash.position.copy(ship.position).add(dir.clone().multiplyScalar(-8));
    scene.add(flash);
    setTimeout(()=>{ try{ scene.remove(flash) }catch(e){} }, 90);
  }

  // ========= Enemy laser (simple) =========
  function createEnemyLaser(from, to){
    const dir = to.clone().sub(from).normalize();
    const geom = new THREE.CylinderGeometry(0.18, 0.18, 12, 8);
    const mat = new THREE.MeshBasicMaterial({ color:0xff6666 });
    const laser = new THREE.Mesh(geom, mat);
    laser.position.copy(from); laser.lookAt(to); laser.rotateX(Math.PI/2);
    laser.userData = { velocity:dir.clone().multiplyScalar(12), lifetime:60 };
    scene.add(laser); activeEffects.push({ type:'laser', mesh:laser });
  }

  // ========= Explosion effect (points) =========
  function createExplosion(pos, size=18){
    const count = 22;
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count*3);
    const colors = new Float32Array(count*3);
    for (let i=0;i<count;i++){
      const j=i*3;
      positions[j] = pos.x + (Math.random()-0.5)*size;
      positions[j+1] = pos.y + (Math.random()-0.5)*size;
      positions[j+2] = pos.z + (Math.random()-0.5)*size;
      colors[j]=1; colors[j+1]=0.4 + Math.random()*0.4; colors[j+2]=0;
    }
    geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors,3));
    const mat = new THREE.PointsMaterial({ size:3.2, vertexColors:true, transparent:true, blending:THREE.AdditiveBlending });
    const pts = new THREE.Points(geom, mat);
    pts.userData = { life:1.0 };
    scene.add(pts); activeEffects.push({ type:'points', mesh:pts });
  }

  // ========= –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è =========
  let perfTime = 0;
  function updateEngineParticles(delta){
    engineParticlesPool.forEach(entry=>{
      const positions = entry.geom.attributes.position.array;
      for (let i=0;i<positions.length;i+=3){
        positions[i+2] += (1.0 + Math.random()*1.0) * (1 + (gameState.touchControls.shoot?0.5:0)) * (1 + (gameState.upgrades.engine-1)*0.15);
        if (positions[i+2] > 18) {
          positions[i] = (Math.random()-0.5)*1.8;
          positions[i+1] = (Math.random()-0.5)*1.8;
          positions[i+2] = 2 + Math.random()*5;
        }
      }
      entry.geom.attributes.position.needsUpdate = true;
      entry.points.material.opacity = 0.7 + Math.abs(Math.sin(perfTime*6))*0.3;
    });
  }

  // ========= –û—Å–Ω–æ–≤–Ω–æ–π update (deltaTime-aware) =========
  function update(delta){
    perfTime += delta;
    if (!gameState.gameActive) return;

    // ship movement forward
    if (ship){
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
      ship.position.add(dir.clone().multiplyScalar(gameState.speed * (1 + (gameState.upgrades.engine-1)*0.15) * delta * 60));
      if (gameState.touchControls.left) ship.rotation.y += gameState.rotationSpeed * delta * 60;
      if (gameState.touchControls.right) ship.rotation.y -= gameState.rotationSpeed * delta * 60;
      // camera follow
      const camOff = new THREE.Vector3(0,8,25).applyQuaternion(ship.quaternion);
      camera.position.copy(ship.position).add(camOff);
      const lookAt = ship.position.clone().add(new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).multiplyScalar(90));
      camera.lookAt(lookAt);
    }

    updateEngineParticles(delta);

    // stars drift
    if (starsPoints){ starsPoints.position.z += 0.12 * delta * 60; if (starsPoints.position.z > 2000) starsPoints.position.z = -2000; }

    nebulas.forEach(n => n.rotation.y += 0.0005 * delta * 60);

    // bullets update
    for (let i=activeBullets.length-1;i>=0;i--){
      const b = activeBullets[i];
      b.position.add(b.userData.velocity.clone().multiplyScalar(delta*60));
      b.userData.lifetime--;
      for (let j=enemyShips.length-1;j>=0;j--){
        const e = enemyShips[j];
        if (b.position.distanceTo(e.position) < 8){
          e.userData.health -= 10 * (1 + (gameState.upgrades.weapon-1)*0.2);
          b.visible = false; activeBullets.splice(i,1);
          if (e.userData.health <= 0){ createExplosion(e.position.clone(), 14); scene.remove(e); enemyShips.splice(j,1); gameState.fragments += 8; gameState.score += 50; generateEnemyShips(1); }
          break;
        }
      }
      if (b.userData.lifetime <= 0 || b.position.distanceTo(ship.position) > 700) { b.visible = false; const idx = activeBullets.indexOf(b); if (idx>=0) activeBullets.splice(idx,1); }
    }

    // asteroids
    for (let i=asteroids.length-1;i>=0;i--){
      const a = asteroids[i];
      a.rotation.x += a.userData.rotationSpeed.x * delta * 60;
      a.rotation.y += a.userData.rotationSpeed.y * delta * 60;
      a.rotation.z += a.userData.rotationSpeed.z * delta * 60;
      a.position.z += 0.6 * delta * 60;
      if (ship && ship.position.distanceTo(a.position) < (a.userData.radius + 6)){
        if (gameState.isShieldActive) gameState.shieldEnergy -= 15;
        else { gameState.health -= 12; flashDamage(); }
        createExplosion(a.position.clone(), a.userData.radius*1.5);
        scene.remove(a); asteroids.splice(i,1); generateAsteroids(1);
      }
      if (a.position.z > ship.position.z + 500){ scene.remove(a); asteroids.splice(i,1); generateAsteroids(1); }
    }

    // enemies
    for (let i=enemyShips.length-1;i>=0;i--){
      const e = enemyShips[i];
      const dx = ship.position.x - e.position.x, dz = ship.position.z - e.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if (dist < 220) { e.position.x += dx * 0.008 * e.userData.speed * delta * 60; e.position.z += dz * 0.008 * e.userData.speed * delta * 60; }
      else e.position.z += 0.2 * delta * 60;
      if (Math.random() < 0.0025 && dist < 200) createEnemyLaser(e.position.clone(), ship.position.clone());
      if (ship && e.position.distanceTo(ship.position) < 12){ if (gameState.isShieldActive) gameState.shieldEnergy -= 20; else { gameState.health -= 18; flashDamage(); } createExplosion(e.position.clone(), 12); scene.remove(e); enemyShips.splice(i,1); generateEnemyShips(1); }
      if (e.position.z > ship.position.z + 450){ scene.remove(e); enemyShips.splice(i,1); generateEnemyShips(1); }
    }

    // starfields
    for (let i=starFields.length-1;i>=0;i--){
      const s = starFields[i];
      s.rotation.y += s.userData.rotationSpeed * delta * 60;
      if (ship && ship.position.distanceTo(s.position) < 10 && !s.userData.collected){
        s.userData.collected = true; gameState.stars++; gameState.score += 15; createExplosion(s.position.clone(),6);
        setTimeout(()=>{ try{ scene.remove(s); starFields.splice(i,1); generateStarFields(1); }catch(e){} }, 280);
      }
      if (s.position.z > ship.position.z + 400){ scene.remove(s); starFields.splice(i,1); generateStarFields(1); }
    }

    // crystals
    for (let i=crystals.length-1;i>=0;i--){
      const c = crystals[i];
      c.rotation.y += c.userData.rotationSpeed * delta * 60;
      if (ship && ship.position.distanceTo(c.position) < 8 && !c.userData.collected){
        c.userData.collected = true; gameState.fragments += 3; gameState.score += 25; createExplosion(c.position.clone(),6);
        setTimeout(()=>{ try{ scene.remove(c); crystals.splice(i,1); generateCrystals(1); }catch(e){} }, 280);
      }
      if (c.position.z > ship.position.z + 400){ scene.remove(c); crystals.splice(i,1); generateCrystals(1); }
    }

    // planets (simple)
    for (let i=planets.length-1;i>=0;i--){
      const p = planets[i]; p.rotation.y += 0.001 * delta * 60;
      if (ship && ship.position.distanceTo(p.position) < p.userData.size + 24){
        // landing: pause game and show menu (simplified)
        gameState.gameActive = false; showScreen('menuScreen'); // extend later with planet UI
      }
      if (p.position.z > ship.position.z + 700){ scene.remove(p); planets.splice(i,1); generatePlanets(1); }
    }

    if (!gameState.isShieldActive && gameState.shieldEnergy < 100) gameState.shieldEnergy = Math.min(gameState.shieldEnergy + 0.12 * delta * 60, 100);

    // effects (lasers, explosion points)
    for (let i=activeEffects.length-1;i>=0;i--){
      const obj = activeEffects[i];
      if (obj.type === 'laser'){
        obj.mesh.position.add(obj.mesh.userData.velocity.clone().multiplyScalar(delta*60));
        obj.mesh.userData.lifetime--;
        if (obj.mesh.userData.lifetime <= 0){ scene.remove(obj.mesh); activeEffects.splice(i,1); continue; }
        if (ship && obj.mesh.position.distanceTo(ship.position) < 8){
          if (gameState.isShieldActive) gameState.shieldEnergy -= 8; else { gameState.health -= 8; flashDamage(); }
          createExplosion(obj.mesh.position.clone(), 10);
          try{ scene.remove(obj.mesh); }catch(e){}
          activeEffects.splice(i,1);
        }
      } else if (obj.type === 'points'){
        obj.mesh.userData.life -= 0.02 * delta * 60;
        obj.mesh.material.opacity = Math.max(0, obj.mesh.userData.life);
        if (obj.mesh.userData.life <= 0){ try{ scene.remove(obj.mesh); }catch(e){} activeEffects.splice(i,1); }
      }
    }

    gameState.score += 0.02 * delta * 60 * gameState.speed;
    if (gameState.mission.progress >= gameState.mission.target) completeMission();
    if (gameState.health <= 0) gameOver();
    updateUI();
  }

  function createCollectEffect(pos){ createExplosion(pos, 6); }

  // ========= UI / transitions =========
  function showScreen(id){
    ['menuScreen','gameScreen','gameOver'].forEach(sid=>{
      const el = document.getElementById(sid);
      if (!el) return;
      if (sid === id){ el.classList.remove('hidden'); el.classList.add('visible'); }
      else { el.classList.remove('visible'); el.classList.add('hidden'); }
    });
  }

  function updateUI(){
    document.getElementById('healthValue').textContent = Math.max(0, Math.round(gameState.health));
    document.getElementById('shieldValue').textContent = Math.round(gameState.shieldEnergy);
    document.getElementById('starsValue').textContent = gameState.stars;
    document.getElementById('fragmentsValue').textContent = gameState.fragments;
    document.getElementById('scoreValue').textContent = Math.round(gameState.score);
  }

  function completeMission(){
    gameState.stars += gameState.mission.reward;
    gameState.score += gameState.mission.reward * 10;
    gameState.mission = { type: Math.random()>0.5 ? 'collect' : 'destroy', target: 5 + Math.floor(Math.random()*6), progress:0, reward:100 + Math.floor(Math.random()*100) };
    const msg = document.createElement('div'); msg.style.cssText = 'position:fixed;left:50%;top:18%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:#0ff;padding:10px 14px;border-radius:8px;border:1px solid #0ff'; msg.textContent = 'üéâ –ú–∏—Å—Å–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞!'; document.body.appendChild(msg);
    setTimeout(()=>{ try{ document.body.removeChild(msg); }catch(e){} }, 2600);
  }

  function gameOver(){
    gameState.gameActive = false; document.getElementById('finalScore').textContent = Math.round(gameState.score); showScreen('gameOver');
  }

  function flashDamage(){
    const el = document.getElementById('damageFlash'); el.style.opacity = '0.55'; setTimeout(()=>el.style.opacity='0', 140);
  }

  // ========= Controls (touch + keyboard) =========
  function setupControls(){
    const leftBtn = document.getElementById('leftBtn'), rightBtn = document.getElementById('rightBtn'), shootBtn = document.getElementById('shootBtn'), shieldBtn = document.getElementById('shieldBtn'), startBtn = document.getElementById('startBtn'), restartBtn = document.getElementById('restartBtn');

    function hold(btn, name){
      btn.addEventListener('touchstart', e=>{ e.preventDefault(); gameState.touchControls[name]=true; });
      btn.addEventListener('touchend', e=>{ e.preventDefault(); gameState.touchControls[name]=false; });
      btn.addEventListener('mousedown', e=>{ e.preventDefault(); gameState.touchControls[name]=true; });
      btn.addEventListener('mouseup', e=>{ e.preventDefault(); gameState.touchControls[name]=false; });
      btn.addEventListener('mouseleave', e=>{ gameState.touchControls[name]=false; });
    }
    if (leftBtn) hold(leftBtn, 'left');
    if (rightBtn) hold(rightBtn, 'right');
    if (shootBtn) hold(shootBtn, 'shoot');

    if (shieldBtn) shieldBtn.addEventListener('click', ()=>{ activateShield(); });

    if (startBtn) startBtn.addEventListener('click', ()=>{
      // –Ω–µ–±–æ–ª—å—à–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ, –∑–≤—É–∫
      AudioEngine.playEngineStart();
      document.getElementById('logoPulse').style.transform = 'scale(0.98)';
      setTimeout(()=>document.getElementById('logoPulse').style.transform = 'scale(1)', 220);
      startGame();
    });

    if (restartBtn) restartBtn.addEventListener('click', ()=>{ startGame(); });

    window.addEventListener('keydown', e=>{
      if (!gameState.gameActive) return;
      if (e.key === 'a' || e.key === 'ArrowLeft') gameState.touchControls.left = true;
      if (e.key === 'd' || e.key === 'ArrowRight') gameState.touchControls.right = true;
      if (e.key === ' ') gameState.touchControls.shoot = true;
      if (e.key === 's') activateShield();
    });
    window.addEventListener('keyup', e=>{
      if (e.key === 'a' || e.key === 'ArrowLeft') gameState.touchControls.left = false;
      if (e.key === 'd' || e.key === 'ArrowRight') gameState.touchControls.right = false;
      if (e.key === ' ') gameState.touchControls.shoot = false;
    });

    // shoot sound on touch/click for mobile
    if (shootBtn) shootBtn.addEventListener('click', ()=>{ if (gameState.gameActive) { AudioEngine.playShoot(); } });
  }

  function activateShield(){
    if (gameState.shieldEnergy >= 25 && !gameState.isShieldActive && ship){
      gameState.isShieldActive = true; gameState.shieldEnergy -= 25;
      const s = new THREE.Mesh(new THREE.SphereGeometry(10, 16, 16), new THREE.MeshBasicMaterial({ color:0x00ffff, transparent:true, opacity:0.28, side:THREE.DoubleSide }));
      ship.add(s); setTimeout(()=>{ try{ ship.remove(s); }catch(e){} gameState.isShieldActive=false; }, 3000);
    }
  }

  // ========= Start / reset game logic =========
  function startGame(){
    gameState.health=100; gameState.stars=0; gameState.fragments=0; gameState.score=0;
    gameState.speed=2; gameState.isShieldActive=false; gameState.shieldEnergy=100; gameState.gameActive=true;
    gameState.upgrades={engine:1,shield:1,weapon:1};
    gameState.mission={type:Math.random()>0.5?'collect':'destroy', target:5, progress:0, reward:100};
    if (ship) { ship.position.set(0,0,15); ship.rotation.set(0,0,0); }
    // clear existing objects
    asteroids.forEach(o=>{ try{ scene.remove(o) }catch(e){} }); asteroids=[];
    enemyShips.forEach(o=>{ try{ scene.remove(o) }catch(e){} }); enemyShips=[];
    starFields.forEach(o=>{ try{ scene.remove(o) }catch(e){} }); starFields=[];
    crystals.forEach(o=>{ try{ scene.remove(o) }catch(e){} }); crystals=[];
    planets.forEach(o=>{ try{ scene.remove(o) }catch(e){} }); planets=[];
    activeBullets.forEach(b=>{ b.visible=false; });
    activeBullets = [];
    generateAsteroids(26); generateEnemyShips(12); generateStarFields(18); generateCrystals(12); generatePlanets(4);
    showScreen('gameScreen');
  }

  // ========= –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è (–≤—ã–∑–æ–≤ —á–µ—Ä–µ–∑ DOMContentLoaded —á—Ç–æ–±—ã –Ω–µ –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç –∑–∞–≥—Ä—É–∑–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤) =========
  function init(){
    try {
      initRenderer(); addLights(); createStarfield(); createNebulas(); createShip(); initBulletPool();
      setupControls(); // controls
      document.getElementById('loadingDots').style.opacity = '1';
      document.getElementById('loadingDots').style.transition = 'opacity 400ms';
      // —É–±–∏—Ä–∞–µ–º —Ç–µ–∫—Å—Ç "–ó–∞–≥—Ä—É–∑–∫–∞..." –µ—Å–ª–∏ –≤—Å–µ –æ–∫
      setTimeout(()=>{ /* –º–∞–ª—ã–π —Ç–∞–π–º–∞—É—Ç —á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É–≤–∏–¥–µ–ª –∞–Ω–∏–º–∞—Ü–∏—é */ }, 200);

      // –ø—Ä—è—á–µ–º –Ω–∞–¥–ø–∏—Å—å –≤ –º–µ–Ω—é (–æ–Ω–∞ —Ç–æ–ª—å–∫–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π)
      const ld = document.getElementById('loadingDots');
      if (ld) ld.style.opacity = '0.9';

      // —Å–∫—Ä—ã–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–π –ª–æ–∞–¥–µ—Ä (–µ—Å–ª–∏ –±—ã–ª)
      const globalLoading = document.querySelector('.loadingWrap');
      if (globalLoading) globalLoading.style.display = 'none';

      // –∑–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∏–º–∞—Ü–∏—é –ª–æ–≥–æ—Ç–∏–ø–∞ (–ø—É–ª—å—Å–∞—Ü–∏—è)
      const logo = document.getElementById('logoPulse');
      if (logo) { logo.animate([{ transform:'scale(1)'},{ transform:'scale(1.02)'},{ transform:'scale(1)' }], { duration:2200, iterations:Infinity }); }

      // –ø—Ä—è—á–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é "–ó–∞–≥—Ä—É–∑–∫–∞..." (–µ—Å–ª–∏ –Ω—É–∂–Ω–æ)
      try { document.getElementById('menuScreen').classList.add('visible'); } catch(e){}

      // —Å—Ç–∞—Ä—Ç –∞–Ω–∏–º-—Ü–∏–∫–ª–∞
      animate();
    } catch (err){
      console.error("Init failed:", err);
      alert("–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏. –ü—Ä–æ–≤–µ—Ä—å –∫–æ–Ω—Å–æ–ª—å (F12).");
    } finally {
      // –ø—Ä—è—á–µ–º —Ç–µ–∫—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –≤ UI (—Ç–æ—á–∫–∏ –æ—Å—Ç–∞—é—Ç—Å—è –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω–æ)
      const ldWrap = document.querySelector('.loadingWrap');
      if (ldWrap) ldWrap.style.opacity = '0.9';
    }
  }

  // ========= –ê–Ω–∏–º–∞—Ü–∏—è (requestAnimationFrame) =========
  let lastTime = performance.now();
  function animate(){
    requestAnimationFrame(animate);
    const now = performance.now();
    const delta = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;

    // –∞–≤—Ç–æ-—Å—Ç—Ä–µ–ª—å –µ—Å–ª–∏ –¥–µ—Ä–∂–∞—Ç –∫–Ω–æ–ø–∫—É
    if (gameState.touchControls.shoot && gameState.gameActive) {
      if (!gameState._lastShotTime || performance.now() - gameState._lastShotTime > (300 / (1 + (gameState.upgrades.weapon-1)*0.2))) {
        shoot(); gameState._lastShotTime = performance.now();
      }
    }

    update(delta);

    // —Ä–µ–Ω–¥–µ—Ä: –µ—Å–ª–∏ composer –µ—Å—Ç—å ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º (bloom), –∏–Ω–∞—á–µ –æ–±—ã—á–Ω—ã–π render
    try {
      if (composer) composer.render(delta);
      else renderer.render(scene, camera);
    } catch(e){
      try { renderer.render(scene, camera); } catch(err){ console.error("Render failed", err); }
    }
  }

  // ========= Resize handler =========
  function onWindowResize(){
    if (!camera || !renderer) return;
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (composer && composer.setSize) composer.setSize(window.innerWidth, window.innerHeight);
  }
  window.addEventListener('resize', onWindowResize);

  // ========= –ó–∞–ø—É—Å–∫ init —á–µ—Ä–µ–∑ DOMContentLoaded (—É—Å—Ç–æ–π—á–∏–≤–µ–µ, —á–µ–º window.load) =========
  document.addEventListener('DOMContentLoaded', () => {
    // –Ω–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã CDN-—Å–∫—Ä–∏–ø—Ç—ã —É—Å–ø–µ–ª–∏ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å—Å—è, –Ω–æ init –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –±—ã—Å—Ç—Ä–æ
    setTimeout(()=>{ init(); }, 60);
  });

  // ========= –≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç—ã / –±—ã—Å—Ç—Ä–∞—è –æ—Ç–ª–∞–¥–∫–∞ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) =========
  // –ï—Å–ª–∏ —Ö–æ—á–µ—à—å —É–≤–∏–¥–µ—Ç—å –æ—à–∏–±–∫—É –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥—É–ª–µ–π ‚Äî —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä—É–π alert –≤ window.onerror –≤—ã—à–µ.

  </script>
</body>
</html>
