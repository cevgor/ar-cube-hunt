<script>
/* ===============================
   Z.E.R.O.: LAST BREACH ‚Äî BUILD 2.0
   Features: –∞–≤—Ç–æ—Å—Ç—Ä–µ–ª—å–±–∞, –ø–æ—Å–∞–¥–∫–∞, –º–∞–≥–∞–∑–∏–Ω
================================= */

let scene, camera, renderer, composer;
let player, bullets = [], enemies = [], planets = [];
let canShoot = true, inMenu = true, landed = false;
let nearestTarget = null;
let speed = 0.4, fireRate = 400, hp = 100, coins = 0;
let upgradeLevel = 1;

// ===== INIT =====
document.addEventListener('DOMContentLoaded', init);
function init() {
  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x030916);
  document.body.appendChild(renderer.domElement);

  // Scene & Camera
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
  camera.position.z = 10;

  // Lights
  const ambient = new THREE.AmbientLight(0x88aaff, 1.2);
  scene.add(ambient);
  const rim = new THREE.DirectionalLight(0x4499ff, 0.8);
  rim.position.set(-5, -5, -10);
  scene.add(rim);

  // Player
  const geom = new THREE.ConeGeometry(1, 3, 8);
  const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0033ff });
  player = new THREE.Mesh(geom, mat);
  player.rotation.x = Math.PI / 2;
  scene.add(player);

  // Stars
  const starGeo = new THREE.BufferGeometry();
  const starCount = 1500;
  const starPos = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount * 3; i++) starPos[i] = (Math.random() - 0.5) * 2000;
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
  const starMat = new THREE.PointsMaterial({ color: 0x88ccff, size: 1.5 });
  const stars = new THREE.Points(starGeo, starMat);
  scene.add(stars);

  // Planets
  for (let i = 0; i < 3; i++) {
    const p = new THREE.Mesh(
      new THREE.SphereGeometry(10 + Math.random() * 3, 32, 32),
      new THREE.MeshStandardMaterial({ color: 0x3344aa + i * 30000, emissive: 0x111122 })
    );
    p.position.set((i - 1) * 80, (Math.random() - 0.5) * 30, -100 - i * 150);
    p.userData = { name: `Planet ${i + 1}`, shop: true };
    planets.push(p);
    scene.add(p);
  }

  // Enemy spawner
  setInterval(() => {
    const e = new THREE.Mesh(
      new THREE.IcosahedronGeometry(1.5, 0),
      new THREE.MeshStandardMaterial({ color: 0xff5555, emissive: 0x440000 })
    );
    e.position.set((Math.random() - 0.5) * 60, (Math.random() - 0.5) * 30, -200);
    enemies.push(e);
    scene.add(e);
  }, 2000);

  // Controls
  window.addEventListener('keydown', moveShip);
  document.getElementById('startBtn').onclick = startGame;

  // Preloader fade
  setTimeout(() => document.getElementById('loading').style.opacity = 0, 1000);
  setTimeout(() => document.getElementById('loading').style.display = 'none', 2000);
}

// ===== START GAME =====
function startGame() {
  inMenu = false;
  document.getElementById('menu').style.opacity = 0;
  setTimeout(() => document.getElementById('menu').style.display = 'none', 600);
  requestAnimationFrame(gameLoop);
}

// ===== GAME LOOP =====
function gameLoop() {
  if (inMenu) return;
  if (!landed) updateObjects();
  renderer.render(scene, camera);
  requestAnimationFrame(gameLoop);
}

// ===== MOVEMENT =====
function moveShip(e) {
  if (landed) {
    if (e.key === 'Escape') exitPlanet();
    return;
  }
  switch (e.key) {
    case 'w': player.position.y += speed; break;
    case 's': player.position.y -= speed; break;
    case 'a': player.position.x -= speed; break;
    case 'd': player.position.x += speed; break;
    case ' ': autoShoot(); break;
  }
}

// ===== UPDATE OBJECTS =====
function updateObjects() {
  // Move enemies
  enemies.forEach((e, i) => {
    e.position.z += 0.8;
    if (e.position.z > 20) {
      scene.remove(e);
      enemies.splice(i, 1);
    }
  });

  // Auto target nearest
  nearestTarget = findNearestEnemy();
  if (nearestTarget && canShoot) autoShoot();

  // Check planet landing
  planets.forEach(p => {
    p.rotation.y += 0.001;
    if (distance(player, p) < 15 && !landed) {
      landed = true;
      showPlanetMenu(p);
    }
  });

  // Bullets
  bullets.forEach((b, i) => {
    b.position.z -= 2;
    enemies.forEach((e, j) => {
      if (distance(b, e) < 2) {
        scene.remove(e); enemies.splice(j, 1);
        scene.remove(b); bullets.splice(i, 1);
        coins += 10;
        document.getElementById('coins').innerText = coins;
      }
    });
  });
}

// ===== SHOOT =====
function autoShoot() {
  if (!canShoot || !nearestTarget) return;
  canShoot = false;

  const dir = new THREE.Vector3().subVectors(nearestTarget.position, player.position).normalize();
  const geom = new THREE.SphereGeometry(0.2, 8, 8);
  const mat = new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x0088ff });
  const bullet = new THREE.Mesh(geom, mat);
  bullet.position.copy(player.position);
  bullet.userData.dir = dir;
  scene.add(bullet);
  bullets.push(bullet);

  const laser = new Audio('https://actions.google.com/sounds/v1/alarms/beep_short.ogg');
  laser.volume = 0.3;
  laser.play();

  setTimeout(() => canShoot = true, fireRate / upgradeLevel);
}

// ===== FIND NEAREST =====
function findNearestEnemy() {
  let min = Infinity, target = null;
  enemies.forEach(e => {
    const d = distance(player, e);
    if (d < min) { min = d; target = e; }
  });
  return target;
}

// ===== DISTANCE =====
function distance(a, b) {
  return a.position.distanceTo(b.position);
}

// ===== PLANET INTERACTION =====
function showPlanetMenu(planet) {
  const overlay = document.getElementById('planetMenu');
  overlay.style.display = 'flex';
  overlay.style.opacity = 1;
  overlay.querySelector('h2').innerText = planet.userData.name;
}

function exitPlanet() {
  landed = false;
  const overlay = document.getElementById('planetMenu');
  overlay.style.opacity = 0;
  setTimeout(() => overlay.style.display = 'none', 500);
}

function upgradeShip() {
  if (coins >= 50 * upgradeLevel) {
    coins -= 50 * upgradeLevel;
    upgradeLevel++;
    document.getElementById('coins').innerText = coins;
    alert('–ö–æ—Ä–∞–±–ª—å —É–ª—É—á—à–µ–Ω! –°–∫–æ—Ä–æ—Å—Ç—å –æ–≥–Ω—è –≤—ã—à–µ.');
  } else {
    alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
  }
}
</script>

<!-- ======== UI ELEMENTS ======== -->
<div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞<span class="dots">...</span></div>

<div id="menu">
  <h1>Z.E.R.O.: LAST BREACH</h1>
  <button id="startBtn">–°–¢–ê–†–¢</button>
</div>

<div id="planetMenu" style="display:none;opacity:0;position:fixed;inset:0;background:rgba(0,0,20,0.9);flex-direction:column;justify-content:center;align-items:center;color:#0ff;font-family:monospace;transition:0.5s;">
  <h2>Planet</h2>
  <p>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –ß—Ç–æ –∂–µ–ª–∞–µ—à—å —Å–¥–µ–ª–∞—Ç—å?</p>
  <button onclick="upgradeShip()">–£–ª—É—á—à–∏—Ç—å –∫–æ—Ä–∞–±–ª—å</button>
  <button onclick="exitPlanet()">–í—ã–ª–µ—Ç–µ—Ç—å</button>
</div>

<div id="hud" style="position:fixed;top:10px;left:10px;color:#0ff;font-family:monospace;">üí† –ö—Ä–µ–¥–∏—Ç—ã: <span id="coins">0</span></div>

<style>
body{margin:0;overflow:hidden;background:#000;color:#0ff;font-family:monospace;}
#loading{position:fixed;inset:0;display:flex;justify-content:center;align-items:center;background:#000;font-size:2em;color:#0ff;transition:1s;}
#menu{position:fixed;inset:0;display:flex;flex-direction:column;justify-content:center;align-items:center;gap:20px;background:#000;color:#0ff;transition:0.5s;}
#menu h1{font-size:3em;animation:pulse 2s infinite;}
button{background:none;border:1px solid #0ff;color:#0ff;padding:10px 30px;font-size:1.2em;cursor:pointer;transition:0.3s;}
button:hover{background:#0ff;color:#000;}
@keyframes pulse{0%{text-shadow:0 0 5px #0ff;}50%{text-shadow:0 0 20px #0ff;}100%{text-shadow:0 0 5px #0ff;}}
.dots::after{content:"";animation:dots 1s infinite;}
@keyframes dots{0%{content:".";}50%{content:"..";}100%{content:"...";}}
</style>
