<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–•—Ä–æ–Ω–∏–∫–∏ –ø–∞–¥–∞—é—â–∏—Ö –∑–≤—ë–∑–¥ | –ö–æ—Å–º–∏—á–µ—Å–∫–∏–π —Ä–µ–π–¥–µ—Ä</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 5, 15, 0.95);
            z-index: 20;
        }
        
        .hidden {
            display: none;
        }
        
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border: 2px solid #0ff;
            border-radius: 8px;
        }
        
        .resources {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 16px;
            text-shadow: 0 0 10px #0ff;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px;
            border: 2px solid #0ff;
            border-radius: 8px;
            text-align: right;
        }
        
        /* –ü—Ä–æ—Å—Ç–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ - 3 –∫–Ω–æ–ø–∫–∏ */
        .simple-controls {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 40px;
            pointer-events: auto;
        }
        
        .control-btn {
            width: 90px;
            height: 90px;
            border-radius: 20px;
            background: rgba(0, 255, 255, 0.4);
            border: 3px solid #0ff;
            color: #0ff;
            font-size: 32px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: 0 0 25px #0ff;
            touch-action: manipulation;
            transition: all 0.1s;
        }
        
        .control-btn:active {
            background: rgba(0, 255, 255, 0.8);
            transform: scale(0.95);
            box-shadow: 0 0 40px #0ff;
        }
        
        .btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 15px 30px;
            margin: 15px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
            border-radius: 8px;
            text-shadow: 0 0 5px #0ff;
            box-shadow: 0 0 15px #0ff;
        }
        
        .btn:active {
            background: rgba(0, 255, 255, 0.2);
        }
        
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0) 0%,
                rgba(255,255,255,0.03) 50%,
                rgba(255,255,255,0) 100%
            );
            background-size: 100% 3px;
            pointer-events: none;
            z-index: 5;
        }
        
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
            text-align: center;
            z-index: 100;
            text-shadow: 0 0 10px #0ff;
        }
        
        .planet-interface {
            background: rgba(0, 15, 40, 0.95);
            padding: 40px;
            border: 3px solid #0ff;
            border-radius: 20px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
            box-shadow: 0 0 40px #0ff;
        }
        
        .dialogue {
            margin: 25px 0;
            padding: 20px;
            border: 2px solid #0ff;
            border-radius: 12px;
            background: rgba(0, 25, 50, 0.8);
            font-size: 16px;
            line-height: 1.5;
        }
        
        .trader-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 25px 0;
        }
        
        .trader-option {
            padding: 15px;
            border: 2px solid #0ff;
            border-radius: 8px;
            background: rgba(0, 40, 80, 0.7);
            cursor: pointer;
            text-align: center;
            pointer-events: auto;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .trader-option:active {
            background: rgba(0, 60, 120, 0.9);
            transform: scale(0.98);
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        /* –ê–¥–∞–ø—Ç–∞—Ü–∏—è –¥–ª—è –æ—á–µ–Ω—å –º–∞–ª–µ–Ω—å–∫–∏—Ö —ç–∫—Ä–∞–Ω–æ–≤ */
        @media (max-height: 600px) {
            .hud, .resources {
                font-size: 14px;
                padding: 8px;
            }
            
            .control-btn {
                width: 80px;
                height: 80px;
                font-size: 28px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading pulse">–ó–ê–ì–†–£–ó–ö–ê –ö–û–°–ú–ò–ß–ï–°–ö–û–ì–û –†–ï–ô–î–ï–†–ê...</div>
    <div id="gameContainer"></div>
    <div id="ui">
        <div class="scanlines"></div>
        
        <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
        <div id="menuScreen" class="screen">
            <h1 style="font-size: 3.5rem; margin-bottom: 2rem; text-shadow: 0 0 20px #0ff;" class="pulse">–ö–û–°–ú–ò–ß–ï–°–ö–ò–ô –†–ï–ô–î–ï–†</h1>
            <p style="margin-bottom: 40px; text-align: center; font-size: 1.2rem;">–ë–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ —á–µ—Ä–µ–∑ –≥–∞–ª–∞–∫—Ç–∏–∫—É</p>
            <button class="btn" id="startBtn">–°–¢–ê–†–¢</button>
        </div>
        
        <!-- –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
        <div id="gameScreen" class="screen hidden">
            <div class="hud">
                <div>‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï: <span id="healthValue">100</span>%</div>
                <div>üöÄ –°–ö–û–†–û–°–¢–¨: <span id="speedValue">50</span></div>
                <div>üõ°Ô∏è –©–ò–¢: <span id="shieldValue">100</span>%</div>
            </div>
            
            <div class="resources">
                <div>‚≠ê –ó–í–Å–ó–î–´: <span id="starsValue">0</span></div>
                <div>üíé –ö–†–ò–°–¢–ê–õ–õ–´: <span id="fragmentsValue">0</span></div>
                <div>üèÜ –û–ß–ö–ò: <span id="scoreValue">0</span></div>
            </div>
            
            <div class="simple-controls">
                <div class="control-btn" id="leftBtn">‚Üê</div>
                <div class="control-btn" id="shieldBtn">üõ°Ô∏è</div>
                <div class="control-btn" id="rightBtn">‚Üí</div>
            </div>
        </div>
        
        <!-- –≠–∫—Ä–∞–Ω –ø–ª–∞–Ω–µ—Ç—ã -->
        <div id="planetScreen" class="screen hidden">
            <div class="planet-interface">
                <h2 id="planetName" style="text-align: center; margin-bottom: 20px; text-shadow: 0 0 10px #0ff;">–ü–õ–ê–ù–ï–¢–ê</h2>
                <div class="dialogue" id="planetDialogue">
                    –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ –ø–ª–∞–Ω–µ—Ç—É! –ß–µ–º –º–æ–≥—É –ø–æ–º–æ—á—å?
                </div>
                
                <div class="trader-options">
                    <div class="trader-option" data-action="trade">üõí –¢–û–†–ì–û–í–ê–¢–¨</div>
                    <div class="trader-option" data-action="talk">üí¨ –ü–û–ë–û–õ–¢–ê–¢–¨</div>
                    <div class="trader-option" data-action="repair">üîß –ü–û–ß–ò–ù–ò–¢–¨ –ö–û–†–ê–ë–õ–¨</div>
                    <div class="trader-option" data-action="upgrade">‚ö° –£–õ–£–ß–®–ï–ù–ò–Ø</div>
                    <div class="trader-option" data-action="mission">üéØ –ó–ê–î–ê–ù–ò–ï</div>
                    <div class="trader-option" data-action="leave">üöÄ –£–õ–ï–¢–ï–¢–¨</div>
                </div>
                
                <div id="tradeInterface" style="display: none; margin-top: 25px;">
                    <h3 style="text-align: center; margin-bottom: 15px;">üõí –¢–û–†–ì–û–í–õ–Ø</h3>
                    <div class="trader-options">
                        <div class="trader-option" data-trade="buyStars">–ö–£–ü–ò–¢–¨ ‚≠ê (10üíé)</div>
                        <div class="trader-option" data-trade="sellStars">–ü–†–û–î–ê–¢–¨ ‚≠ê (8üíé)</div>
                        <div class="trader-option" data-trade="buyShield">–ö–£–ü–ò–¢–¨ –©–ò–¢ (50üíé)</div>
                        <div class="trader-option" data-trade="back">‚Üê –ù–ê–ó–ê–î</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- –≠–∫—Ä–∞–Ω –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä—ã -->
        <div id="gameOver" class="screen hidden">
            <div style="background: rgba(0, 0, 0, 0.95); padding: 40px; border: 3px solid #f00; text-align: center; border-radius: 15px; box-shadow: 0 0 40px #f00;">
                <h2 style="color: #f00; text-shadow: 0 0 10px #f00;">–ö–û–†–ê–ë–õ–¨ –£–ù–ò–ß–¢–û–ñ–ï–ù</h2>
                <p style="margin: 25px 0; font-size: 20px;">–í–∞—à —Å—á—ë—Ç: <span id="finalScore">0</span></p>
                <button class="btn" id="restartBtn">–ù–û–í–ê–Ø –ò–ì–†–ê</button>
                <button class="btn" id="menuBtn">–ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ</button>
            </div>
        </div>
    </div>

    <script>
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥—Ä—É–∑–∫—É Three.js
        if (typeof THREE === 'undefined') {
            document.getElementById('loading').innerHTML = '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ Three.js. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É.';
            throw new Error('Three.js –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω');
        }

        let scene, camera, renderer, ship;
        let asteroids = [], enemyShips = [], starFields = [], planets = [], crystals = [];
        let engineParticles = [], nebulas = [];
        
        // –ò–≥—Ä–æ–≤—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let gameState = {
            health: 100,
            stars: 0,
            fragments: 0,
            score: 0,
            speed: 0.8, // –£–≤–µ–ª–∏—á–∏–ª —Å–∫–æ—Ä–æ—Å—Ç—å –¥–ª—è –±–æ–ª–µ–µ –¥–∏–Ω–∞–º–∏—á–Ω–æ–π –∏–≥—Ä—ã
            rotationSpeed: 0.03,
            isShieldActive: false,
            shieldEnergy: 100,
            gameActive: false,
            touchControls: {
                left: false,
                right: false
            },
            currentPlanet: null
        };

        // –ü–ª–∞–Ω–µ—Ç—ã –∏ –∏—Ö –æ–ø–∏—Å–∞–Ω–∏—è
        const planetData = [
            { 
                name: "–ö–†–ò–û–ù–ò–°", 
                dialogue: "–õ–µ–¥—è–Ω–æ–π –≥–∏–≥–∞–Ω—Ç —Å —Å–∏—è—é—â–∏–º–∏ –∫—Ä–∏—Å—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–º–∏ –æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è–º–∏.",
                color: 0x88ccff,
                size: 25
            },
            { 
                name: "–ü–ò–†–û–°", 
                dialogue: "–†–∞—Å–∫–∞–ª—ë–Ω–Ω—ã–π –º–∏—Ä —Å –≤—É–ª–∫–∞–Ω–∏—á–µ—Å–∫–∏–º–∏ –º–æ—Ä—è–º–∏ –ª–∞–≤—ã.",
                color: 0xff6633,
                size: 30
            },
            { 
                name: "–í–ï–†–î–ê–ù–¢", 
                dialogue: "–ó–µ–ª—ë–Ω—ã–π –º–∏—Ä —Å –±–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ç–Ω—ã–º–∏ –ª–µ—Å–∞–º–∏.",
                color: 0x44ff88,
                size: 22
            },
            { 
                name: "–ù–ï–ö–°–£–°", 
                dialogue: "–ì–∏–≥–∞–Ω—Ç—Å–∫–∞—è –∫–æ—Å–º–∏—á–µ—Å–∫–∞—è —Å—Ç–∞–Ω—Ü–∏—è - —Ü–µ–Ω—Ç—Ä —Ç–æ—Ä–≥–æ–≤–ª–∏.",
                color: 0x8888ff,
                size: 35
            },
            { 
                name: "–ê–£–†–ï–õ–ò–Ø", 
                dialogue: "–ó–æ–ª–æ—Ç–∞—è –ø–ª–∞–Ω–µ—Ç–∞ —Å —Ä–µ–¥–∫–∏–º–∏ –º–µ—Ç–∞–ª–ª–∏—á–µ—Å–∫–∏–º–∏ —Ñ–æ—Ä–º–∞–º–∏ –∂–∏–∑–Ω–∏.",
                color: 0xffdd44,
                size: 28
            }
        ];

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
        function initThreeJS() {
            try {
                // –°—Ü–µ–Ω–∞
                scene = new THREE.Scene();
                
                // –ö–∞–º–µ—Ä–∞
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                
                // –†–µ–Ω–¥–µ—Ä–µ—Ä —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true,
                    alpha: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000022, 1);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('gameContainer').appendChild(renderer.domElement);
                
                // –£–ª—É—á—à–µ–Ω–Ω–æ–µ –æ—Å–≤–µ—â–µ–Ω–∏–µ
                const ambientLight = new THREE.AmbientLight(0x444477, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                scene.add(directionalLight);
                
                const pointLight = new THREE.PointLight(0x4488ff, 0.8, 100);
                pointLight.position.set(0, 0, 20);
                scene.add(pointLight);
                
                // –ó–≤—ë–∑–¥–Ω–æ–µ –Ω–µ–±–æ
                createStarfield();
                
                // –¢—É–º–∞–Ω–Ω–æ—Å—Ç–∏
                createNebulas();
                
                // –ö–æ—Ä–∞–±–ª—å –∏–≥—Ä–æ–∫–∞
                createShip();
                
                // –°–∫—Ä—ã–≤–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É
                document.getElementById('loading').style.display = 'none';
                
                return true;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Three.js:', error);
                document.getElementById('loading').innerHTML = '–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ 3D. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∫—É WebGL.';
                return false;
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∑–≤—ë–∑–¥–Ω–æ–≥–æ –Ω–µ–±–∞
        function createStarfield() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 3000;
            const starPositions = new Float32Array(starCount * 3);
            const starColors = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i += 3) {
                starPositions[i] = (Math.random() - 0.5) * 2000;
                starPositions[i + 1] = (Math.random() - 0.5) * 2000;
                starPositions[i + 2] = (Math.random() - 0.5) * 2000;
                
                // –†–∞–∑–Ω—ã–µ —Ü–≤–µ—Ç–∞ –∑–≤–µ–∑–¥
                const colorChoice = Math.random();
                if (colorChoice < 0.7) {
                    starColors[i] = 1; starColors[i + 1] = 1; starColors[i + 2] = 1; // –ë–µ–ª—ã–π
                } else if (colorChoice < 0.85) {
                    starColors[i] = 0.8; starColors[i + 1] = 0.9; starColors[i + 2] = 1; // –ì–æ–ª—É–±–æ–π
                } else {
                    starColors[i] = 1; starColors[i + 1] = 0.8; starColors[i + 2] = 0.6; // –ñ–µ–ª—Ç—ã–π
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                size: 2,
                sizeAttenuation: true,
                vertexColors: true,
                transparent: true
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —Ç—É–º–∞–Ω–Ω–æ—Å—Ç–µ–π
        function createNebulas() {
            for (let i = 0; i < 3; i++) {
                const nebulaGeometry = new THREE.SphereGeometry(300 + Math.random() * 200, 16, 16);
                const nebulaMaterial = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.7, 0.3),
                    transparent: true,
                    opacity: 0.05,
                    side: THREE.BackSide
                });
                
                const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
                nebula.position.set(
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000,
                    (Math.random() - 0.5) * 1000
                );
                scene.add(nebula);
                nebulas.push(nebula);
            }
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è
        function createShip() {
            const group = new THREE.Group();
            
            // –ö–æ—Ä–ø—É—Å –∫–æ—Ä–∞–±–ª—è
            const hullGeometry = new THREE.ConeGeometry(4, 12, 4);
            const hullMaterial = new THREE.MeshPhongMaterial({
                color: 0x00aaff,
                shininess: 100,
                emissive: 0x002266
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            hull.rotation.x = Math.PI / 2;
            group.add(hull);
            
            // –ö—Ä—ã–ª—å—è
            const wingGeometry = new THREE.BoxGeometry(8, 1, 4);
            const wingMaterial = new THREE.MeshPhongMaterial({
                color: 0x0088ff,
                shininess: 80,
                emissive: 0x001133
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-6, 0, 0);
            group.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(6, 0, 0);
            group.add(rightWing);
            
            // –î–≤–∏–≥–∞—Ç–µ–ª–∏
            const engineGeometry = new THREE.CylinderGeometry(1.5, 2, 3, 8);
            const engineMaterial = new THREE.MeshPhongMaterial({
                color: 0xff6600,
                emissive: 0xff3300,
                shininess: 30
            });
            const leftEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            leftEngine.position.set(-3, 0, -4);
            leftEngine.rotation.x = Math.PI / 2;
            group.add(leftEngine);
            
            const rightEngine = new THREE.Mesh(engineGeometry, engineMaterial);
            rightEngine.position.set(3, 0, -4);
            rightEngine.rotation.x = Math.PI / 2;
            group.add(rightEngine);
            
            group.position.z = 15;
            group.position.y = 0; // –§–∏–∫—Å–∏—Ä—É–µ–º –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
            scene.add(group);
            ship = group;
            
            // –°–æ–∑–¥–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –¥–≤–∏–≥–∞—Ç–µ–ª—è
            createEngineParticles();
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è
        function createEngineParticles() {
            const particleCount = 20;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = 0;
                positions[i + 1] = 0;
                positions[i + 2] = -5 - Math.random() * 10;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffaa00,
                size: 2,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            ship.add(particleSystem);
            engineParticles.push(particleSystem);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è
        function updateEngineParticles() {
            engineParticles.forEach(particles => {
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 2] -= 0.5 + Math.random() * 0.5;
                    if (positions[i + 2] < -15) {
                        positions[i + 2] = -5;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
            });
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
        function generateAsteroids(count) {
            for (let i = 0; i < count; i++) {
                const size = Math.random() * 6 + 2;
                const geometry = new THREE.IcosahedronGeometry(size, 1);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xaaaaaa,
                    shininess: 30,
                    emissive: 0x222222
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                
                asteroid.position.x = (Math.random() - 0.5) * 200;
                asteroid.position.y = 0; // –í—Å–µ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                asteroid.position.z = -100 - Math.random() * 500;
                
                asteroid.rotation.x = Math.random() * Math.PI;
                asteroid.rotation.y = Math.random() * Math.PI;
                
                asteroid.userData = {
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    }
                };
                
                asteroid.castShadow = true;
                scene.add(asteroid);
                asteroids.push(asteroid);
            }
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–∞–∂–µ—Å–∫–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π
        function generateEnemyShips(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.OctahedronGeometry(4, 0);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff3300,
                    shininess: 100,
                    emissive: 0x660000
                });
                
                const enemyShip = new THREE.Mesh(geometry, material);
                
                enemyShip.position.x = (Math.random() - 0.5) * 150;
                enemyShip.position.y = 0; // –í—Å–µ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                enemyShip.position.z = -200 - Math.random() * 400;
                
                enemyShip.userData = {
                    health: 30
                };
                
                enemyShip.castShadow = true;
                scene.add(enemyShip);
                enemyShips.push(enemyShip);
            }
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–ª–µ–π –∑–≤—ë–∑–¥ (—Ä–µ—Å—É—Ä—Å—ã)
        function generateStarFields(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(3, 12, 12);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    shininess: 100,
                    emissive: 0x666600
                });
                
                const starField = new THREE.Mesh(geometry, material);
                
                starField.position.x = (Math.random() - 0.5) * 180;
                starField.position.y = 0; // –í—Å–µ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                starField.position.z = -150 - Math.random() * 450;
                
                starField.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    collected: false
                };
                
                starField.castShadow = true;
                scene.add(starField);
                starFields.push(starField);
            }
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
        function generateCrystals(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.OctahedronGeometry(2.5, 0);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff00ff,
                    shininess: 100,
                    emissive: 0x660066
                });
                
                const crystal = new THREE.Mesh(geometry, material);
                
                crystal.position.x = (Math.random() - 0.5) * 200;
                crystal.position.y = 0; // –í—Å–µ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                crystal.position.z = -100 - Math.random() * 600;
                
                crystal.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.03,
                    collected: false
                };
                
                crystal.castShadow = true;
                scene.add(crystal);
                crystals.push(crystal);
            }
        }
        
        // –ü—Ä–æ—Ü–µ–¥—É—Ä–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–µ—Ç
        function generatePlanets(count) {
            for (let i = 0; i < count; i++) {
                const planetInfo = planetData[Math.floor(Math.random() * planetData.length)];
                const geometry = new THREE.SphereGeometry(planetInfo.size, 32, 32);
                
                const material = new THREE.MeshPhongMaterial({
                    color: planetInfo.color,
                    shininess: 30,
                    emissive: new THREE.Color(planetInfo.color).multiplyScalar(0.1)
                });
                
                const planet = new THREE.Mesh(geometry, material);
                
                planet.position.x = (Math.random() - 0.5) * 300;
                planet.position.y = 0; // –í—Å–µ –Ω–∞ –æ–¥–Ω–æ–π –ø–ª–æ—Å–∫–æ—Å—Ç–∏
                planet.position.z = -400 - Math.random() * 800;
                
                planet.userData = {
                    size: planetInfo.size,
                    planetData: planetInfo
                };
                
                planet.castShadow = true;
                scene.add(planet);
                planets.push(planet);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è
        function updateGameState() {
            if (!gameState.gameActive || !ship) return;
            
            // –ö–æ—Ä–∞–±–ª—å –≤—Å–µ–≥–¥–∞ –ª–µ—Ç–∏—Ç –í–ü–ï–†–Å–î –ø–æ —Å–≤–æ–µ–π –ª–æ–∫–∞–ª—å–Ω–æ–π –æ—Å–∏ Z
            // –í—ã—á–∏—Å–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ—Ä–∞–±–ª—è
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(ship.quaternion);
            
            // –î–≤–∏–≥–∞–µ–º –∫–æ—Ä–∞–±–ª—å –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –µ–≥–æ –Ω–æ—Å–∞
            ship.position.add(direction.multiplyScalar(gameState.speed));
            
            // –ü–æ–≤–æ—Ä–æ—Ç –∫–æ—Ä–∞–±–ª—è –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ
            if (gameState.touchControls.left) {
                ship.rotation.y += gameState.rotationSpeed;
            }
            if (gameState.touchControls.right) {
                ship.rotation.y -= gameState.rotationSpeed;
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã - —Å–ª–µ–¥—É–µ—Ç –∑–∞ –∫–æ—Ä–∞–±–ª–µ–º
            camera.position.x = ship.position.x;
            camera.position.y = 5; // –ù–µ–º–Ω–æ–≥–æ –≤—ã—à–µ –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–±–∑–æ—Ä–∞
            camera.position.z = ship.position.z + 20;
            
            // –ö–∞–º–µ—Ä–∞ –≤—Å–µ–≥–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –Ω–µ–º–Ω–æ–≥–æ –≤–ø–µ—Ä–µ–¥ –æ—Ç –∫–æ—Ä–∞–±–ª—è
            const lookAtPoint = ship.position.clone();
            lookAtPoint.add(direction.multiplyScalar(10));
            camera.lookAt(lookAtPoint);
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –¥–≤–∏–≥–∞—Ç–µ–ª—è
            updateEngineParticles();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤ (–æ–Ω–∏ —Å—Ç–æ—è—Ç –Ω–∞ –º–µ—Å—Ç–µ, —Å–æ–∑–¥–∞–≤–∞—è –∏–ª–ª—é–∑–∏—é –¥–≤–∏–∂–µ–Ω–∏—è)
            asteroids.forEach((asteroid, index) => {
                asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è —Å –∫–æ—Ä–∞–±–ª–µ–º
                const distance = Math.sqrt(
                    Math.pow(asteroid.position.x - ship.position.x, 2) +
                    Math.pow(asteroid.position.z - ship.position.z, 2)
                );
                
                if (distance < 10) {
                    if (gameState.isShieldActive) {
                        gameState.shieldEnergy -= 20;
                        // –≠—Ñ—Ñ–µ–∫—Ç –æ—Ç—Å–∫–æ–∫–∞ –ø—Ä–∏ —â–∏—Ç–µ
                        asteroid.position.x += (asteroid.position.x - ship.position.x) * 0.5;
                        asteroid.position.z += (asteroid.position.z - ship.position.z) * 0.5;
                    } else {
                        gameState.health -= 10;
                        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—è
                        ship.scale.set(1.1, 1.1, 1.1);
                        setTimeout(() => ship.scale.set(1, 1, 1), 100);
                    }
                    
                    scene.remove(asteroid);
                    asteroids.splice(index, 1);
                    generateAsteroids(1);
                }
                
                // –ï—Å–ª–∏ –∞—Å—Ç–µ—Ä–æ–∏–¥ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –ø–æ–∑–∞–¥–∏, —É–¥–∞–ª—è–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≤–ø–µ—Ä–µ–¥–∏
                if (asteroid.position.z > ship.position.z + 200) {
                    scene.remove(asteroid);
                    asteroids.splice(index, 1);
                    generateAsteroids(1);
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–∂–µ—Å–∫–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π
            enemyShips.forEach((enemy, index) => {
                // –í—Ä–∞–≥–∏ –¥–≤–∏–∂—É—Ç—Å—è –∫ –∫–æ—Ä–∞–±–ª—é
                const dx = ship.position.x - enemy.position.x;
                const dz = ship.position.z - enemy.position.z;
                
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance < 100) {
                    // –ï—Å–ª–∏ –±–ª–∏–∑–∫–æ, –ø—Ä–µ—Å–ª–µ–¥—É–µ–º –∏–≥—Ä–æ–∫–∞
                    enemy.position.x += dx * 0.01;
                }
                
                const collisionDistance = Math.sqrt(
                    Math.pow(enemy.position.x - ship.position.x, 2) +
                    Math.pow(enemy.position.z - ship.position.z, 2)
                );
                
                if (collisionDistance < 10) {
                    if (gameState.isShieldActive) {
                        gameState.shieldEnergy -= 15;
                    } else {
                        gameState.health -= 15;
                    }
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç –≤–∑—Ä—ã–≤–∞
                    createExplosion(enemy.position);
                    
                    scene.remove(enemy);
                    enemyShips.splice(index, 1);
                    gameState.fragments += 5;
                    generateEnemyShips(1);
                }
                
                // –ï—Å–ª–∏ –≤—Ä–∞–≥ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –ø–æ–∑–∞–¥–∏, —É–¥–∞–ª—è–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –≤–ø–µ—Ä–µ–¥–∏
                if (enemy.position.z > ship.position.z + 200) {
                    scene.remove(enemy);
                    enemyShips.splice(index, 1);
                    generateEnemyShips(1);
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–µ–π –∑–≤—ë–∑–¥
            starFields.forEach((star, index) => {
                star.rotation.y += star.userData.rotationSpeed;
                
                const distance = Math.sqrt(
                    Math.pow(star.position.x - ship.position.x, 2) +
                    Math.pow(star.position.z - ship.position.z, 2)
                );
                
                if (distance < 8 && !star.userData.collected) {
                    star.userData.collected = true;
                    gameState.stars += 1;
                    gameState.score += 10;
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç —Å–±–æ—Ä–∞
                    star.scale.set(0.1, 0.1, 0.1);
                    createCollectEffect(star.position);
                    
                    setTimeout(() => {
                        scene.remove(star);
                        starFields.splice(index, 1);
                        generateStarFields(1);
                    }, 300);
                }
                
                // –ï—Å–ª–∏ –∑–≤–µ–∑–¥–∞ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –ø–æ–∑–∞–¥–∏, —É–¥–∞–ª—è–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≤–ø–µ—Ä–µ–¥–∏
                if (star.position.z > ship.position.z + 200) {
                    scene.remove(star);
                    starFields.splice(index, 1);
                    generateStarFields(1);
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤
            crystals.forEach((crystal, index) => {
                crystal.rotation.y += crystal.userData.rotationSpeed;
                
                const distance = Math.sqrt(
                    Math.pow(crystal.position.x - ship.position.x, 2) +
                    Math.pow(crystal.position.z - ship.position.z, 2)
                );
                
                if (distance < 7 && !crystal.userData.collected) {
                    crystal.userData.collected = true;
                    gameState.fragments += 2;
                    gameState.score += 20;
                    
                    // –≠—Ñ—Ñ–µ–∫—Ç —Å–±–æ—Ä–∞
                    crystal.scale.set(0.1, 0.1, 0.1);
                    createCollectEffect(crystal.position);
                    
                    setTimeout(() => {
                        scene.remove(crystal);
                        crystals.splice(index, 1);
                        generateCrystals(1);
                    }, 300);
                }
                
                // –ï—Å–ª–∏ –∫—Ä–∏—Å—Ç–∞–ª–ª —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –ø–æ–∑–∞–¥–∏, —É–¥–∞–ª—è–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –≤–ø–µ—Ä–µ–¥–∏
                if (crystal.position.z > ship.position.z + 200) {
                    scene.remove(crystal);
                    crystals.splice(index, 1);
                    generateCrystals(1);
                }
            });
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Å–∞–¥–∫–∏
            planets.forEach((planet, index) => {
                planet.rotation.y += 0.002;
                
                const distance = Math.sqrt(
                    Math.pow(planet.position.x - ship.position.x, 2) +
                    Math.pow(planet.position.z - ship.position.z, 2)
                );
                
                // –ï—Å–ª–∏ –±–ª–∏–∑–∫–æ –∫ –ø–ª–∞–Ω–µ—Ç–µ, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø–æ—Å–∞–¥–∫—É
                if (distance < planet.userData.size + 15) {
                    landOnPlanet(planet);
                }
                
                // –ï—Å–ª–∏ –ø–ª–∞–Ω–µ—Ç–∞ —Å–ª–∏—à–∫–æ–º –¥–∞–ª–µ–∫–æ –ø–æ–∑–∞–¥–∏, —É–¥–∞–ª—è–µ–º –∏ —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –≤–ø–µ—Ä–µ–¥–∏
                if (planet.position.z > ship.position.z + 200) {
                    scene.remove(planet);
                    planets.splice(index, 1);
                    generatePlanets(1);
                }
            });
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏ —â–∏—Ç–∞
            if (!gameState.isShieldActive && gameState.shieldEnergy < 100) {
                gameState.shieldEnergy = Math.min(gameState.shieldEnergy + 0.1, 100);
            }
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
            updateUI();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–∫–æ–Ω—á–∞–Ω–∏—è –∏–≥—Ä—ã
            if (gameState.health <= 0) {
                gameOver();
            }
            
            // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—á—ë—Ç–∞ —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
            gameState.score += gameState.speed * 0.1;
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ –≤–∑—Ä—ã–≤–∞
        function createExplosion(position) {
            const particleCount = 15;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = position.x + (Math.random() - 0.5) * 5;
                positions[i + 1] = position.y + (Math.random() - 0.5) * 5;
                positions[i + 2] = position.z + (Math.random() - 0.5) * 5;
                
                colors[i] = 1;     // R
                colors[i + 1] = 0.5; // G
                colors[i + 2] = 0;   // B
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 3,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
            let opacity = 1;
            const fadeInterval = setInterval(() => {
                opacity -= 0.05;
                particleMaterial.opacity = opacity;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(particleSystem);
                }
            }, 50);
        }
        
        // –°–æ–∑–¥–∞–Ω–∏–µ —ç—Ñ—Ñ–µ–∫—Ç–∞ —Å–±–æ—Ä–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
        function createCollectEffect(position) {
            const particleCount = 10;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = position.x + (Math.random() - 0.5) * 3;
                positions[i + 1] = position.y + (Math.random() - 0.5) * 3;
                positions[i + 2] = position.z + (Math.random() - 0.5) * 3;
                
                colors[i] = 1;     // R
                colors[i + 1] = 1; // G
                colors[i + 2] = 0;   // B
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 2,
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
            
            // –ê–Ω–∏–º–∞—Ü–∏—è –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏—è
            let opacity = 1;
            const fadeInterval = setInterval(() => {
                opacity -= 0.1;
                particleMaterial.opacity = opacity;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(particleSystem);
                }
            }, 50);
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
        function updateUI() {
            document.getElementById('healthValue').textContent = Math.max(0, Math.round(gameState.health));
            document.getElementById('speedValue').textContent = Math.round(gameState.speed * 100);
            document.getElementById('shieldValue').textContent = Math.round(gameState.shieldEnergy);
            document.getElementById('starsValue').textContent = gameState.stars;
            document.getElementById('fragmentsValue').textContent = gameState.fragments;
            document.getElementById('scoreValue').textContent = Math.round(gameState.score);
        }
        
        // –ê–∫—Ç–∏–≤–∞—Ü–∏—è —â–∏—Ç–∞
        function activateShield() {
            if (gameState.shieldEnergy >= 20 && !gameState.isShieldActive && ship) {
                gameState.isShieldActive = true;
                
                const shieldGeometry = new THREE.SphereGeometry(8, 16, 16);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                ship.add(shield);
                
                setTimeout(() => {
                    if (shield.parent) {
                        ship.remove(shield);
                    }
                    gameState.isShieldActive = false;
                }, 3000);
            }
        }
        
        // –ü–æ—Å–∞–¥–∫–∞ –Ω–∞ –ø–ª–∞–Ω–µ—Ç—É
        function landOnPlanet(planet) {
            gameState.gameActive = false;
            gameState.currentPlanet = planet;
            
            // –£–±–∏—Ä–∞–µ–º –ø–ª–∞–Ω–µ—Ç—É –∏–∑ —Å—Ü–µ–Ω—ã
            scene.remove(planet);
            planets = planets.filter(p => p !== planet);
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –ø–ª–∞–Ω–µ—Ç—ã
            document.getElementById('planetName').textContent = planet.userData.planetData.name;
            document.getElementById('planetDialogue').textContent = planet.userData.planetData.dialogue;
            
            showScreen('planetScreen');
        }
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞ –ø–ª–∞–Ω–µ—Ç–µ
        function handlePlanetAction(action) {
            const dialogue = document.getElementById('planetDialogue');
            const tradeInterface = document.getElementById('tradeInterface');
            
            switch(action) {
                case 'trade':
                    tradeInterface.style.display = 'block';
                    dialogue.textContent = '–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?';
                    break;
                case 'talk':
                    const responses = [
                        '–ú–µ—Å—Ç–Ω—ã–µ –ª–µ–≥–µ–Ω–¥—ã –≥–æ–≤–æ—Ä—è—Ç –æ –¥—Ä–µ–≤–Ω–µ–π —Ü–∏–≤–∏–ª–∏–∑–∞—Ü–∏–∏, –æ—Å—Ç–∞–≤–∏–≤—à–µ–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –≤ —ç—Ç–∏—Ö –∑–≤—ë–∑–¥–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö.',
                        '–ë—É–¥—å –æ—Å—Ç–æ—Ä–æ–∂–µ–Ω –≤ —Å–µ–∫—Ç–æ—Ä–µ N-7, —Ç–∞–º –≤–∏–¥–µ–ª–∏ –∫–æ—Ä–∞–±–ª–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –ø—Ä–æ–∏—Å—Ö–æ–∂–¥–µ–Ω–∏—è.',
                        '–ï—Å–ª–∏ –Ω–∞–π–¥—ë—à—å –≥–æ–ª—É–±—ã–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã - –Ω–µ –ø—Ä–æ–¥–∞–≤–∞–π –∏—Ö –ø–µ—Ä–≤–æ–º—É –≤—Å—Ç—Ä–µ—á–Ω–æ–º—É, –æ–Ω–∏ —Ü–µ–Ω–Ω—ã –¥–ª—è —É—á—ë–Ω—ã—Ö.',
                        '–ù–∞ —ç—Ç–æ–π –ø–ª–∞–Ω–µ—Ç–µ –∫–æ–≥–¥–∞-—Ç–æ –±—ã–ª–∞ –≤–µ–ª–∏–∫–∞—è –∏–º–ø–µ—Ä–∏—è, –Ω–æ —Ç–µ–ø–µ—Ä—å –æ—Å—Ç–∞–ª–∏—Å—å –ª–∏—à—å —Ä—É–∏–Ω—ã.'
                    ];
                    dialogue.textContent = responses[Math.floor(Math.random() * responses.length)];
                    break;
                case 'repair':
                    if (gameState.fragments >= 30) {
                        gameState.health = Math.min(gameState.health + 50, 100);
                        gameState.fragments -= 30;
                        dialogue.textContent = '–ö–æ—Ä–∞–±–ª—å –æ—Ç—Ä–µ–º–æ–Ω—Ç–∏—Ä–æ–≤–∞–Ω! –ó–¥–æ—Ä–æ–≤—å–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ.';
                    } else {
                        dialogue.textContent = '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –¥–ª—è —Ä–µ–º–æ–Ω—Ç–∞ (–Ω—É–∂–Ω–æ 30üíé).';
                    }
                    break;
                case 'upgrade':
                    if (gameState.stars >= 5) {
                        gameState.speed += 0.1;
                        gameState.stars -= 5;
                        dialogue.textContent = '–î–≤–∏–≥–∞—Ç–µ–ª—å —É–ª—É—á—à–µ–Ω! –°–∫–æ—Ä–æ—Å—Ç—å —É–≤–µ–ª–∏—á–µ–Ω–∞.';
                    } else {
                        dialogue.textContent = '–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤—ë–∑–¥ –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è (–Ω—É–∂–Ω–æ 5‚≠ê).';
                    }
                    break;
                case 'mission':
                    const missions = [
                        '–°–æ–±–µ—Ä–∏ 10 –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –≤ —Å–æ—Å–µ–¥–Ω–µ–π —Å–∏—Å—Ç–µ–º–µ –∏ –ø–æ–ª—É—á–∏—à—å 50‚≠ê.',
                        '–£–Ω–∏—á—Ç–æ–∂—å 5 –≤—Ä–∞–∂–µ—Å–∫–∏—Ö –∫–æ—Ä–∞–±–ª–µ–π –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–ª—É—á—à–µ–Ω–Ω–æ–≥–æ —â–∏—Ç–∞.',
                        '–ù–∞–π–¥–∏ –¥—Ä–µ–≤–Ω–∏–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç –≤ –∞—Å—Ç–µ—Ä–æ–∏–¥–Ω–æ–º –ø–æ–ª–µ –∑–∞ 100üíé.'
                    ];
                    dialogue.textContent = '–ó–∞–¥–∞–Ω–∏–µ: ' + missions[Math.floor(Math.random() * missions.length)];
                    break;
                case 'leave':
                    tradeInterface.style.display = 'none';
                    showScreen('gameScreen');
                    gameState.gameActive = true;
                    generatePlanets(1); // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø–ª–∞–Ω–µ—Ç—É
                    break;
                case 'buyStars':
                    if (gameState.fragments >= 10) {
                        gameState.stars += 1;
                        gameState.fragments -= 10;
                        dialogue.textContent = '–ü–æ–∫—É–ø–∫–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞! –ü–æ–ª—É—á–µ–Ω–∞ 1‚≠ê.';
                    } else {
                        dialogue.textContent = '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ (–Ω—É–∂–Ω–æ 10üíé).';
                    }
                    break;
                case 'sellStars':
                    if (gameState.stars >= 1) {
                        gameState.stars -= 1;
                        gameState.fragments += 8;
                        dialogue.textContent = '–ü—Ä–æ–¥–∞–∂–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–∞! –ü–æ–ª—É—á–µ–Ω–æ 8üíé.';
                    } else {
                        dialogue.textContent = '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤—ë–∑–¥ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏ (–Ω—É–∂–Ω–æ 1‚≠ê).';
                    }
                    break;
                case 'buyShield':
                    if (gameState.fragments >= 50) {
                        gameState.shieldEnergy = 100;
                        gameState.fragments -= 50;
                        dialogue.textContent = '–©–∏—Ç –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!';
                    } else {
                        dialogue.textContent = '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤ –¥–ª—è –ø–æ–∫—É–ø–∫–∏ —â–∏—Ç–∞ (–Ω—É–∂–Ω–æ 50üíé).';
                    }
                    break;
                case 'back':
                    tradeInterface.style.display = 'none';
                    dialogue.textContent = '–ß–µ–º –µ—â—ë –º–æ–≥—É –ø–æ–º–æ—á—å?';
                    break;
            }
            updateUI();
        }
        
        // –ö–æ–Ω–µ—Ü –∏–≥—Ä—ã
        function gameOver() {
            gameState.gameActive = false;
            document.getElementById('finalScore').textContent = Math.round(gameState.score);
            showScreen('gameOver');
        }
        
        // –ù–æ–≤–∞—è –∏–≥—Ä–∞
        function startGame() {
            gameState.health = 100;
            gameState.stars = 0;
            gameState.fragments = 0;
            gameState.score = 0;
            gameState.speed = 0.8;
            gameState.isShieldActive = false;
            gameState.shieldEnergy = 100;
            gameState.gameActive = true;
            
            if (ship) {
                ship.position.x = 0;
                ship.position.z = 15;
                ship.rotation.y = 0;
            }
            
            // –û—á–∏—Å—Ç–∫–∞ —Å—Ü–µ–Ω—ã
            asteroids.forEach(asteroid => scene.remove(asteroid));
            enemyShips.forEach(enemy => scene.remove(enemy));
            starFields.forEach(star => scene.remove(star));
            crystals.forEach(crystal => scene.remove(crystal));
            planets.forEach(planet => scene.remove(planet));
            
            asteroids = [];
            enemyShips = [];
            starFields = [];
            crystals = [];
            planets = [];
            
            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –Ω–æ–≤—ã—Ö –æ–±—ä–µ–∫—Ç–æ–≤
            generateAsteroids(20);
            generateEnemyShips(8);
            generateStarFields(12);
            generateCrystals(8);
            generatePlanets(4);
            
            showScreen('gameScreen');
            updateUI();
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å —ç–∫—Ä–∞–Ω
        function showScreen(screenId) {
            // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ —ç–∫—Ä–∞–Ω—ã
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.add('hidden');
            });
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω—É–∂–Ω—ã–π —ç–∫—Ä–∞–Ω
            document.getElementById(screenId).classList.remove('hidden');
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ–Ω—Å–æ—Ä–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
        function setupTouchControls() {
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const shieldBtn = document.getElementById('shieldBtn');
            const restartBtn = document.getElementById('restartBtn');
            const startBtn = document.getElementById('startBtn');
            const menuBtn = document.getElementById('menuBtn');
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è
            const addButtonHandler = (button, controlName) => {
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    gameState.touchControls[controlName] = true;
                });
                
                button.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    gameState.touchControls[controlName] = false;
                });
                
                // –î–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞
                button.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    gameState.touchControls[controlName] = true;
                });
                
                button.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    gameState.touchControls[controlName] = false;
                });
            };
            
            addButtonHandler(leftBtn, 'left');
            addButtonHandler(rightBtn, 'right');
            
            // –ö–Ω–æ–ø–∫–∞ —â–∏—Ç–∞
            shieldBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                activateShield();
            });
            
            shieldBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                activateShield();
            });
            
            // –ö–Ω–æ–ø–∫–∏ –º–µ–Ω—é
            startBtn.addEventListener('click', () => {
                startGame();
            });
            
            restartBtn.addEventListener('click', () => {
                startGame();
            });
            
            menuBtn.addEventListener('click', () => {
                gameState.gameActive = false;
                showScreen('menuScreen');
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –ø–ª–∞–Ω–µ—Ç—ã
            document.querySelectorAll('.trader-option').forEach(option => {
                option.addEventListener('click', () => {
                    const action = option.getAttribute('data-action') || option.getAttribute('data-trade');
                    if (action) {
                        handlePlanetAction(action);
                    }
                });
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
        function setupEventListeners() {
            window.addEventListener('resize', () => {
                if (camera && renderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
        }
        
        // –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
        function gameLoop() {
            if (scene && camera && renderer) {
                updateGameState();
                renderer.render(scene, camera);
            }
            requestAnimationFrame(gameLoop);
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–≥—Ä—ã
        function init() {
            // –°–Ω–∞—á–∞–ª–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º Three.js
            if (!initThreeJS()) {
                return;
            }
            
            // –ó–∞—Ç–µ–º –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
            setupEventListeners();
            setupTouchControls();
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
            showScreen('menuScreen');
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
            gameLoop();
        }
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        window.addEventListener('load', init);
    </script>
</body>
</html>