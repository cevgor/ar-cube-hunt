<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Z.E.R.O.: Last Breach</title>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
:root{
  --neon:#00ffea; --accent:#ff6b6b; --bg:#05060a;
}
*{box-sizing:border-box;margin:0;padding:0;user-select:none;-webkit-user-select:none}
html,body,#app{height:100%}
body{background:linear-gradient(180deg,#030305,#0b0b10);font-family:Arial,Helvetica,sans-serif;color:var(--neon);overflow:hidden}
#app{position:relative;width:100vw;height:100vh}

/* Menu */
#menu{
  position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
  z-index:4000;
  pointer-events:auto;
  background: rgba(5, 6, 10, 0.95);
  backdrop-filter: blur(5px);
}
.menu-overlay{
  width:min(820px,94%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));
  border:1px solid rgba(0,255,234,0.07);padding:28px;border-radius:14px;text-align:center;backdrop-filter:blur(6px)
}
.menu-title{font-size:44px;letter-spacing:3px;background:linear-gradient(90deg,var(--neon),#5cc9ff);-webkit-background-clip:text;color:transparent;margin-bottom:6px}
.menu-sub{color:#bffdf7;opacity:0.9;margin-bottom:12px}
.menu-row{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}
.btn{padding:12px 18px;border-radius:10px;background:linear-gradient(180deg,#0d1116,#081018);border:1px solid rgba(0,255,234,0.06);color:var(--neon);cursor:pointer;font-weight:700;transition: all 0.2s ease;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,255,234,0.1);}
.btn:active{transform:translateY(0px);}
.btn.secondary{color:#ffb3d6;border-color:rgba(255,107,107,0.12)}
.btn.small{padding:8px 10px;font-size:14px}

/* Modals */
.modal{display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:4500;background:rgba(0,0,0,0.8);}
.modal.show{display:flex}
.modal .card{width:min(720px,94%);background:#07090b;padding:18px;border-radius:12px;border:1px solid rgba(0,255,234,0.06)}

/* Game UI */
#gameUI{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3000;pointer-events:none}
.panel{background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;border:1px solid rgba(0,255,234,0.04);display:flex;gap:8px;align-items:center;backdrop-filter:blur(6px)}
#hud{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:10px;pointer-events:none}
#healthBar{width:220px;height:14px;background:#111;border-radius:8px;overflow:hidden}
#healthFill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width 0.12s linear}

/* Bottom controls */
#bottomUI{position:absolute;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;pointer-events:auto;z-index:3200}
.weaponButtons{display:flex;gap:8px}
.wbtn{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(0,255,234,0.04);color:var(--neon);font-weight:700;cursor:pointer;transition: all 0.2s ease;}
.wbtn.active{border-color:rgba(0,255,234,0.6);background:rgba(0,255,234,0.1);}

/* Joystick */
#joystick{position:absolute;left:18px;bottom:18px;width:120px;height:120px;border-radius:50%;background:rgba(0,255,234,0.04);display:none;align-items:center;justify-content:center;pointer-events:auto;z-index:3200;border:2px solid rgba(0,255,234,0.1)}
#joyHandle{width:56px;height:56px;border-radius:50%;background:rgba(0,255,234,0.14);transform:translate(-50%,-50%);position:relative;left:50%;top:50%}

/* Crosshair */
#crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:28px;height:28px;pointer-events:none;z-index:3100}
.crossV{position:absolute;left:50%;transform:translateX(-50%);width:3px;height:28px;background:var(--neon)}
.crossH{position:absolute;top:50%;transform:translateY(-50%);height:3px;width:28px;background:var(--neon)}

/* gameContainer */
#gameContainer{position:absolute;inset:0;z-index:2000;pointer-events:none}

/* Results */
#results{position:absolute;inset:0;display:none;z-index:4200;align-items:center;justify-content:center;background:rgba(0,0,0,0.85)}
.results .card{padding:30px;border-radius:12px;background:linear-gradient(180deg,#07080a,#0b0b10);border:1px solid rgba(0,255,234,0.06);color:var(--neon)}

/* Responsive */
@media (max-width:900px){
  #joystick{display:flex}
  #crosshair{display:block}
}
</style>
</head>
<body>
<div id="app">
  <!-- Menu -->
  <div id="menu">
    <div class="menu-overlay">
      <div class="menu-title">Z.E.R.O.</div>
      <div class="menu-sub">LAST BREACH</div>
      <div class="menu-row">
        <button id="startButton" class="btn">üéÆ –ù–ê–ß–ê–¢–¨ –ú–ò–°–°–ò–Æ</button>
        <button id="settingsButton" class="btn">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button id="helpButton" class="btn secondary">üìñ –û–ë–£–ß–ï–ù–ò–ï</button>
      </div>
      <div style="margin-top:12px;color:#98fff8;opacity:0.9">–¢–∞–∫—Ç–∏—á–µ—Å–∫–∏–π —à—É—Ç–µ—Ä –≤—ã–∂–∏–≤–∞–Ω–∏—è —Å –≤–æ–ª–Ω–∞–º–∏ –≤—Ä–∞–≥–æ–≤</div>
    </div>
  </div>

  <!-- Modals -->
  <div id="modalSettings" class="modal">
    <div class="card">
      <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
      <div style="margin:10px 0;">–ì—Ä–æ–º–∫–æ—Å—Ç—å: <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.8"></div>
      <div style="margin:10px 0;">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <input id="sens" type="range" min="0.2" max="2" step="0.05" value="1"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px;"><button id="closeSettings" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
    </div>
  </div>

  <div id="modalHelp" class="modal">
    <div class="card">
      <h3>–û–±—É—á–µ–Ω–∏–µ</h3>
      <p>–î–≤–∏–∂–µ–Ω–∏–µ: WASD / —Å—Ç—Ä–µ–ª–∫–∏ –∏–ª–∏ –¥–∂–æ–π—Å—Ç–∏–∫. –°—Ç—Ä–µ–ª—å–±–∞: –º—ã—à—å/–∫–Ω–æ–ø–∫–∞. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è: 1/2/3.</p>
      <div style="display:flex;justify-content:flex-end"><button id="closeHelp" class="btn">–ü–æ–Ω—è—Ç–Ω–æ</button></div>
    </div>
  </div>

  <!-- Game UI -->
  <div id="gameUI">
    <div id="hud">
      <div class="panel"><div style="min-width:80px">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï</div>
        <div id="healthBar"><div id="healthFill"></div></div>
        <div id="hpTxt" style="min-width:60px;text-align:right;font-weight:700">100</div>
      </div>
      <div class="panel">–ü–∞—Ç—Ä–æ–Ω—ã: <div id="ammoTxt" style="margin-left:8px;font-weight:700">‚Äî</div></div>
      <div class="panel">–í–æ–ª–Ω–∞: <div id="waveTxt" style="margin-left:8px;font-weight:700">0</div></div>
    </div>

    <div id="bottomUI">
      <div class="weaponButtons">
        <button class="wbtn active" data-w="0">1 –ü–∏—Å—Ç–æ–ª–µ—Ç</button>
        <button class="wbtn" data-w="1">2 –ê–≤—Ç–æ</button>
        <button class="wbtn" data-w="2">3 –î—Ä–æ–±–æ–≤–∏–∫</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="shootBtn" class="btn">üî´</button>
        <button id="skillBtn" class="btn secondary">‚ö° –ò–º–ø—É–ª—å—Å</button>
        <button id="reloadBtn" class="btn small">‚Üª –ü–µ—Ä–µ–∑–∞—Ä—è–¥</button>
      </div>
    </div>

    <div id="joystick"><div id="joyHandle"></div></div>
    <div id="crosshair"><div class="crossV"></div><div class="crossH"></div></div>
  </div>

  <!-- Results -->
  <div id="results">
    <div class="results card">
      <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
      <div id="resultsText"></div>
      <div style="margin-top:12px">
        <button id="resultsToMenu" class="btn">–í –º–µ–Ω—é</button>
        <button id="restartButton" class="btn secondary" style="margin-left:8px">üîÑ –ó–∞–Ω–æ–≤–æ</button>
      </div>
    </div>
  </div>

  <!-- Canvas container -->
  <div id="gameContainer"></div>
</div>

<script>
// –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∏ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è –∏–≥—Ä—ã
const CONFIG = {
  worldSize: 80,
  playerSpeed: 0.08,
  playerRadius: 0.6,
  sfxVol: 0.8,
  sensitivity: 1.0
};

let state = {
  running: false, paused: false, wave: 0, score: 0, enemies: [], drops: [],
  ammo: [12, 30, 8], reserve: [60, 180, 24], currentWeapon: 0, playerHP: 100, totalKilled: 0,
  lastSpawnTime: 0, enemiesToSpawn: 0, gameStartTime: 0
};

// DOM elements
const menu = document.getElementById('menu');
const gameContainer = document.getElementById('gameContainer');
const gameUI = document.getElementById('gameUI');
const modalSettings = document.getElementById('modalSettings');
const modalHelp = document.getElementById('modalHelp');
const results = document.getElementById('results');
const resultsText = document.getElementById('resultsText');

// Three.js variables
let scene, camera, renderer, clock;
let playerPos = new THREE.Vector3(0, 1.6, 0);
let playerVel = new THREE.Vector3();
let obstacles = [];
let animationFrameId = null;

// Simple sound system
class SoundManager {
  constructor() {
    this.sounds = {};
    this.init();
  }

  init() {
    // –ü—Ä–æ—Å—Ç–∞—è —Å–∏—Å—Ç–µ–º–∞ –∑–≤—É–∫–æ–≤ —á–µ—Ä–µ–∑ Web Audio API
    this.context = new (window.AudioContext || window.webkitAudioContext)();
  }

  playShoot() {
    this.playSound(800, 0.1);
  }

  playHit() {
    this.playSound(300, 0.2);
  }

  playSound(frequency, duration) {
    if (CONFIG.sfxVol === 0) return;
    
    try {
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.value = frequency;
      gainNode.gain.value = 0.1 * CONFIG.sfxVol;
      
      oscillator.start();
      oscillator.stop(this.context.currentTime + duration);
    } catch (e) {
      console.log("Sound error:", e);
    }
  }
}

const soundManager = new SoundManager();

// Utility
function $(id) { return document.getElementById(id); }

// UI Setup
function setupUI() {
  $('startButton').addEventListener('click', startGame);
  $('settingsButton').addEventListener('click', () => modalSettings.classList.add('show'));
  $('closeSettings').addEventListener('click', () => modalSettings.classList.remove('show'));
  $('helpButton').addEventListener('click', () => modalHelp.classList.add('show'));
  $('closeHelp').addEventListener('click', () => modalHelp.classList.remove('show'));

  $('shootBtn').addEventListener('click', fire);
  $('skillBtn').addEventListener('click', useSkill);
  $('reloadBtn').addEventListener('click', reload);

  document.querySelectorAll('.wbtn').forEach(b => {
    b.addEventListener('click', () => switchWeapon(parseInt(b.dataset.w)));
  });

  $('resultsToMenu').addEventListener('click', () => {
    results.style.display = 'none';
    menu.style.display = 'flex';
    cleanupGame();
  });

  $('restartButton').addEventListener('click', () => {
    results.style.display = 'none';
    startGame();
  });

  $('sfxVol').addEventListener('input', (e) => CONFIG.sfxVol = parseFloat(e.target.value));
  $('sens').addEventListener('input', (e) => CONFIG.sensitivity = parseFloat(e.target.value));
}

// Game functions
function startGame() {
  menu.style.display = 'none';
  gameUI.style.pointerEvents = 'auto';
  gameContainer.style.pointerEvents = 'auto';
  
  state.running = true;
  state.paused = false;
  state.wave = 0;
  state.score = 0;
  state.enemies = [];
  state.drops = [];
  state.playerHP = 100;
  state.totalKilled = 0;
  state.ammo = [12, 30, 8];
  state.reserve = [60, 180, 24];
  state.currentWeapon = 0;
  state.gameStartTime = performance.now();

  initThree();
  updateHUD();
  highlightWeapon(0);
  nextWave();
  runLoop();
}

function cleanupGame() {
  state.running = false;
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  if (renderer) {
    gameContainer.innerHTML = '';
    renderer = null;
    scene = null;
    camera = null;
  }
  obstacles = [];
  playerVel.set(0, 0, 0);
}

function initThree() {
  cleanupGame();

  // Scene
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0f1a);
  clock = new THREE.Clock();

  // Camera
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.copy(playerPos);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  gameContainer.appendChild(renderer.domElement);

  // Lighting - –£–í–ï–õ–ò–ß–ï–ù–ù–ê–Ø –ò–ù–¢–ï–ù–°–ò–í–ù–û–°–¢–¨ –û–°–í–ï–©–ï–ù–ò–Ø
  const ambientLight = new THREE.AmbientLight(0xffffff, 1.0); // –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 0.6 –¥–æ 1.0
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // –£–≤–µ–ª–∏—á–µ–Ω–æ —Å 0.9 –¥–æ 1.0
  directionalLight.position.set(50, 50, 50);
  directionalLight.castShadow = true;
  scene.add(directionalLight);

  // Ground - –°–î–ï–õ–ê–ù–ê –ë–û–õ–ï–ï –Ø–†–ö–û–ô
  const groundGeometry = new THREE.PlaneGeometry(CONFIG.worldSize * 2, CONFIG.worldSize * 2);
  const groundMaterial = new THREE.MeshStandardMaterial({ 
    color: 0x2a3b4c,
    roughness: 0.7,
    metalness: 0.1
  });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // Grid helper for better visibility
  const gridHelper = new THREE.GridHelper(CONFIG.worldSize * 2, 20, 0x444444, 0x222222);
  gridHelper.position.y = 0.01;
  scene.add(gridHelper);

  // Simple test objects to verify rendering
  const testBox = new THREE.Mesh(
    new THREE.BoxGeometry(2, 2, 2),
    new THREE.MeshStandardMaterial({ color: 0xff0000 })
  );
  testBox.position.set(5, 1, 5);
  scene.add(testBox);

  const testSphere = new THREE.Mesh(
    new THREE.SphereGeometry(1, 16, 16),
    new THREE.MeshStandardMaterial({ color: 0x00ff00 })
  );
  testSphere.position.set(-5, 1, 5);
  scene.add(testSphere);

  createEnvironment();

  window.addEventListener('resize', onResize);
}

function createEnvironment() {
  // Create some simple obstacles
  const boxGeometry = new THREE.BoxGeometry(4, 3, 4);
  const boxMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  
  for (let i = 0; i < 8; i++) {
    const box = new THREE.Mesh(boxGeometry, boxMaterial);
    const angle = (i / 8) * Math.PI * 2;
    const radius = 15 + Math.random() * 20;
    box.position.set(
      Math.cos(angle) * radius,
      1.5,
      Math.sin(angle) * radius
    );
    box.castShadow = true;
    scene.add(box);
    obstacles.push(new THREE.Box3().setFromObject(box));
  }
}

const WEAPONS = [
  { name: '–ü–∏—Å—Ç–æ–ª–µ—Ç', dmg: 25, rpm: 300, mag: 12, range: 50 },
  { name: '–ê–≤—Ç–æ–º–∞—Ç', dmg: 15, rpm: 600, mag: 30, range: 60 },
  { name: '–î—Ä–æ–±–æ–≤–∏–∫', dmg: 40, rpm: 150, mag: 8, range: 25 }
];

let lastShot = 0;

function fire() {
  if (!state.running || state.paused) return;
  
  const w = WEAPONS[state.currentWeapon];
  const now = performance.now();
  
  if (now - lastShot < 60000 / w.rpm) return;
  if (state.ammo[state.currentWeapon] <= 0) return;
  
  state.ammo[state.currentWeapon]--;
  lastShot = now;
  soundManager.playShoot();
  
  // Simple enemy hit detection
  for (const enemy of state.enemies) {
    const distance = enemy.mesh.position.distanceTo(camera.position);
    if (distance < w.range && Math.random() > 0.5) {
      enemy.userData.hp -= w.dmg;
      if (enemy.userData.hp <= 0) {
        killEnemy(enemy);
      } else {
        state.score += 5;
        soundManager.playHit();
      }
      break;
    }
  }
  
  updateHUD();
}

function killEnemy(enemy) {
  state.score += 20;
  state.totalKilled++;
  scene.remove(enemy.mesh);
  state.enemies = state.enemies.filter(e => e !== enemy);
  updateHUD();
}

function spawnEnemy() {
  const geometry = new THREE.ConeGeometry(0.5, 2, 8);
  const material = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
  const mesh = new THREE.Mesh(geometry, material);
  
  const angle = Math.random() * Math.PI * 2;
  const distance = 10 + Math.random() * 15;
  mesh.position.set(
    Math.cos(angle) * distance,
    1,
    Math.sin(angle) * distance
  );
  
  mesh.userData = {
    hp: 50,
    speed: 0.03
  };
  
  scene.add(mesh);
  state.enemies.push({ mesh, userData: mesh.userData });
}

function updateEnemies(dt) {
  for (const enemy of state.enemies) {
    const direction = new THREE.Vector3()
      .subVectors(camera.position, enemy.mesh.position)
      .normalize();
    
    enemy.mesh.position.addScaledVector(direction, enemy.userData.speed);
    enemy.mesh.lookAt(camera.position);
    
    // Check if enemy is too close
    if (enemy.mesh.position.distanceTo(camera.position) < 2) {
      damagePlayer(10);
    }
  }
}

function damagePlayer(amount) {
  state.playerHP = Math.max(0, state.playerHP - amount);
  if (state.playerHP <= 0) {
    endGame();
  }
  updateHUD();
}

function nextWave() {
  state.wave++;
  state.enemiesToSpawn = 3 + state.wave * 2;
  updateHUD();
}

function updateHUD() {
  $('healthFill').style.width = state.playerHP + '%';
  $('hpTxt').textContent = Math.round(state.playerHP);
  $('ammoTxt').textContent = `${state.ammo[state.currentWeapon]}/${state.reserve[state.currentWeapon]}`;
  $('waveTxt').textContent = state.wave;
}

function switchWeapon(index) {
  state.currentWeapon = index;
  highlightWeapon(index);
  updateHUD();
}

function highlightWeapon(index) {
  document.querySelectorAll('.wbtn').forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
}

function reload() {
  const w = WEAPONS[state.currentWeapon];
  const needed = w.mag - state.ammo[state.currentWeapon];
  const canTake = Math.min(needed, state.reserve[state.currentWeapon]);
  
  if (canTake > 0) {
    state.ammo[state.currentWeapon] += canTake;
    state.reserve[state.currentWeapon] -= canTake;
    updateHUD();
  }
}

function useSkill() {
  // Push back all enemies
  for (const enemy of state.enemies) {
    const direction = new THREE.Vector3()
      .subVectors(enemy.mesh.position, camera.position)
      .normalize();
    enemy.mesh.position.addScaledVector(direction, 3);
  }
}

function runLoop() {
  if (!state.running) return;
  
  animationFrameId = requestAnimationFrame(runLoop);
  const dt = clock.getDelta();
  
  // Player movement
  if (playerVel.length() > 0) {
    const newPos = playerPos.clone().add(playerVel);
    playerPos.copy(newPos);
    camera.position.copy(playerPos);
  }
  
  // Enemy spawning
  if (state.enemiesToSpawn > 0 && state.enemies.length < 10) {
    if (Math.random() < 0.1) {
      spawnEnemy();
      state.enemiesToSpawn--;
    }
  }
  
  // Next wave check
  if (state.enemies.length === 0 && state.enemiesToSpawn === 0) {
    nextWave();
  }
  
  updateEnemies(dt);
  
  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

function endGame() {
  state.running = false;
  cancelAnimationFrame(animationFrameId);
  
  const gameTime = Math.floor((performance.now() - state.gameStartTime) / 1000);
  const level = Math.floor(state.wave / 3) + 1;
  
  resultsText.innerHTML = `
    <div style="margin:10px 0;">‚≠ê –û—á–∫–∏: ${state.score}</div>
    <div style="margin:10px 0;">üéØ –£–±–∏–π—Å—Ç–≤: ${state.totalKilled}</div>
    <div style="margin:10px 0;">üåä –í–æ–ª–Ω –ø—Ä–æ–π–¥–µ–Ω–æ: ${state.wave}</div>
    <div style="margin:10px 0;">‚è±Ô∏è –í—Ä–µ–º—è –≤—ã–∂–∏–≤–∞–Ω–∏—è: ${gameTime} —Å–µ–∫</div>
    <div style="margin:10px 0;">üéØ –£—Ä–æ–≤–µ–Ω—å: ${level}</div>
  `;
  
  results.style.display = 'flex';
  
  // Send to Telegram
  try {
    if (window.Telegram && Telegram.WebApp) {
      Telegram.WebApp.sendData(JSON.stringify({
        score: state.score,
        kills: state.totalKilled,
        wave: state.wave,
        time: gameTime,
        level: level
      }));
    }
  } catch (e) {
    console.log("Telegram not available");
  }
}

// Input handling
let keys = {};
window.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (e.code === 'Space') fire();
  if (e.code === 'Digit1') switchWeapon(0);
  if (e.code === 'Digit2') switchWeapon(1);
  if (e.code === 'Digit3') switchWeapon(2);
  if (e.code === 'KeyR') reload();
});

window.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

// Movement
function updateMovement() {
  playerVel.set(0, 0, 0);
  
  if (keys['KeyW'] || keys['ArrowUp']) playerVel.z -= CONFIG.playerSpeed;
  if (keys['KeyS'] || keys['ArrowDown']) playerVel.z += CONFIG.playerSpeed;
  if (keys['KeyA'] || keys['ArrowLeft']) playerVel.x -= CONFIG.playerSpeed;
  if (keys['KeyD'] || keys['ArrowRight']) playerVel.x += CONFIG.playerSpeed;
  
  // Rotate movement vector by camera rotation
  playerVel.applyEuler(new THREE.Euler(0, camera.rotation.y, 0));
}

// Mouse look
let mouseDown = false;
window.addEventListener('mousedown', () => mouseDown = true);
window.addEventListener('mouseup', () => mouseDown = false);
window.addEventListener('mousemove', (e) => {
  if (mouseDown && state.running) {
    camera.rotation.y -= e.movementX * 0.002 * CONFIG.sensitivity;
    camera.rotation.x = THREE.MathUtils.clamp(
      camera.rotation.x - e.movementY * 0.002 * CONFIG.sensitivity,
      -Math.PI / 2,
      Math.PI / 2
    );
  }
});

function onResize() {
  if (camera && renderer) {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
}

// Initialize
window.addEventListener('load', () => {
  gameContainer.style.pointerEvents = 'none';
  gameUI.style.pointerEvents = 'none';
  
  setupUI();
  
  // Mobile joystick setup
  if (window.innerWidth < 900) {
    $('joystick').style.display = 'flex';
  }
  
  console.log("Z.E.R.O. Game Ready");
  
  try {
    if (window.Telegram && Telegram.WebApp) {
      Telegram.WebApp.ready();
      Telegram.WebApp.expand();
    }
  } catch (e) {
    console.log("Running in browser mode");
  }
  
  // Start movement update loop
  setInterval(updateMovement, 16);
});
</script>
</body>
</html>
