<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>Z.E.R.O. ‚Äî UNIFIED PLANET SYSTEM</title>
  <!-- Three.js r128 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Postprocessing -->
  <script src="https://threejs.org/examples/js/postprocessing/EffectComposer.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/RenderPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/UnrealBloomPass.js"></script>
  <script src="https://threejs.org/examples/js/postprocessing/ShaderPass.js"></script>
  <script src="https://threejs.org/examples/js/shaders/CopyShader.js"></script>
  <script src="https://threejs.org/examples/js/shaders/GammaCorrectionShader.js"></script>
  <style>
    :root {
      --neon: #00ffff;
      --bg: #04111b;
      --glass: rgba(0, 0, 0, 0.45);
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: Inter, "Courier New", monospace;
      color: var(--neon);
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
    }
    #gameContainer {
      position: fixed;
      inset: 0;
      z-index: 0;
    }
    #ui {
      position: fixed;
      inset: 0;
      z-index: 10;
      pointer-events: none;
    }
    .overlayCenter {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      pointer-events: auto;
    }
    .menuCard {
      background: linear-gradient(135deg, rgba(0,8,18,0.85), rgba(0,6,12,0.6));
      padding: 18px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,255,0.06);
      box-shadow: 0 10px 40px rgba(0,255,255,0.03);
    }
    .title {
      font-size: 1.6rem;
      color: var(--neon);
      text-align: center;
      margin-bottom: 8px;
      text-shadow: 0 0 14px rgba(0,255,255,0.18);
    }
    .btn {
      pointer-events: auto;
      background: transparent;
      border: 1px solid rgba(0,255,255,0.12);
      padding: 10px 14px;
      color: var(--neon);
      border-radius: 10px;
      margin: 6px;
      cursor: pointer;
    }
    .hud {
      position: fixed;
      left: 10px;
      top: 10px;
      pointer-events: auto;
      background: var(--glass);
      padding: 8px;
      border-radius: 8px;
      border: 1px solid rgba(0,255,255,0.06);
    }
    .hudRow {
      font-size: 14px;
      margin-bottom: 6px;
    }
    /* Space Controls */
    #spaceControls {
      position: fixed;
      bottom: 12px;
      left: 12px;
      pointer-events: auto;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .joyPad {
      width: 110px;
      height: 110px;
      border-radius: 999px;
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.03);
      touch-action: none;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .joyKnob {
      width: 42px;
      height: 42px;
      border-radius: 999px;
      background: rgba(0,255,255,0.06);
      border: 1px solid rgba(0,255,255,0.12);
    }
    .spaceActionButtons {
      position: fixed;
      right: 12px;
      bottom: 36px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: auto;
    }
    .actionBtn {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      background: rgba(0,255,255,0.04);
      border: 1px solid rgba(0,255,255,0.08);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 22px;
      color: var(--neon);
    }
    /* Surface Controls */
    #surfaceControls {
      position: fixed;
      bottom: 12px;
      left: 12px;
      pointer-events: auto;
      display: none;
      gap: 10px;
      align-items: center;
    }
    #surfaceJoy {
      width: 120px;
      height: 120px;
      border-radius: 60px;
      background: rgba(0,0,0,0.25);
      pointer-events: auto;
      touch-action: none;
      position: relative;
    }
    #surfaceKnob {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 22px;
      background: rgba(0,255,255,0.12);
      left: 38px;
      top: 38px;
      border: 1px solid rgba(0,255,255,0.08);
    }
    .surfaceActionButtons {
      position: fixed;
      right: 12px;
      bottom: 36px;
      display: none;
      flex-direction: column;
      gap: 12px;
      pointer-events: auto;
    }
    #damageFlash {
      position: fixed;
      inset: 0;
      background: #ff2b2b;
      opacity: 0;
      pointer-events: none;
      mix-blend-mode: screen;
      transition: opacity 120ms;
    }
    .bottomHints {
      position: fixed;
      left: 12px;
      bottom: 12px;
      font-size: 12px;
      opacity: 0.9;
      padding: 8px;
      background: var(--glass);
      border-radius: 8px;
      border: 1px solid rgba(0,255,255,0.04);
      pointer-events: auto;
    }
    .planetUI {
      position: fixed;
      inset: 10% 8% 10% 8%;
      background: linear-gradient(180deg, rgba(0,6,18,0.96), rgba(0,4,10,0.88));
      border-radius: 12px;
      padding: 14px;
      border: 1px solid rgba(0,255,255,0.06);
      display: none;
      z-index: 20;
      pointer-events: auto;
      color: #9ff;
    }
    .dialogue {
      background: rgba(0,10,20,0.6);
      padding: 10px;
      border-radius: 8px;
      margin: 10px 0;
      border: 1px solid rgba(0,255,255,0.04);
    }
    .npc {
      display: flex;
      gap: 8px;
      align-items: center;
      margin: 8px 0;
    }
    .npc .face {
      width: 44px;
      height: 44px;
      border-radius: 8px;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(0,255,255,0.05);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
    }
    .shopGrid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-top: 10px;
    }
    .shopItem {
      background: rgba(0,0,0,0.45);
      padding: 10px;
      border-radius: 8px;
      border: 1px solid rgba(0,255,255,0.06);
      text-align: center;
    }
    .small {
      font-size: 13px;
      color: #9ff;
      opacity: 0.9;
    }
    .scanlines {
      position: fixed;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(to bottom, rgba(255,255,255,0) 0px, rgba(255,255,255,0.02) 2px, rgba(255,255,255,0) 3px);
      opacity: 0.18;
      mix-blend-mode: overlay;
    }
    .landingIndicator {
      position: fixed;
      left: 50%;
      bottom: 80px;
      transform: translateX(-50%);
      background: rgba(0, 40, 60, 0.8);
      padding: 12px 20px;
      border-radius: 20px;
      border: 1px solid rgba(0,255,255,0.2);
      font-size: 16px;
      color: #00ffff;
      transition: all 0.3s ease;
      opacity: 0;
      pointer-events: none;
    }
    .landingIndicator.active {
      opacity: 1;
      transform: translateX(-50%) scale(1.05);
    }
    @media (max-width:420px) {
      .joyPad, #surfaceJoy { width: 90px; height: 90px; }
      .joyKnob, #surfaceKnob { width: 36px; height: 36px; }
      .actionBtn { width: 56px; height: 56px; }
      .title { font-size: 1.2rem; }
      .landingIndicator {
        font-size: 14px;
        padding: 8px 16px;
        bottom: 60px;
      }
    }
  </style>
</head>
<body>
  <div id="gameContainer"></div>
  <div id="ui">
    <div class="scanlines"></div>
    <div id="menu" class="overlayCenter menuCard">
      <div class="title">Z.E.R.O.: UNIFIED PLANET SYSTEM</div>
      <div style="text-align:center;color:#9fe;margin-bottom:8px;font-size:13px">–ö–æ—Å–º–∏—á–µ—Å–∫–∏–µ –ø–æ–ª–µ—Ç—ã ‚Ä¢ –•–æ–¥—å–±–∞ –ø–æ –ø–ª–∞–Ω–µ—Ç–∞–º ‚Ä¢ –£–ª—É—á—à–µ–Ω–Ω—ã–π –≥–µ–π–º–ø–ª–µ–π</div>
      <div style="display:flex;justify-content:center;gap:8px">
        <button id="btnStart" class="btn">–°–¢–ê–†–¢</button>
        <button id="btnHow" class="btn">–ö–ê–ö –ò–ì–†–ê–¢–¨</button>
      </div>
      <div style="margin-top:10px;text-align:center;font-size:13px;color:#9aa">–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥—É–ª–µ–π... <span id="loadingDots">‚óè‚óè‚óè</span></div>
    </div>
    <div id="hud" class="hud">
      <div class="hudRow">‚ù§Ô∏è <span id="uiHealth">100</span>  ¬∑  üõ° <span id="uiShield">100</span>  ¬∑  ‚õΩ <span id="uiFuel">100</span></div>
      <div class="hudRow">üí≥ <span id="uiCredits">0</span>  ¬∑  ‚≠ê <span id="uiStars">0</span>  ¬∑  üéØ <span id="uiMission">0/5</span></div>
    </div>
    <!-- Space Controls -->
    <div id="spaceControls">
      <div id="spaceJoy" class="joyPad"><div id="spaceKnob" class="joyKnob"></div></div>
      <div class="bottomHints">–î–∂–æ–π—Å—Ç–∏–∫ ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ ‚Ä¢ –¢–∞–ø –ø–æ –ø–ª–∞–Ω–µ—Ç–µ ‚Äî –ø—Ä–∏–∑–µ–º–ª–∏—Ç—å—Å—è</div>
    </div>
    <div class="spaceActionButtons">
      <div id="btnShield" class="actionBtn" title="–©–∏—Ç">üõ°</div>
      <div id="btnShoot" class="actionBtn" title="–û–≥–æ–Ω—å">üí•</div>
      <div id="btnBoost" class="actionBtn" title="–û–≤–µ—Ä–¥—Ä–∞–π–≤">‚ö°</div>
    </div>
    <!-- Surface Controls -->
    <div id="surfaceControls">
      <div id="surfaceJoy"><div id="surfaceKnob"></div></div>
      <div class="bottomHints">–î–∂–æ–π—Å—Ç–∏–∫ ‚Äî —Ö–æ–¥—å–±–∞ ‚Ä¢ –ò—Å—Å–ª–µ–¥—É–π –ø–ª–∞–Ω–µ—Ç—É</div>
    </div>
    <div class="surfaceActionButtons">
      <div id="btnInteract" class="actionBtn" title="–í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ">üëÅÔ∏è</div>
      <div id="btnTakeoff" class="actionBtn" title="–í–∑–ª–µ—Ç–µ—Ç—å">üöÄ</div>
    </div>
    <div id="damageFlash"></div>
    <div id="landingIndicator" class="landingIndicator">–ü–†–ò–ë–õ–ò–ñ–ï–ù–ò–ï –ö –ü–õ–ê–ù–ï–¢–ï - –ù–ê–ñ–ú–ò–¢–ï –î–õ–Ø –ü–û–°–ê–î–ö–ò</div>
    <!-- Planet UI -->
    <div id="planetPanel" class="planetUI">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong id="planetName">PLANET</strong><div class="small" id="planetDesc">–û–ø–∏—Å–∞–Ω–∏–µ</div></div>
        <div><button id="btnClosePanel" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
      </div>
      <div class="dialogue" id="npcDialogue">–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –Ω–∞ –ø–ª–∞–Ω–µ—Ç—É. –ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?</div>
      <div style="margin-top:8px"><strong>–¢–æ—Ä–≥–æ–≤—Ü—ã –Ω–∞ —ç—Ç–æ–π –ø–ª–∞–Ω–µ—Ç–µ:</strong></div>
      <div id="npcList" style="margin-top:8px"></div>
      <div class="shopGrid" id="shopGrid">
        <!-- Shop items will be populated here -->
      </div>
    </div>
  </div>
<script>
/* ========= Z.E.R.O. ‚Äî UNIFIED PLANET SYSTEM =========
   –ü–æ–ª–Ω–æ—Å—Ç—å—é –ø–µ—Ä–µ—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º–∏ –ø–æ—Å–∞–¥–∫–∞–º–∏
   –∏ —É–ª—É—á—à–µ–Ω–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–æ–π
*/
// ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
function easeOutCubic(t) {
  return 1 - Math.pow(1 - t, 3);
}

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

function distanceTo(x1, y1, z1, x2, y2, z2) {
  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2));
}

// ========== GLOBAL GAME STATE ==========
const STATE = {
  mode: 'menu', // 'menu'|'space'|'landing'|'surface'
  credits: 0,
  health: 100,
  shield: 100,
  fuel: 100,
  stars: 0,
  missionProgress: 0,
  upgrades: { weapon:1, engine:1, shield:1 },
  canShoot: true,
  lastShot: 0,
  overdrive: false,
  shieldActive: false,
  currentPlanet: null,
  debugMode: false
};

// ========== THREE.js scene setup ==========
let scene, camera, renderer, composer;
let shipGroup, shipEngineParticles;
let stars, nebulas = [];
let asteroids = [], enemies = [], bullets = [], planets = [];
let surfaceScene = null, surfacePlayer = null, surfaceObjects = [];
let clock = new THREE.Clock();
let pixelRatio = Math.min(window.devicePixelRatio || 1, 1.6);
let hasComposer = false;
let debugText = null;
let raycaster = new THREE.Raycaster();

// Control states
let spaceJoystick = { x: 0, y: 0 };
let surfaceJoystick = { x: 0, y: 0, active: false };

// Landing animation state
let landingAnimation = {
  active: false,
  startPos: new THREE.Vector3(),
  targetPos: new THREE.Vector3(),
  progress: 0,
  duration: 2000,
  startTime: 0
};

// Physics constants
const GRAVITY = 9.8;
const GROUND_LEVEL = -2;
const PLAYER_HEIGHT = 2.5;

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø THREE.js ==========
function initThree(){
  try {
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x03121a, 3000, 8000);
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 10000);
    camera.position.set(0,6,22);
    
    renderer = new THREE.WebGLRenderer({ antialias:true, alpha: true });
    renderer.setPixelRatio(pixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x03121a, 1);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    const gameContainer = document.getElementById('gameContainer');
    if (gameContainer) {
      gameContainer.appendChild(renderer.domElement);
    } else {
      document.body.appendChild(renderer.domElement);
    }
    
    // Postprocessing
    try {
      composer = new THREE.EffectComposer(renderer);
      const renderPass = new THREE.RenderPass(scene, camera);
      composer.addPass(renderPass);
      
      const bloom = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.2, 0.6);
      bloom.threshold = 0.12; 
      bloom.strength = 0.9; 
      bloom.radius = 0.4;
      composer.addPass(bloom);
      
      const gamma = new THREE.ShaderPass(THREE.GammaCorrectionShader);
      composer.addPass(gamma);
      
      hasComposer = true;
    } catch(e) {
      hasComposer = false;
      console.warn('Postprocessing not available:', e);
    }
    
    console.log('Three.js initialized successfully');
    return true;
  } catch(e) {
    console.error('Error initializing Three.js:', e);
    return false;
  }
}

// ========== –û–°–í–ï–©–ï–ù–ò–ï ==========
function makeLights(){
  try {
    const amb = new THREE.AmbientLight(0x8aaaff, 0.9);
    scene.add(amb);
    
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(30, 40, 10);
    dir.castShadow = true;
    dir.shadow.mapSize.width = 1024;
    dir.shadow.mapSize.height = 1024;
    scene.add(dir);
    
    const rim = new THREE.DirectionalLight(0x66bbff, 0.5);
    rim.position.set(-20, -10, -30);
    scene.add(rim);
    
    console.log('Lights created');
    return true;
  } catch(e) {
    console.error('Error creating lights:', e);
    return false;
  }
}

// ========== –°–û–ó–î–ê–ù–ò–ï –ö–û–†–ê–ë–õ–Ø ==========
function createShip(){
  try {
    shipGroup = new THREE.Group();
    
    // –ö–æ—Ä–ø—É—Å –∫–æ—Ä–∞–±–ª—è
    const hullGeom = new THREE.ConeGeometry(2.2, 7, 6);
    const hullMat = new THREE.MeshStandardMaterial({ 
      color: 0x00aaff, 
      metalness: 0.4, 
      roughness: 0.25, 
      emissive: 0x002244, 
      emissiveIntensity: 0.9,
      side: THREE.DoubleSide
    });
    const hull = new THREE.Mesh(hullGeom, hullMat);
    hull.rotation.x = Math.PI/2;
    hull.castShadow = true;
    shipGroup.add(hull);
    
    // –ö—Ä—ã–ª—å—è
    const wingGeom = new THREE.BoxGeometry(6.5, 0.6, 2.6);
    const wingMat = new THREE.MeshStandardMaterial({ 
      color: 0x006ea8, 
      metalness: 0.25, 
      roughness: 0.35, 
      emissive: 0x001122,
      side: THREE.DoubleSide
    });
    
    const lw = new THREE.Mesh(wingGeom, wingMat);
    lw.position.set(-4.5, 0, 0);
    lw.castShadow = true;
    shipGroup.add(lw);
    
    const rw = lw.clone();
    rw.position.set(4.5, 0, 0);
    shipGroup.add(rw);
    
    // –•–≤–æ—Å—Ç–æ–≤–æ–µ –æ–ø–µ—Ä–µ–Ω–∏–µ
    const tailGeom = new THREE.ConeGeometry(1.0, 4, 8);
    const tailMat = new THREE.MeshStandardMaterial({ 
      color: 0x005577, 
      metalness: 0.3, 
      roughness: 0.4,
      side: THREE.DoubleSide
    });
    const tail = new THREE.Mesh(tailGeom, tailMat);
    tail.rotation.x = Math.PI/2;
    tail.position.set(0, 0, -4);
    shipGroup.add(tail);
    
    shipGroup.position.set(0, 0, 15);
    scene.add(shipGroup);
    
    // –ß–∞—Å—Ç–∏—Ü—ã –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π
    const maxP = 80;
    const pos = new Float32Array(maxP * 3);
    const cols = new Float32Array(maxP * 3);
    
    for(let i = 0; i < maxP; i++){ 
      const j = i * 3; 
      pos[j] = (Math.random() - 0.5) * 1.6; 
      pos[j+1] = (Math.random() - 0.5) * 1.6; 
      pos[j+2] = 2 + Math.random() * 4; 
      
      cols[j] = 1; 
      cols[j+1] = 0.45 + Math.random() * 0.45; 
      cols[j+2] = 0; 
    }
    
    const pGeom = new THREE.BufferGeometry(); 
    pGeom.setAttribute('position', new THREE.BufferAttribute(pos, 3)); 
    pGeom.setAttribute('color', new THREE.BufferAttribute(cols, 3));
    
    const pMat = new THREE.PointsMaterial({ 
      size: 2.2, 
      vertexColors: true, 
      transparent: true, 
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const pSys = new THREE.Points(pGeom, pMat);
    pSys.frustumCulled = false;
    shipGroup.add(pSys);
    shipEngineParticles = { points: pSys, geom: pGeom };
    
    console.log('Ship created');
    return true;
  } catch(e) {
    console.error('Error creating ship:', e);
    return false;
  }
}

// ========== –ó–í–ï–ó–î–ù–û–ï –ü–û–õ–ï –ò –¢–£–ú–ê–ù–ù–û–°–¢–ò ==========
function createStarfield(){
  try {
    const count = 2400;
    const pos = new Float32Array(count * 3);
    const cols = new Float32Array(count * 3);
    
    for(let i = 0; i < count; i++){ 
      const j = i * 3; 
      pos[j] = (Math.random() - 0.5) * 4000; 
      pos[j+1] = (Math.random() - 0.5) * 2000; 
      pos[j+2] = (Math.random() - 0.5) * 6000 - 1000; 
      
      const c = Math.random(); 
      if(c < 0.7){ 
        cols[j] = 1; cols[j+1] = 1; cols[j+2] = 1; 
      } else if(c < 0.9){ 
        cols[j] = 0.8; cols[j+1] = 0.9; cols[j+2] = 1; 
      } else { 
        cols[j] = 1; cols[j+1] = 0.9; cols[j+2] = 0.6; 
      } 
    }
    
    const geom = new THREE.BufferGeometry(); 
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3)); 
    geom.setAttribute('color', new THREE.BufferAttribute(cols, 3));
    
    const mat = new THREE.PointsMaterial({ 
      vertexColors: true, 
      size: 1.9, 
      transparent: true, 
      blending: THREE.AdditiveBlending, 
      opacity: 0.95,
      depthWrite: false
    });
    
    stars = new THREE.Points(geom, mat);
    stars.frustumCulled = false;
    scene.add(stars);
    
    // –¢—É–º–∞–Ω–Ω–æ—Å—Ç–∏
    for(let i = 0; i < 3; i++){
      const g = new THREE.SphereGeometry(300 + Math.random() * 260, 32, 32);
      const mat = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color().setHSL(Math.random(), 0.6, 0.45), 
        transparent: true, 
        opacity: 0.06, 
        side: THREE.BackSide, 
        depthWrite: false 
      });
      
      const m = new THREE.Mesh(g, mat); 
      m.position.set(
        (Math.random() - 0.5) * 2000,
        (Math.random() - 0.5) * 1200,
        (Math.random() - 0.5) * 3000 - 800
      );
      m.frustumCulled = false;
      scene.add(m); 
      nebulas.push(m);
    }
    
    console.log('Starfield created');
    return true;
  } catch(e) {
    console.error('Error creating starfield:', e);
    return false;
  }
}

// ========== –ü–õ–ê–ù–ï–¢–´ ==========
function generateSpacePlanets(){
  try {
    const pdata = [
      {name: '–ö–†–ò–û–ù–ò–°', color: 0x88ccff, size: 20, desc: '–õ–µ–¥—è–Ω–æ–π –º–∏—Ä —Å –∫—Ä–∏—Å—Ç–∞–ª—å–Ω—ã–º–∏ –ø–µ—â–µ—Ä–∞–º–∏'},
      {name: '–ü–ò–†–û–°', color: 0xff6633, size: 24, desc: '–í—É–ª–∫–∞–Ω–∏—á–µ—Å–∫–∏–π –º–∏—Ä –æ–≥–Ω–µ–Ω–Ω—ã—Ö —Ä–µ–∫'},
      {name: '–í–ï–†–î–ê–ù–¢', color: 0x44ff88, size: 18, desc: '–ë–∏–æ–ª—é–º–∏–Ω–µ—Å—Ü–µ–Ω—Ç–Ω—ã–µ –ª–µ—Å–∞'},
      // –î–∞–ª—å–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç—ã
      {name: '–ê–£–†–ï–õ–ò–Ø', color: 0xffaa88, size: 22, desc: '–ü—É—Å—Ç—ã–Ω–Ω—ã–π –º–∏—Ä —Å –∑–æ–ª–æ—Ç—ã–º–∏ –ø–µ—Å–∫–∞–º–∏'},
      {name: '–¢–ï–ö–¢–û–ù–ò–ö–ê', color: 0xaa66aa, size: 26, desc: '–ü–ª–∞–Ω–µ—Ç–∞ —Å –≥–∏–≥–∞–Ω—Ç—Å–∫–∏–º–∏ –∫–∞–Ω—å–æ–Ω–∞–º–∏'},
      {name: '–ù–ï–ë–£–õ–ê', color: 0x66aaff, size: 19, desc: '–ì–∞–∑–æ–≤—ã–π –≥–∏–≥–∞–Ω—Ç —Å –∫–æ–ª—å—Ü–∞–º–∏'},
      {name: '–•–ò–ú–ò–†–ê', color: 0x88ff44, size: 21, desc: '–ü–ª–∞–Ω–µ—Ç–∞ —Å —ç–∫–∑–æ—Ç–∏—á–µ—Å–∫–æ–π —Ñ–ª–æ—Ä–æ–π'},
      {name: '–ú–ê–ì–ù–ï–¢–ê–†', color: 0xff44aa, size: 17, desc: '–ú–∞–≥–Ω–∏—Ç–Ω–∞—è –ø–ª–∞–Ω–µ—Ç–∞ —Å —Å–∏—è—é—â–∏–º–∏ –ø–æ–ª—é—Å–∞–º–∏'},
      {name: '–ö–í–ê–ó–ê–†', color: 0xffff44, size: 23, desc: '–≠–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∞—è –∞–Ω–æ–º–∞–ª–∏—è'},
      {name: '–ì–ê–õ–ê–ö–¢–ò–û–ù', color: 0xaa44ff, size: 28, desc: '–î—Ä–µ–≤–Ω—è—è –ø–ª–∞–Ω–µ—Ç–∞-–∞—Ä—Ç–µ—Ñ–∞–∫—Ç'}
    ];
    
    for(let i = 0; i < pdata.length; i++){
      const p = pdata[i];
      const geom = new THREE.SphereGeometry(p.size, 24, 24);
      const mat = new THREE.MeshStandardMaterial({ 
        color: p.color, 
        emissive: new THREE.Color(p.color).multiplyScalar(0.18), 
        roughness: 0.5,
        metalness: 0.1
      });
      
      const m = new THREE.Mesh(geom, mat); 
      
      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –ø–ª–∞–Ω–µ—Ç—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è—Ö - –æ—Ç –±–ª–∏–∑–∫–∏—Ö –¥–æ –æ—á–µ–Ω—å –¥–∞–ª–µ–∫–∏—Ö
      let zPos;
      if (i < 3) {
        // –ë–ª–∏–∑–∫–∏–µ –ø–ª–∞–Ω–µ—Ç—ã
        zPos = -800 - i * 600;
      } else if (i < 6) {
        // –°—Ä–µ–¥–Ω–µ–π –¥–∞–ª—å–Ω–æ—Å—Ç–∏
        zPos = -2500 - (i-3) * 800;
      } else {
        // –î–∞–ª—å–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç—ã
        zPos = -5000 - (i-6) * 1200;
      }
      
      m.position.set(
        (i % 4 - 1.5) * 180 + (Math.random() - 0.5) * 100, 
        (Math.random() - 0.5) * 80, 
        zPos
      );
      
      m.userData = { 
        name: p.name, 
        desc: p.desc, 
        type: i % 3, // –†–∞—Å–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø—ã —Ü–∏–∫–ª–∏—á–µ—Å–∫–∏
        radius: p.size
      };
      m.castShadow = true;
      scene.add(m); 
      planets.push(m);
    }
    
    console.log('Planets generated:', planets.length);
    return true;
  } catch(e) {
    console.error('Error generating planets:', e);
    return false;
  }
}

// ========== –ü–û–í–ï–†–•–ù–û–°–¢–¨ –ü–õ–ê–ù–ï–¢–´ ==========
function createSurfaceForPlanet(planet){
  try {
    console.log('Creating surface for planet:', planet.userData.name);
    
    // –û—á–∏—â–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
    if(surfaceScene) {
      scene.remove(surfaceScene);
      surfaceObjects = [];
    }
    
    surfaceScene = new THREE.Group();
    
    // –°–æ–∑–¥–∞–µ–º –∑–µ–º–ª—é
    const groundSize = 300;
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(groundSize, groundSize, 32, 32), 
      new THREE.MeshStandardMaterial({ 
        color: 0x0b1b12,
        roughness: 0.8,
        metalness: 0.1,
        side: THREE.DoubleSide
      })
    );
    ground.rotation.x = -Math.PI/2; 
    ground.position.set(0, GROUND_LEVEL, 0);
    ground.receiveShadow = true;
    ground.userData = { name: 'ground', type: 'terrain' };
    surfaceScene.add(ground);
    
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –ø—Ä–∏—Ä–æ–¥–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –ø–ª–∞–Ω–µ—Ç—ã
    const objectCount = 30;
    const colors = [
      [0x4466ff, 0x6688ff],  // –ö—Ä–∏–æ–Ω–∏—Å - —Å–∏–Ω–∏–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã
      [0xffaa33, 0xff6633],  // –ü–∏—Ä–æ–Ω - –æ—Ä–∞–Ω–∂–µ–≤—ã–µ –∫–∞–º–Ω–∏
      [0x88ff88, 0x44ffaa]   // –í–µ—Ä–¥–∞–Ω—Ç - –∑–µ–ª–µ–Ω—ã–µ —Ä–∞—Å—Ç–µ–Ω–∏—è
    ];
    
    const planetType = planet.userData.type;
    const planetColors = colors[planetType];
    
    for(let i = 0; i < objectCount; i++){
      const size = 1 + Math.random() * 4;
      const geom = new THREE.DodecahedronGeometry(size, 1);
      const color = planetColors[Math.floor(Math.random() * planetColors.length)];
      
      const mat = new THREE.MeshStandardMaterial({ 
        color: color,
        roughness: 0.7,
        metalness: 0.2,
        emissive: planetType === 2 ? new THREE.Color(color).multiplyScalar(0.2) : 0x000000,
        emissiveIntensity: 0.5
      });
      
      const obj = new THREE.Mesh(geom, mat);
      obj.position.set(
        (Math.random() - 0.5) * groundSize * 0.8, 
        size/2 + GROUND_LEVEL, 
        (Math.random() - 0.5) * groundSize * 0.8
      );
      obj.castShadow = true;
      obj.receiveShadow = true;
      obj.userData = { name: `object_${i}`, type: 'terrain' };
      surfaceScene.add(obj);
      surfaceObjects.push(obj);
    }
    
    // –°–æ–∑–¥–∞–µ–º NPC
    const npcData = [
      {name: '–¢–æ—Ä–≥–æ–≤–µ—Ü –•–∞–Ω', dialog: '–†–µ–¥–∫–∏–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ø–æ –ª—É—á—à–∏–º —Ü–µ–Ω–∞–º!', type: 'merchant'},
      {name: '–ú–µ—Ö–∞–Ω–∏–∫ –ó–æ—Ä–∏', dialog: '–ß–∏–Ω–∏–º –∫–æ—Ä–∞–±–ª–∏ –ª—é–±–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏', type: 'mechanic'},
      {name: '–£—á–µ–Ω—ã–π –õ–∏—Ä–∞', dialog: '–ò–∑—É—á–∞—é –º–µ—Å—Ç–Ω—É—é —Ñ–∞—É–Ω—É... –æ–ø–∞—Å–Ω—É—é —Ñ–∞—É–Ω—É', type: 'scientist'},
      {name: '–ò–Ω—Ñ–æ—Ä–º–∞—Ç–æ—Ä –ö–µ–π', dialog: '–°–ª—É—Ö–∏ –æ –∑–∞–±—Ä–æ—à–µ–Ω–Ω—ã—Ö —Å—Ç–∞–Ω—Ü–∏—è—Ö...', type: 'informant'}
    ];
    
    npcData.forEach((npc, index) => {
      const npcGroup = new THREE.Group();
      npcGroup.userData = {...npc, interactable: true};
      
      // –¢–µ–ª–æ NPC
      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.8, 2.0, 4, 8),
        new THREE.MeshStandardMaterial({ 
          color: 0x8888ff,
          roughness: 0.7
        })
      );
      body.position.y = 1.0;
      npcGroup.add(body);
      
      // –ì–æ–ª–æ–≤–∞ NPC
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 8, 6),
        new THREE.MeshStandardMaterial({ 
          color: 0xffaa88,
          roughness: 0.5
        })
      );
      head.position.y = 2.3;
      npcGroup.add(head);
      
      // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º NPC –≤–æ–∫—Ä—É–≥ —Ü–µ–Ω—Ç—Ä–∞
      const angle = (index / npcData.length) * Math.PI * 2;
      const radius = 25;
      npcGroup.position.set(
        Math.cos(angle) * radius,
        GROUND_LEVEL + 0.1,
        Math.sin(angle) * radius
      );
      
      npcGroup.lookAt(0, GROUND_LEVEL, 0);
      npcGroup.castShadow = true;
      surfaceScene.add(npcGroup);
      surfaceObjects.push(npcGroup);
    });
    
    // –°–æ–ª–Ω—Ü–µ –¥–ª—è –æ—Å–≤–µ—â–µ–Ω–∏—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
    const sun = new THREE.DirectionalLight(0xffffff, 1.2);
    sun.position.set(100, 200, 100);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 1024;
    sun.shadow.mapSize.height = 1024;
    surfaceScene.add(sun);
    
    scene.add(surfaceScene);
    console.log('Surface created with', surfaceObjects.length, 'objects');
    return surfaceScene;
  } catch(e) {
    console.error('Error creating surface:', e);
    return null;
  }
}

function createSurfacePlayer(){
  try {
    console.log('Creating surface player');
    
    const player = new THREE.Group();
    
    // –¢–µ–ª–æ –∏–≥—Ä–æ–∫–∞
    const body = new THREE.Mesh(
      new THREE.CapsuleGeometry(0.6, 1.5, 4, 8),
      new THREE.MeshStandardMaterial({ 
        color: 0x66ddff,
        emissive: 0x002233,
        roughness: 0.4,
        metalness: 0.3
      })
    );
    body.position.y = 0.75;
    player.add(body);
    
    // –ì–æ–ª–æ–≤–∞ –∏–≥—Ä–æ–∫–∞
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.4, 8, 6),
      new THREE.MeshStandardMaterial({ 
        color: 0xffccaa,
        roughness: 0.6
      })
    );
    head.position.y = 1.6;
    player.add(head);
    
    player.position.set(0, GROUND_LEVEL + PLAYER_HEIGHT, 0);
    player.castShadow = true;
    player.userData = { name: 'player', type: 'character' };
    
    console.log('Surface player created at position:', player.position);
    return player;
  } catch(e) {
    console.error('Error creating surface player:', e);
    return null;
  }
}

// ========== –°–ò–°–¢–ï–ú–ê –û–ë–™–ï–ö–¢–û–í –ö–û–°–ú–û–°–ê ==========
function spawnAsteroid(x, y, z, size = 3){
  try {
    const geom = new THREE.IcosahedronGeometry(size, 1);
    const mat = new THREE.MeshStandardMaterial({ 
      color: 0x9a9a9a, 
      metalness: 0.05, 
      roughness: 0.6,
      emissive: 0x222222,
      emissiveIntensity: 0.2
    });
    
    const m = new THREE.Mesh(geom, mat); 
    m.position.set(x, y, z); 
    m.userData = {
      rot: {
        x: (Math.random() - 0.5) * 0.02,
        y: (Math.random() - 0.5) * 0.02,
        z: (Math.random() - 0.5) * 0.02
      },
      radius: size,
      type: 'asteroid'
    };
    m.castShadow = true;
    scene.add(m); 
    asteroids.push(m);
    return m;
  } catch(e) {
    console.error('Error spawning asteroid:', e);
    return null;
  }
}

function spawnEnemy(x, y, z){
  try {
    const geom = new THREE.OctahedronGeometry(3, 1);
    const mat = new THREE.MeshStandardMaterial({ 
      color: 0xff3355, 
      emissive: 0x550000, 
      metalness: 0.2, 
      roughness: 0.4 
    });
    
    const e = new THREE.Mesh(geom, mat); 
    e.position.set(x, y, z); 
    e.userData = { 
      health: 30, 
      speed: 0.45 + Math.random() * 0.6,
      type: 'enemy'
    };
    e.castShadow = true;
    scene.add(e); 
    enemies.push(e);
    return e;
  } catch(e) {
    console.error('Error spawning enemy:', e);
    return null;
  }
}

function initSpaceObjects(){
  try {
    console.log('Initializing space objects');
    
    for(let i = 0; i < 18; i++){ 
      spawnAsteroid(
        (Math.random() - 0.5) * 600, 
        (Math.random() - 0.5) * 200, 
        -200 - Math.random() * 2000, 
        1.5 + Math.random() * 4
      );
    }
    
    for(let i = 0; i < 8; i++){ 
      spawnEnemy(
        (Math.random() - 0.5) * 400, 
        (Math.random() - 0.5) * 180, 
        -300 - Math.random() * 1200
      );
    }
    
    console.log('Space objects initialized:', asteroids.length, 'asteroids,', enemies.length, 'enemies');
    return true;
  } catch(e) {
    console.error('Error initializing space objects:', e);
    return false;
  }
}

// ========== –°–ò–°–¢–ï–ú–ê –ü–£–õ–¨ ==========
let bulletPool = [];
const POOL = { bullets: 60 };

function initBulletPool(){
  try {
    console.log('Initializing bullet pool');
    
    const geom = new THREE.SphereGeometry(0.45, 6, 6);
    const mat = new THREE.MeshBasicMaterial({ 
      color: 0xffff88,
      emissive: 0xffff88,
      emissiveIntensity: 1.0
    });
    
    for(let i = 0; i < POOL.bullets; i++){ 
      const m = new THREE.Mesh(geom, mat); 
      m.visible = false; 
      m.userData = {
        vel: new THREE.Vector3(), 
        life: 0,
        type: 'bullet'
      }; 
      m.frustumCulled = false;
      scene.add(m); 
      bulletPool.push(m); 
    }
    
    console.log('Bullet pool initialized:', bulletPool.length, 'bullets');
    return true;
  } catch(e) {
    console.error('Error initializing bullet pool:', e);
    return false;
  }
}

function getBullet(){
  for(let i = 0; i < bulletPool.length; i++) {
    if(!bulletPool[i].visible) {
      return bulletPool[i];
    }
  }
  console.warn('Bullet pool exhausted');
  return null;
}

// ========== –ó–í–£–ö–û–í–ê–Ø –°–ò–°–¢–ï–ú–ê ==========
const SFX = (function(){
  let ctx = null;
  let isMuted = false;
  
  function ensure(){ 
    if(!ctx && !isMuted){ 
      try{ 
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        console.log('Audio context created');
      } catch(e){ 
        ctx = null;
        console.warn('Audio context creation failed:', e);
      } 
    } 
    return ctx; 
  }
  
  function playStart(){ 
    if(isMuted) return;
    const c = ensure(); 
    if(!c) return; 
    
    const o = c.createOscillator();
    const g = c.createGain(); 
    
    o.type = 'sawtooth'; 
    o.frequency.setValueAtTime(140, c.currentTime); 
    o.frequency.exponentialRampToValueAtTime(480, c.currentTime + 0.25); 
    
    g.gain.setValueAtTime(0.0001, c.currentTime); 
    g.gain.exponentialRampToValueAtTime(0.14, c.currentTime + 0.06); 
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.9); 
    
    o.connect(g); 
    g.connect(c.destination); 
    
    o.start(); 
    o.stop(c.currentTime + 0.8); 
    
    console.log('Start sound played');
  }
  
  function playShoot(){ 
    if(isMuted) return;
    const c = ensure(); 
    if(!c) return; 
    
    const o1 = c.createOscillator();
    const o2 = c.createOscillator();
    const g = c.createGain(); 
    
    o1.type = 'square'; 
    o2.type = 'triangle'; 
    
    o1.frequency.setValueAtTime(900, c.currentTime); 
    o2.frequency.setValueAtTime(1300, c.currentTime); 
    
    g.gain.setValueAtTime(0.22, c.currentTime); 
    g.gain.exponentialRampToValueAtTime(0.0001, c.currentTime + 0.14); 
    
    o1.connect(g); 
    o2.connect(g); 
    g.connect(c.destination); 
    
    o1.start(); 
    o2.start(); 
    
    o1.stop(c.currentTime + 0.14); 
    o2.stop(c.currentTime + 0.14); 
    
    console.log('Shoot sound played');
  }
  
  function playBuy(){ 
    if(isMuted) return;
    const c = ensure(); 
    if(!c) return; 
    
    const o = c.createOscillator();
    const g = c.createGain(); 
    
    o.type = 'sine'; 
    o.frequency.setValueAtTime(600, c.currentTime); 
    o.frequency.exponentialRampToValueAtTime(900, c.currentTime + 0.12); 
    
    g.gain.setValueAtTime(0.2, c.currentTime); 
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.2); 
    
    o.connect(g); 
    g.connect(c.destination); 
    
    o.start(); 
    o.stop(c.currentTime + 0.2); 
    
    console.log('Buy sound played');
  }
  
  function playLanding(){
    if(isMuted) return;
    const c = ensure();
    if(!c) return;
    
    const o = c.createOscillator();
    const g = c.createGain();
    
    o.type = 'sine';
    o.frequency.setValueAtTime(400, c.currentTime);
    o.frequency.exponentialRampToValueAtTime(200, c.currentTime + 0.5);
    
    g.gain.setValueAtTime(0.1, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 0.8);
    
    o.connect(g);
    g.connect(c.destination);
    
    o.start();
    o.stop(c.currentTime + 0.8);
    
    console.log('Landing sound played');
  }
  
  function playTakeoff(){
    if(isMuted) return;
    const c = ensure();
    if(!c) return;
    
    const o = c.createOscillator();
    const g = c.createGain();
    
    o.type = 'sawtooth';
    o.frequency.setValueAtTime(200, c.currentTime);
    o.frequency.exponentialRampToValueAtTime(800, c.currentTime + 0.6);
    
    g.gain.setValueAtTime(0.15, c.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, c.currentTime + 1.0);
    
    o.connect(g);
    g.connect(c.destination);
    
    o.start();
    o.stop(c.currentTime + 1.0);
    
    console.log('Takeoff sound played');
  }
  
  function toggleMute(){
    isMuted = !isMuted;
    if(isMuted && ctx){
      ctx.close();
      ctx = null;
    }
    console.log('Audio muted:', isMuted);
    return isMuted;
  }
  
  return { 
    playStart, 
    playShoot, 
    playBuy,
    playLanding,
    playTakeoff,
    toggleMute
  };
})();

// ========== –ë–û–ï–í–ê–Ø –°–ò–°–¢–ï–ú–ê ==========
function findNearestThreat(){
  let min = Infinity;
  let target = null;
  const pos = shipGroup.position;
  
  [...enemies, ...asteroids].forEach(o => {
    const d = pos.distanceTo(o.position);
    if(d < min){
      min = d;
      target = o;
    }
  });
  
  return target;
}

function shootAt(target){
  if(!target || !STATE.canShoot) return;
  
  const b = getBullet(); 
  if(!b) return;
  
  b.visible = true;
  b.position.copy(shipGroup.position);
  
  const dir = new THREE.Vector3()
    .subVectors(target.position, shipGroup.position)
    .normalize();
  
  b.userData.vel.copy(dir).multiplyScalar( 
    (18 + STATE.upgrades.weapon * 4) * (STATE.overdrive ? 1.6 : 1) 
  );
  
  b.userData.life = 120;
  bullets.push(b);
  
  SFX.playShoot();
  
  STATE.canShoot = false;
  STATE.lastShot = performance.now();
  
  setTimeout(() => { 
    STATE.canShoot = true;
  }, Math.max(120, 420 / (1 + (STATE.upgrades.weapon - 1) * 0.25)));
}

function createExplosion(pos, size = 12, color = 0xff6600){
  try {
    const count = 20;
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const cols = new Float32Array(count * 3);
    
    for(let i = 0; i < count; i++){ 
      const j = i * 3; 
      positions[j] = pos.x + (Math.random() - 0.5) * size; 
      positions[j+1] = pos.y + (Math.random() - 0.5) * size; 
      positions[j+2] = pos.z + (Math.random() - 0.5) * size; 
      
      cols[j] = 1; 
      cols[j+1] = 0.4 + Math.random() * 0.6; 
      cols[j+2] = 0; 
    }
    
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3)); 
    geom.setAttribute('color', new THREE.BufferAttribute(cols, 3));
    
    const mat = new THREE.PointsMaterial({ 
      size: 3.0, 
      vertexColors: true, 
      transparent: true, 
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    
    const pts = new THREE.Points(geom, mat); 
    pts.userData.life = 1.0; 
    scene.add(pts);
    
    const id = setInterval(() => { 
      if(!pts.material) {
        clearInterval(id);
        return;
      }
      
      pts.material.opacity -= 0.12; 
      pts.scale.multiplyScalar(1.1);
      
      if(pts.material.opacity <= 0){ 
        clearInterval(id); 
        try{
          scene.remove(pts);
        } catch(e){
          console.warn('Error removing explosion:', e);
        } 
      } 
    }, 50);
    
    return pts;
  } catch(e) {
    console.error('Error creating explosion:', e);
    return null;
  }
}

function flashDamage(){
  const el = document.getElementById('damageFlash'); 
  if(!el) return;
  
  el.style.opacity = '0.55'; 
  setTimeout(() => {
    if(el) el.style.opacity = '0';
  }, 150);
}

// ========== –°–ò–°–¢–ï–ú–ê –ü–û–°–ê–î–ö–ò –ò –ü–û–í–ï–†–•–ù–û–°–¢–ò ==========
function performLanding(planet){
  if(STATE.mode !== 'space') return;
  
  console.log("Starting landing sequence on:", planet.userData.name);
  
  STATE.mode = 'landing';
  STATE.currentPlanet = planet;
  
  landingAnimation.active = true;
  landingAnimation.startPos.copy(shipGroup.position);
  
  // –¶–µ–ª–µ–≤–∞—è –ø–æ–∑–∏—Ü–∏—è –¥–ª—è –ø–æ—Å–∞–¥–∫–∏ - –Ω–∞–¥ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å—é –ø–ª–∞–Ω–µ—Ç—ã
  landingAnimation.targetPos.copy(planet.position)
    .add(new THREE.Vector3(0, planet.userData.radius + 10, 0));
  
  landingAnimation.progress = 0;
  landingAnimation.startTime = performance.now();
  
  // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ—Å–∞–¥–∫–∏
  document.getElementById('landingIndicator').classList.remove('active');
  
  // –ó–≤—É–∫ –ø–æ—Å–∞–¥–∫–∏
  SFX.playLanding();
  
  // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –ø–æ—Å–∞–¥–∫–∏
  createLandingEffect(shipGroup.position, planet.userData.radius);
}

function createLandingEffect(position, radius){
  try {
    // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π –ø—Ä–∏ –ø–æ—Å–∞–¥–∫–µ
    const count = 30;
    const geom = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    const colors = new Float32Array(count * 3);
    
    for(let i = 0; i < count; i++){
      const j = i * 3;
      const angle = Math.random() * Math.PI * 2;
      const dist = Math.random() * radius * 0.8;
      
      positions[j] = position.x + Math.cos(angle) * dist;
      positions[j+1] = position.y - 5;
      positions[j+2] = position.z + Math.sin(angle) * dist;
      
      colors[j] = 1;
      colors[j+1] = 0.8;
      colors[j+2] = 0.3;
    }
    
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    
    const mat = new THREE.PointsMaterial({
      size: 4.0,
      vertexColors: true,
      transparent: true,
      blending: THREE.AdditiveBlending,
      opacity: 0.8
    });
    
    const effect = new THREE.Points(geom, mat);
    scene.add(effect);
    
    // –ê–Ω–∏–º–∞—Ü–∏—è —ç—Ñ—Ñ–µ–∫—Ç–∞
    const startTime = performance.now();
    const duration = 1000;
    
    function animateEffect(){
      const elapsed = performance.now() - startTime;
      const progress = elapsed / duration;
      
      if(progress < 1){
        effect.material.opacity = 0.8 * (1 - progress);
        effect.scale.set(1 + progress, 1 + progress, 1 + progress);
        requestAnimationFrame(animateEffect);
      } else {
        try {
          scene.remove(effect);
        } catch(e) {
          console.warn('Error removing landing effect:', e);
        }
      }
    }
    
    animateEffect();
  } catch(e) {
    console.error('Error creating landing effect:', e);
  }
}

function updateLanding(delta){
  if(!landingAnimation.active || !STATE.currentPlanet) return;
  
  const elapsed = performance.now() - landingAnimation.startTime;
  landingAnimation.progress = clamp(elapsed / landingAnimation.duration, 0, 1);
  
  const t = easeOutCubic(landingAnimation.progress);
  
  // –î–≤–∏–∂–µ–Ω–∏–µ –∫–æ—Ä–∞–±–ª—è –∫ –ø–ª–∞–Ω–µ—Ç–µ
  shipGroup.position.lerpVectors(
    landingAnimation.startPos, 
    landingAnimation.targetPos, 
    t
  );
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
  const camOffset = new THREE.Vector3(0, 8, 15);
  const targetCamPos = shipGroup.position.clone().add(camOffset);
  camera.position.lerp(targetCamPos, 0.1);
  camera.lookAt(shipGroup.position);
  
  // –ï—Å–ª–∏ –ø–æ—Å–∞–¥–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
  if(landingAnimation.progress >= 1){
    landingAnimation.active = false;
    completeLanding(STATE.currentPlanet);
  }
}

function completeLanding(planet){
  console.log("Landing complete on:", planet.userData.name);
  
  // –°–∫—Ä—ã–≤–∞–µ–º –∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã
  if(stars) stars.visible = false;
  nebulas.forEach(n => { if(n) n.visible = false; });
  planets.forEach(p => { if(p) p.visible = false; });
  asteroids.forEach(a => { if(a) a.visible = false; });
  enemies.forEach(e => { if(e) e.visible = false; });
  bullets.forEach(b => { if(b) b.visible = false; });
  if(shipGroup) shipGroup.visible = false;
  
  // –£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
  if(surfaceScene) {
    try {
      scene.remove(surfaceScene);
    } catch(e) {
      console.warn('Error removing surface scene:', e);
    }
    surfaceScene = null;
    surfaceObjects = [];
  }
  
  // –°–æ–∑–¥–∞–µ–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å –ø–ª–∞–Ω–µ—Ç—ã
  surfaceScene = createSurfaceForPlanet(planet);
  
  // –°–æ–∑–¥–∞–µ–º –∏–≥—Ä–æ–∫–∞ –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
  surfacePlayer = createSurfacePlayer();
  if (surfacePlayer && surfaceScene) {
    surfacePlayer.position.set(0, GROUND_LEVEL + PLAYER_HEIGHT, 0);
    surfaceScene.add(surfacePlayer);
  }
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –¥–ª—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
  camera.position.set(0, GROUND_LEVEL + 8, 15);
  if (surfacePlayer) {
    camera.lookAt(surfacePlayer.position);
  }
  
  // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
  document.getElementById('spaceControls').style.display = 'none';
  document.querySelector('.spaceActionButtons').style.display = 'none';
  
  document.getElementById('surfaceControls').style.display = 'flex';
  document.querySelector('.surfaceActionButtons').style.display = 'flex';
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º UI –ø–ª–∞–Ω–µ—Ç—ã
  showPlanetPanel(planet);
  
  STATE.mode = 'surface';
  
  console.log('Surface mode activated successfully');
  console.log('Player position:', surfacePlayer?.position);
  console.log('Camera position:', camera.position);
}

function takeOffFromPlanet(){
  if(STATE.mode !== 'surface') return;
  
  console.log("Taking off from planet:", STATE.currentPlanet ? STATE.currentPlanet.userData.name : 'unknown');
  
  SFX.playTakeoff();
  
  // –£–¥–∞–ª—è–µ–º –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç—å
  if(surfaceScene) {
    try {
      scene.remove(surfaceScene);
    } catch(e) {
      console.warn('Error removing surface scene during takeoff:', e);
    }
    surfaceScene = null;
    surfacePlayer = null;
    surfaceObjects = [];
  }
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–æ—Å–º–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã
  if(stars) stars.visible = true;
  nebulas.forEach(n => { if(n) n.visible = true; });
  planets.forEach(p => { if(p) p.visible = true; });
  asteroids.forEach(a => { if(a) a.visible = true; });
  enemies.forEach(e => { if(e) e.visible = true; });
  bullets.forEach(b => { if(b) b.visible = true; });
  if(shipGroup) shipGroup.visible = true;
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–æ—Ä–∞–±–ª—å
  if(STATE.currentPlanet && shipGroup) {
    shipGroup.position.copy(STATE.currentPlanet.position)
      .add(new THREE.Vector3(0, STATE.currentPlanet.userData.radius + 20, 30));
  }
  
  // –ü–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É –¥–ª—è –∫–æ—Å–º–æ—Å–∞
  if(shipGroup) {
    const camOffset = new THREE.Vector3(0, 6, 22);
    camera.position.copy(shipGroup.position).add(camOffset);
    camera.lookAt(shipGroup.position);
  }
  
  // –ü–µ—Ä–µ–∫–ª—é—á–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
  document.getElementById('surfaceControls').style.display = 'none';
  document.querySelector('.surfaceActionButtons').style.display = 'none';
  
  document.getElementById('spaceControls').style.display = 'flex';
  document.querySelector('.spaceActionButtons').style.display = 'flex';
  
  // –ó–∞–∫—Ä—ã–≤–∞–µ–º UI –ø–ª–∞–Ω–µ—Ç—ã
  document.getElementById('planetPanel').style.display = 'none';
  
  STATE.mode = 'space';
  STATE.currentPlanet = null;
  
  console.log('Back to space mode successfully');
}

// ========== UI –ò –ú–ê–ì–ê–ó–ò–ù ==========
function updateHUD(){
  try {
    document.getElementById('uiCredits').textContent = STATE.credits;
    document.getElementById('uiHealth').textContent = Math.max(0, Math.round(STATE.health));
    document.getElementById('uiShield').textContent = Math.round(STATE.shield);
    document.getElementById('uiFuel').textContent = Math.round(STATE.fuel);
    document.getElementById('uiStars').textContent = STATE.stars;
    document.getElementById('uiMission').textContent = `${STATE.missionProgress}/5`;
  } catch(e) {
    console.warn('Error updating HUD:', e);
  }
}

function showPlanetPanel(planet){
  if(!planet) return;
  
  try {
    document.getElementById('planetName').textContent = planet.userData.name;
    document.getElementById('planetDesc').textContent = planet.userData.desc;
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º NPC
    const npcList = document.getElementById('npcList');
    if(npcList) {
      npcList.innerHTML = '';
      
      const npcs = [
        {name: '–¢–æ—Ä–≥–æ–≤–µ—Ü –•–∞–Ω', text: '–†–µ–¥–∫–∏–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ø–æ –ª—É—á—à–∏–º —Ü–µ–Ω–∞–º!'},
        {name: '–ú–µ—Ö–∞–Ω–∏–∫ –ó–æ—Ä–∏', text: '–ß–∏–Ω–∏–º –∫–æ—Ä–∞–±–ª–∏ –ª—é–±–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏'},
        {name: '–£—á–µ–Ω—ã–π –õ–∏—Ä–∞', text: '–ò–∑—É—á–∞—é –º–µ—Å—Ç–Ω—É—é —Ñ–∞—É–Ω—É... –æ–ø–∞—Å–Ω—É—é —Ñ–∞—É–Ω—É'},
        {name: '–ò–Ω—Ñ–æ—Ä–º–∞—Ç–æ—Ä –ö–µ–π', text: '–°–ª—É—Ö–∏ –æ –∑–∞–±—Ä–æ—à–µ–Ω–Ω—ã—Ö —Å—Ç–∞–Ω—Ü–∏—è—Ö...'}
      ];
      
      npcs.forEach((npc, idx) => {
        const div = document.createElement('div');
        div.className = 'npc';
        div.innerHTML = `
          <div class="face">${npc.name[0]}</div>
          <div style="flex:1">
            <strong>${npc.name}</strong>
            <div class="small">${npc.text}</div>
          </div>
          <button class="btn" data-npc="${idx}">–ì–æ–≤–æ—Ä–∏—Ç—å</button>
        `;
        npcList.appendChild(div);
      });
    }
    
    // –ó–∞–ø–æ–ª–Ω—è–µ–º –º–∞–≥–∞–∑–∏–Ω
    const shopGrid = document.getElementById('shopGrid');
    if(shopGrid) {
      shopGrid.innerHTML = '';
      
      const shopItems = [
        {id: 'repair', name: '–†–µ–º–æ–Ω—Ç', price: 50, desc: '+50 –∑–¥–æ—Ä–æ–≤—å—è', icon: '‚ù§Ô∏è'},
        {id: 'weapon', name: '–£–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è', price: 100, desc: '+20% —É—Ä–æ–Ω–∞', icon: 'üí•'},
        {id: 'engine', name: '–£–ª—É—á—à–µ–Ω–∏–µ –¥–≤–∏–≥–∞—Ç–µ–ª—è', price: 80, desc: '+15% —Å–∫–æ—Ä–æ—Å—Ç–∏', icon: '‚ö°'},
        {id: 'shield', name: '–©–∏—Ç', price: 60, desc: '+50 —â–∏—Ç–∞', icon: 'üõ°'},
        {id: 'fuel', name: '–¢–æ–ø–ª–∏–≤–æ', price: 30, desc: '+50 —Ç–æ–ø–ª–∏–≤–∞', icon: '‚õΩ'},
        {id: 'scan', name: '–°–∫–∞–Ω–µ—Ä', price: 120, desc: '–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤', icon: 'üì°'}
      ];
      
      shopItems.forEach(item => {
        const div = document.createElement('div');
        div.className = 'shopItem';
        div.innerHTML = `
          <div style="font-size:20px">${item.icon}</div>
          <div><strong>${item.name}</strong></div>
          <div class="small">${item.desc}</div>
          <button class="btn" style="margin-top:8px" data-item="${item.id}" data-price="${item.price}">
            ${item.price}üí≥
          </button>
        `;
        shopGrid.appendChild(div);
      });
    }
    
    document.getElementById('planetPanel').style.display = 'block';
  } catch(e) {
    console.warn('Error showing planet panel:', e);
  }
}

function buyItem(itemId, price){
  if(STATE.credits < price) {
    alert('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫—Ä–µ–¥–∏—Ç–æ–≤!');
    return false;
  }
  
  STATE.credits -= price;
  SFX.playBuy();
  
  switch(itemId){
    case 'repair':
      STATE.health = Math.min(100, STATE.health + 50);
      break;
    case 'weapon':
      STATE.upgrades.weapon += 1;
      break;
    case 'engine':
      STATE.upgrades.engine += 1;
      break;
    case 'shield':
      STATE.shield = Math.min(100, STATE.shield + 50);
      break;
    case 'fuel':
      STATE.fuel = Math.min(100, STATE.fuel + 50);
      break;
    case 'scan':
      alert('–°–∫–∞–Ω–µ—Ä –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω! –¢–µ–ø–µ—Ä—å –≤—ã –≤–∏–¥–∏—Ç–µ –≤—Ä–∞–≥–æ–≤ –Ω–∞ —Ä–∞–¥–∞—Ä–µ.');
      break;
  }
  
  updateHUD();
  return true;
}

// ========== –°–ò–°–¢–ï–ú–ê –£–ü–†–ê–í–õ–ï–ù–ò–Ø ==========
function initSpaceJoystick(){
  try {
    const joy = document.getElementById('spaceJoy');
    const knob = document.getElementById('spaceKnob');
    
    if(!joy || !knob) {
      console.warn('Space joystick elements not found');
      return false;
    }
    
    let isTouching = false;
    let joyRect;
    
    function start(ev){
      isTouching = true;
      joyRect = joy.getBoundingClientRect();
      const pos = getTouchPos(ev);
      moveKnob(pos.x - joyRect.left, pos.y - joyRect.top);
    }
    
    function move(ev){
      if(!isTouching) return;
      ev.preventDefault();
      const pos = getTouchPos(ev);
      const localX = pos.x - joyRect.left - joyRect.width/2;
      const localY = pos.y - joyRect.top - joyRect.height/2;
      const maxDist = joyRect.width/2 - 21;
      const dist = Math.hypot(localX, localY);
      
      const normX = (dist > maxDist) ? (localX/dist * maxDist) : localX;
      const normY = (dist > maxDist) ? (localY/dist * maxDist) : localY;
      
      knob.style.transform = `translate(${normX}px, ${normY}px)`;
      spaceJoystick.x = normX / maxDist;
      spaceJoystick.y = -normY / maxDist;
    }
    
    function end(){
      isTouching = false;
      knob.style.transform = `translate(0px, 0px)`;
      spaceJoystick.x = 0;
      spaceJoystick.y = 0;
    }
    
    function getTouchPos(e){
      const t = e.touches ? e.touches[0] : e;
      return { x: t.clientX, y: t.clientY };
    }
    
    function moveKnob(x, y){
      const localX = x - joyRect.width/2;
      const localY = y - joyRect.height/2;
      const maxDist = joyRect.width/2 - 21;
      const dist = Math.hypot(localX, localY);
      
      const normX = (dist > maxDist) ? (localX/dist * maxDist) : localX;
      const normY = (dist > maxDist) ? (localY/dist * maxDist) : localY;
      
      knob.style.transform = `translate(${normX}px, ${normY}px)`;
      spaceJoystick.x = normX / maxDist;
      spaceJoystick.y = -normY / maxDist;
    }
    
    joy.addEventListener('touchstart', start, {passive:false});
    joy.addEventListener('touchmove', move, {passive:false});
    joy.addEventListener('touchend', end, {passive:false});
    joy.addEventListener('mousedown', start);
    window.addEventListener('mousemove', move);
    window.addEventListener('mouseup', end);
    
    console.log('Space joystick initialized');
    return true;
  } catch(e) {
    console.error('Error initializing space joystick:', e);
    return false;
  }
}

function initSurfaceJoystick(){
  try {
    const joy = document.getElementById('surfaceJoy');
    const knob = document.getElementById('surfaceKnob');
    
    if(!joy || !knob) {
      console.warn('Surface joystick elements not found');
      return false;
    }
    
    let startX = 0, startY = 0, active = false;
    const radius = 40;
    
    function down(e){
      active = true;
      surfaceJoystick.active = true;
      const touch = (e.touches && e.touches[0]) || e;
      startX = touch.clientX;
      startY = touch.clientY;
    }
    
    function move(e){
      if(!active) return;
      e.preventDefault();
      const touch = (e.touches && e.touches[0]) || e;
      let dx = touch.clientX - startX;
      let dy = touch.clientY - startY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      if(dist > radius){
        dx *= radius/dist;
        dy *= radius/dist;
      }
      
      knob.style.left = (38 + dx) + 'px';
      knob.style.top = (38 + dy) + 'px';
      surfaceJoystick.x = dx / radius;
      surfaceJoystick.y = -dy / radius;
    }
    
    function up(){
      active = false;
      knob.style.left = '38px';
      knob.style.top = '38px';
      surfaceJoystick.active = false;
      surfaceJoystick.x = 0;
      surfaceJoystick.y = 0;
    }
    
    joy.addEventListener('touchstart', down);
    joy.addEventListener('touchmove', move);
    joy.addEventListener('touchend', up);
    joy.addEventListener('mousedown', down);
    joy.addEventListener('mousemove', move);
    joy.addEventListener('mouseup', up);
    joy.addEventListener('mouseleave', up);
    
    console.log('Surface joystick initialized');
    return true;
  } catch(e) {
    console.error('Error initializing surface joystick:', e);
    return false;
  }
}

// ========== –û–°–ù–û–í–ù–û–ô –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ==========
let lastTime = performance.now();

function animate(){
  try {
    requestAnimationFrame(animate);
    
    const now = performance.now();
    const delta = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
    switch(STATE.mode){
      case 'space':
        updateSpace(delta);
        break;
      case 'landing':
        updateLanding(delta);
        break;
      case 'surface':
        updateSurface(delta);
        break;
    }
    
    // –†–µ–Ω–¥–µ—Ä–∏–Ω–≥
    if(hasComposer && composer) {
      composer.render();
    } else if(renderer) {
      renderer.render(scene, camera);
    }
  } catch(e) {
    console.error('Error in game loop:', e);
  }
}

function updateSpace(delta){
  if(!shipGroup) return;
  
  // –£–í–ï–õ–ò–ß–ï–ù–ù–ê–Ø –°–ö–û–†–û–°–¢–¨ –ë–û–ö–û–í–û–ì–û –ü–ï–†–ï–ú–ï–©–ï–ù–ò–Ø - –±—ã–ª–æ 8 –∏ 6, —Å—Ç–∞–ª–æ 16 –∏ 12
  const moveSpeed = 1.2 * (1 + (STATE.upgrades.engine - 1) * 0.2) * (STATE.overdrive ? 2.0 : 1.0);
  
  shipGroup.position.x += spaceJoystick.x * 16 * delta * moveSpeed;
  shipGroup.position.y += spaceJoystick.y * 12 * delta * moveSpeed;
  shipGroup.position.z -= 40 * delta * moveSpeed;
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
  const camOffset = new THREE.Vector3(0, 6, 22);
  const targetCamPos = shipGroup.position.clone().add(camOffset);
  camera.position.lerp(targetCamPos, 0.12);
  camera.lookAt(shipGroup.position.clone().add(new THREE.Vector3(0, 0, -180)));
  
  // –ß–∞—Å—Ç–∏—Ü—ã –¥–≤–∏–≥–∞—Ç–µ–ª–µ–π
  if(shipEngineParticles) {
    animateEngineParticles(delta);
  }
  
  // –î–≤–∏–∂–µ–Ω–∏–µ –∑–≤–µ–∑–¥ –¥–ª—è –ø–∞—Ä–∞–ª–ª–∞–∫—Å–∞
  if(stars) { 
    stars.position.z += 0.09 * delta * 60; 
    if(stars.position.z > 2000) stars.position.z = -2000; 
  }
  
  nebulas.forEach(n => {
    if(n) n.rotation.y += 0.0005 * delta * 60;
  });
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
  for(let i = asteroids.length - 1; i >= 0; i--){
    const a = asteroids[i];
    if(!a) continue;
    
    a.position.z += 0.6 * delta * 60;
    a.rotation.x += a.userData.rot.x * delta * 60; 
    a.rotation.y += a.userData.rot.y * delta * 60;
    
    if(a.position.z > shipGroup.position.z + 80){ 
      try {
        scene.remove(a);
      } catch(e) {
        console.warn('Error removing asteroid:', e);
      }
      asteroids.splice(i, 1); 
      spawnAsteroid(
        (Math.random() - 0.5) * 800, 
        (Math.random() - 0.5) * 200, 
        shipGroup.position.z - 1600, 
        1.0 + Math.random() * 4
      ); 
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
    if(a.position.distanceTo(shipGroup.position) < (a.userData.radius + 3.5)){
      if(STATE.shield > 0){ 
        STATE.shield = Math.max(0, STATE.shield - 10); 
      } else { 
        STATE.health -= 10; 
        flashDamage(); 
      }
      
      createExplosion(a.position, 10); 
      try {
        scene.remove(a);
      } catch(e) {
        console.warn('Error removing asteroid on collision:', e);
      }
      asteroids.splice(i, 1);
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
  for(let i = enemies.length - 1; i >= 0; i--){
    const e = enemies[i];
    if(!e) continue;
    
    const dx = shipGroup.position.x - e.position.x; 
    const dz = shipGroup.position.z - e.position.z;
    const dist = Math.hypot(dx, dz);
    
    if(dist < 260){ 
      e.position.x += dx * 0.008 * e.userData.speed * delta * 60; 
      e.position.z += dz * 0.008 * e.userData.speed * delta * 60; 
    } else {
      e.position.z += 0.2 * delta * 60;
    }
    
    if(e.position.distanceTo(shipGroup.position) < 8){ 
      if(STATE.shield > 0) {
        STATE.shield = Math.max(0, STATE.shield - 20);
      } else { 
        STATE.health -= 20; 
        flashDamage(); 
      } 
      
      createExplosion(e.position, 12); 
      try {
        scene.remove(e);
      } catch(e) {
        console.warn('Error removing enemy on collision:', e);
      }
      enemies.splice(i, 1); 
      STATE.credits += 12; 
      updateHUD(); 
    }
    
    if(e.position.z > shipGroup.position.z + 200){ 
      try {
        scene.remove(e);
      } catch(e) {
        console.warn('Error removing enemy:', e);
      }
      enemies.splice(i, 1); 
      spawnEnemy(
        (Math.random() - 0.5) * 600,
        (Math.random() - 0.5) * 200, 
        shipGroup.position.z - 1200
      ); 
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—É–ª—å
  for(let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    if(!b || !b.visible) continue;
    
    b.position.add(b.userData.vel.clone().multiplyScalar(delta * 60));
    b.userData.life--;
    
    for(let j = enemies.length - 1; j >= 0; j--){
      const en = enemies[j];
      if(!en) continue;
      
      if(b.position.distanceTo(en.position) < 5){
        en.userData.health -= 12 * (1 + (STATE.upgrades.weapon - 1) * 0.25);
        b.visible = false;
        bullets.splice(i, 1);
        
        if(en.userData.health <= 0){
          createExplosion(en.position, 10); 
          try {
            scene.remove(en);
          } catch(e) {
            console.warn('Error removing enemy:', e);
          }
          enemies.splice(j, 1); 
          STATE.credits += 20; 
          STATE.stars += 1;
          updateHUD(); 
        }
        break;
      }
    }
    
    if(b.userData.life <= 0 || b.position.distanceTo(shipGroup.position) > 1200){ 
      b.visible = false; 
      bullets.splice(i, 1); 
    }
  }
  
  // –†–∞—Å—Ö–æ–¥ —Ç–æ–ø–ª–∏–≤–∞
  STATE.fuel = Math.max(0, STATE.fuel - 0.002 * delta * 60 * (STATE.overdrive ? 2 : 1));
  if(STATE.fuel <= 0){ 
    STATE.overdrive = false; 
  }
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–ª–∏–∑–æ—Å—Ç–∏ –∫ –ø–ª–∞–Ω–µ—Ç–∞–º
  let nearPlanet = null;
  let minDistance = Infinity;
  
  for(let p of planets){
    if(!p) continue;
    const d = shipGroup.position.distanceTo(p.position);
    const landingDistance = p.userData.radius + 50;
    
    if(d < landingDistance && d < minDistance){
      minDistance = d;
      nearPlanet = p;
    }
  }
  
  // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ—Å–∞–¥–∫–∏
  const landingIndicator = document.getElementById('landingIndicator');
  if(landingIndicator) {
    if(nearPlanet) {
      landingIndicator.textContent = `–ü–†–ò–ë–õ–ò–ñ–ï–ù–ò–ï –ö ${nearPlanet.userData.name} - –ù–ê–ñ–ú–ò–¢–ï –î–õ–Ø –ü–û–°–ê–î–ö–ò`;
      landingIndicator.classList.add('active');
    } else {
      landingIndicator.classList.remove('active');
    }
  }
  
  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø–æ—Å–∞–¥–∫–∞ –ø—Ä–∏ –æ—á–µ–Ω—å –±–ª–∏–∑–∫–æ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏
  if(nearPlanet && minDistance < nearPlanet.userData.radius + 20){
    performLanding(nearPlanet);
  }
  
  updateHUD();
  STATE.missionProgress = Math.min(5, STATE.missionProgress + 0.0005 * delta * 60);
}

function updateSurface(delta){
  if(!surfacePlayer || !surfaceScene) return;
  
  // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –∏ –∫–æ–ª–ª–∏–∑–∏–∏ —Å –∑–µ–º–ª–µ–π
  const playerY = surfacePlayer.position.y;
  const targetY = GROUND_LEVEL + PLAYER_HEIGHT;
  
  if(playerY > targetY) {
    surfacePlayer.position.y -= GRAVITY * delta * 60;
    if(surfacePlayer.position.y < targetY) {
      surfacePlayer.position.y = targetY;
    }
  } else if(playerY < targetY) {
    surfacePlayer.position.y = targetY;
  }
  
  // –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
  const speed = 8 * delta;
  
  if(surfaceJoystick.active){
    const moveX = surfaceJoystick.x * speed;
    const moveZ = surfaceJoystick.y * speed;
    
    surfacePlayer.position.x += moveX;
    surfacePlayer.position.z += moveZ;
    
    // –ü–æ–≤–æ—Ä–æ—Ç –∏–≥—Ä–æ–∫–∞ –≤ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –¥–≤–∏–∂–µ–Ω–∏—è
    if(Math.abs(surfaceJoystick.x) > 0.1 || Math.abs(surfaceJoystick.y) > 0.1){
      surfacePlayer.rotation.y = Math.atan2(-surfaceJoystick.x, -surfaceJoystick.y);
    }
  }
  
  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
  const camOffset = new THREE.Vector3(0, PLAYER_HEIGHT + 4, 12);
  const targetCamPos = surfacePlayer.position.clone().add(camOffset);
  camera.position.lerp(targetCamPos, 0.1);
  camera.lookAt(surfacePlayer.position);
  
  // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å NPC
  if(surfaceObjects.length > 0) {
    for(let obj of surfaceObjects) {
      if(!obj.userData || !obj.userData.interactable) continue;
      
      const dist = surfacePlayer.position.distanceTo(obj.position);
      if(dist < 4.0 && STATE.mode === 'surface') {
        document.querySelector('.bottomHints').textContent = '–ù–∞–∂–º–∏—Ç–µ üëÅÔ∏è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è';
        break;
      }
    }
  }
}

function animateEngineParticles(delta){
  if(!shipEngineParticles || !shipEngineParticles.geom) return;
  
  const positions = shipEngineParticles.geom.attributes.position.array;
  const count = positions.length / 3;
  
  for(let i = 0; i < count; i++){
    const j = i * 3;
    positions[j+2] += (1.0 + Math.random() * 1.0) * (STATE.overdrive ? 1.4 : 1.0);
    
    if(positions[j+2] > 18){ 
      positions[j] = (Math.random() - 0.5) * 1.8; 
      positions[j+1] = (Math.random() - 0.5) * 1.8; 
      positions[j+2] = 2 + Math.random() * 4; 
    }
  }
  
  shipEngineParticles.geom.attributes.position.needsUpdate = true;
  shipEngineParticles.points.material.opacity = 0.6 + Math.abs(Math.sin(Date.now() * 0.006)) * 0.25;
}

// ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –°–û–ë–´–¢–ò–ô ==========
function initEventHandlers(){
  try {
    // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
    const startBtn = document.getElementById('btnStart');
    if (startBtn) startBtn.addEventListener('click', startGame);
    
    // –û–±—É—á–µ–Ω–∏–µ
    const howBtn = document.getElementById('btnHow');
    if (howBtn) howBtn.addEventListener('click', () => {
      alert(`–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:
–ö–æ—Å–º–æ—Å: –î–∂–æ–π—Å—Ç–∏–∫ - –¥–≤–∏–∂–µ–Ω–∏–µ, üí• - —Å—Ç—Ä–µ–ª—å–±–∞, üõ° - —â–∏—Ç, ‚ö° - –æ–≤–µ—Ä–¥—Ä–∞–π–≤
–ü–ª–∞–Ω–µ—Ç–∞: –î–∂–æ–π—Å—Ç–∏–∫ - —Ö–æ–¥—å–±–∞, üëÅÔ∏è - –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ, üöÄ - –≤–∑–ª–µ—Ç
–¢–∞–ø –ø–æ –ø–ª–∞–Ω–µ—Ç–µ –¥–ª—è –ø–æ—Å–∞–¥–∫–∏!`);
    });
    
    // –î–µ–π—Å—Ç–≤–∏—è –≤ –∫–æ—Å–º–æ—Å–µ
    const shootBtn = document.getElementById('btnShoot');
    if (shootBtn) shootBtn.addEventListener('click', () => {
      if(STATE.mode === 'space'){ 
        const t = findNearestThreat(); 
        if(t) shootAt(t); 
      }
    });
    
    const shieldBtn = document.getElementById('btnShield');
    if (shieldBtn) shieldBtn.addEventListener('click', () => {
      if(STATE.mode === 'space' && STATE.credits >= 20 && !STATE.shieldActive){ 
        STATE.credits -= 20; 
        STATE.shieldActive = true;
        
        // –í–∏–∑—É–∞–ª—å–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç —â–∏—Ç–∞
        const shield = new THREE.Mesh(
          new THREE.SphereGeometry(8, 16, 12),
          new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            transparent: true, 
            opacity: 0.2, 
            side: THREE.DoubleSide 
          })
        );
        shield.userData = { type: 'shield' };
        shipGroup.add(shield);
        
        setTimeout(() => {
          try{ 
            if(shipGroup && shipGroup.children.includes(shield)) {
              shipGroup.remove(shield);
            }
          } catch(e){
            console.warn('Error removing shield:', e);
          }
          STATE.shieldActive = false;
        }, 5000);
        
        SFX.playBuy(); 
        updateHUD(); 
      } else {
        alert('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –∫—Ä–µ–¥–∏—Ç–æ–≤ –∏–ª–∏ —â–∏—Ç —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω.');
      }
    });
    
    const boostBtn = document.getElementById('btnBoost');
    if (boostBtn) boostBtn.addEventListener('click', () => {
      if(STATE.mode === 'space' && STATE.fuel >= 20 && !STATE.overdrive){ 
        STATE.fuel -= 20; 
        STATE.overdrive = true; 
        setTimeout(() => STATE.overdrive = false, 5000); 
      }
    });
    
    // –î–µ–π—Å—Ç–≤–∏—è –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω–æ—Å—Ç–∏
    const takeoffBtn = document.getElementById('btnTakeoff');
    if (takeoffBtn) takeoffBtn.addEventListener('click', takeOffFromPlanet);
    
    const interactBtn = document.getElementById('btnInteract');
    if (interactBtn) interactBtn.addEventListener('click', () => {
      if(STATE.mode === 'surface' && surfaceObjects.length > 0){
        // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à–µ–≥–æ NPC
        let nearestNPC = null;
        let minDist = Infinity;
        
        for(let obj of surfaceObjects) {
          if(!obj.userData || !obj.userData.interactable) continue;
          
          const dist = surfacePlayer.position.distanceTo(obj.position);
          if(dist < minDist && dist < 4.0) {
            minDist = dist;
            nearestNPC = obj;
          }
        }
        
        if(nearestNPC) {
          // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥ —Å NPC
          const dialogues = {
            merchant: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å! –£ –º–µ–Ω—è –µ—Å—Ç—å –ª—É—á—à–∏–µ —Ç–æ–≤–∞—Ä—ã –≤ –≥–∞–ª–∞–∫—Ç–∏–∫–µ.",
            mechanic: "–ü—Ä–∏–≤–µ—Ç! –ß–µ–º —è –º–æ–≥—É –ø–æ–º–æ—á—å —Å –≤–∞—à–∏–º –∫–æ—Ä–∞–±–ª–µ–º?",
            scientist: "–û, –ø—É—Ç–µ—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫! –Ø –∏–∑—É—á–∞—é –º–µ—Å—Ç–Ω—É—é —ç–∫–æ—Å–∏—Å—Ç–µ–º—É. –û—Å—Ç–æ—Ä–æ–∂–Ω–æ, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Å—É—â–µ—Å—Ç–≤–∞ –æ–ø–∞—Å–Ω—ã!",
            informant: "–≠–π, —à–µ–ø–æ—Ç–æ–º... –Ø –∑–Ω–∞—é, –≥–¥–µ —Å–ø—Ä—è—Ç–∞–Ω—ã –¥—Ä–µ–≤–Ω–∏–µ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã."
          };
          
          document.getElementById('npcDialogue').textContent = 
            dialogues[nearestNPC.userData.type] || nearestNPC.userData.dialog;
          
          document.getElementById('planetPanel').style.display = 'block';
        } else {
          document.querySelector('.bottomHints').textContent = '–ù–µ—Ç NPC —Ä—è–¥–æ–º –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è';
        }
      }
    });
    
    // –ü–∞–Ω–µ–ª—å –ø–ª–∞–Ω–µ—Ç—ã
    const closePanelBtn = document.getElementById('btnClosePanel');
    if (closePanelBtn) closePanelBtn.addEventListener('click', () => {
      document.getElementById('planetPanel').style.display = 'none';
    });
    
    // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å NPC –≤ UI
    const npcList = document.getElementById('npcList');
    if (npcList) {
      npcList.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-npc]');
        if(btn){
          const npcId = parseInt(btn.dataset.npc);
          const dialogues = [
            "–°–ª—ã—à–∞–ª –æ –∫–∞—Ä–∞–≤–∞–Ω–µ –≤ —Å–µ–∫—Ç–æ—Ä–µ 9? –í—ã—Å–æ–∫–∞—è –æ–ø–ª–∞—Ç–∞!",
            "–ù—É–∂–µ–Ω —Ä–µ–º–æ–Ω—Ç? –£ –º–µ–Ω—è –µ—Å—Ç—å –∑–∞–ø—á–∞—Å—Ç–∏... –∑–∞ –∫—Ä–µ–¥–∏—Ç—ã.",
            "–ì–æ–≤–æ—Ä—è—Ç, –Ω–∞ –∑–∞–±—Ä–æ—à–µ–Ω–Ω–æ–π —Å—Ç–∞–Ω—Ü–∏–∏ –Ω–∞—à–ª–∏ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã.",
            "–û—Å—Ç–æ—Ä–æ–∂–Ω–æ! –ù–∞ –æ—Ä–±–∏—Ç–µ –ø–∏—Ä–∞—Ç—ã. –õ—É—á—à–µ –≤–∫–ª—é—á–∏—Ç—å —â–∏—Ç—ã."
          ];
          document.getElementById('npcDialogue').textContent = dialogues[npcId] || "–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É—é, –ø—É—Ç–Ω–∏–∫.";
        }
      });
    }
    
    // –ü–æ–∫—É–ø–∫–∏ –≤ –º–∞–≥–∞–∑–∏–Ω–µ
    const shopGrid = document.getElementById('shopGrid');
    if (shopGrid) {
      shopGrid.addEventListener('click', (e) => {
        const btn = e.target.closest('button[data-item]');
        if(btn){
          const itemId = btn.dataset.item;
          const price = parseInt(btn.dataset.price);
          buyItem(itemId, price);
        }
      });
    }
    
    // –û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–ª–∏–∫–æ–≤ –ø–æ –ø–ª–∞–Ω–µ—Ç–∞–º
    if (renderer && renderer.domElement) {
      renderer.domElement.addEventListener('click', (e) => {
        if(STATE.mode !== 'space') return;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∫–ª–∏–∫–Ω—É–ª–∏ –ª–∏ –ø–æ UI
        const uiElements = document.querySelectorAll('.btn, .actionBtn, .joyPad, .spaceActionButtons, .surfaceActionButtons, .planetUI');
        for(let el of uiElements) {
          if(el.contains(e.target)) return;
        }
        
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
        
        raycaster.setFromCamera({x, y}, camera);
        const intersects = raycaster.intersectObjects(planets);
        
        if(intersects.length > 0){
          performLanding(intersects[0].object);
        }
      });
    }
    
    console.log('Event handlers initialized');
    return true;
  } catch(e) {
    console.error('Error initializing event handlers:', e);
    return false;
  }
}

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò–ì–†–´ ==========
function startGame(){
  if(STATE.mode !== 'menu') return;
  
  console.log('Starting game...');
  
  try {
    SFX.playStart();
    STATE.mode = 'space';
    const menu = document.getElementById('menu');
    if (menu) menu.style.display = 'none';
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª
    animate();
    
    console.log('Game started successfully');
  } catch(e) {
    console.error('Error starting game:', e);
    alert('–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∏–≥—Ä—ã: ' + e.message);
  }
}

function initGame() {
  try {
    console.log('Initializing game components...');
    
    if (!initThree()) throw new Error('Three.js initialization failed');
    if (!makeLights()) throw new Error('Lights creation failed');
    if (!createShip()) throw new Error('Ship creation failed');
    if (!createStarfield()) throw new Error('Starfield creation failed');
    if (!generateSpacePlanets()) throw new Error('Planets generation failed');
    if (!initSpaceObjects()) throw new Error('Space objects initialization failed');
    if (!initBulletPool()) throw new Error('Bullet pool initialization failed');
    if (!initSpaceJoystick()) throw new Error('Space joystick initialization failed');
    if (!initSurfaceJoystick()) throw new Error('Surface joystick initialization failed');
    if (!initEventHandlers()) throw new Error('Event handlers initialization failed');
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ —Å–ø–∞–≤–Ω–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
    setInterval(() => {
      if(STATE.mode === 'space'){ 
        spawnEnemy(
          (Math.random() - 0.5) * 600,
          (Math.random() - 0.5) * 200, 
          shipGroup.position.z - 1200
        ); 
      }
    }, 2400);
    
    // –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–µ —Å–ø–∞–≤–Ω–µ–Ω–∏–µ –∞—Å—Ç–µ—Ä–æ–∏–¥–æ–≤
    setInterval(() => {
      if(STATE.mode === 'space'){ 
        spawnAsteroid(
          (Math.random() - 0.5) * 800,
          (Math.random() - 0.5) * 200, 
          shipGroup.position.z - 1600, 
          1.2 + Math.random() * 4
        ); 
      }
    }, 1300);
    
    updateHUD();
    
    console.log('Game bootstrapped successfully');
  } catch(e) {
    console.error('Critical error during bootstrap:', e);
    alert('–û—à–∏–±–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã: ' + e.message);
  }
}

function bootstrap(){
  console.log('Bootstrapping game...');
  
  // –ñ–¥–µ–º –ø–æ–ª–Ω–æ–π –∑–∞–≥—Ä—É–∑–∫–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
  } else {
    initGame();
  }
}

// ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ò–ó–ú–ï–ù–ï–ù–ò–Ø –†–ê–ó–ú–ï–†–ê ==========
window.addEventListener('resize', () => {
  console.log('Window resized');
  
  if(renderer && camera){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    if(hasComposer && composer) {
      composer.setSize(window.innerWidth, window.innerHeight);
      composer.setPixelRatio(pixelRatio);
    }
  }
});

// ========== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–†–ò –ó–ê–ì–†–£–ó–ö–ï ==========
bootstrap();

// –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
let dots = 0;
setInterval(() => {
  dots = (dots + 1) % 4;
  const loadingDots = document.getElementById('loadingDots');
  if (loadingDots) loadingDots.textContent = '‚óè'.repeat(dots);
}, 500);

// Debug —Ä–µ–∂–∏–º –ø–æ –¥–≤–æ–π–Ω–æ–º—É –∫–ª–∏–∫—É
window.addEventListener('dblclick', () => {
  if(STATE.debugMode) {
    STATE.credits += 100;
    STATE.stars += 5;
    updateHUD();
    SFX.playBuy();
    alert('Debug credits and stars added!');
  }
});

// ========== DEBUG –§–£–ù–ö–¶–ò–ò ==========
window.debugInfo = function() {
  console.log('=== DEBUG INFO ===');
  console.log('Mode:', STATE.mode);
  console.log('Current planet:', STATE.currentPlanet ? STATE.currentPlanet.userData.name : 'none');
  console.log('Ship position:', shipGroup ? shipGroup.position : 'no ship');
  console.log('Surface player position:', surfacePlayer ? surfacePlayer.position : 'no surface player');
  console.log('Surface scene:', surfaceScene ? 'exists' : 'none');
  console.log('Surface objects:', surfaceObjects.length);
  console.log('Planets:', planets.length);
  console.log('Asteroids:', asteroids.length);
  console.log('Enemies:', enemies.length);
  console.log('Bullets:', bullets.length);
  console.log('=================');
};

console.log('Game script loaded successfully');
</script>
</body>
</html>