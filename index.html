<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Z.E.R.O.: Last Breach</title>

<!-- Telegram + Three.js -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
:root{
  --neon:#00ffea; --accent:#ff6b6b; --bg:#05060a;
}
*{box-sizing:border-box;margin:0;padding:0;user-select:none;-webkit-user-select:none}
html,body,#app{height:100%}
body{background:linear-gradient(180deg,#030305,#0b0b10);font-family:Arial,Helvetica,sans-serif;color:var(--neon);overflow:hidden}
#app{position:relative;width:100vw;height:100vh}

/* Menu sits on top */
#menu{
  position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
  z-index:4000; /* high - menu always clickable */
  pointer-events:auto;
  background: rgba(5, 6, 10, 0.9);
  backdrop-filter: blur(5px);
}
.menu-overlay{
  width:min(820px,94%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));
  border:1px solid rgba(0,255,234,0.07);padding:28px;border-radius:14px;text-align:center;backdrop-filter:blur(6px)
}
.menu-title{font-size:44px;letter-spacing:3px;background:linear-gradient(90deg,var(--neon),#5cc9ff);-webkit-background-clip:text;color:transparent;margin-bottom:6px}
.menu-sub{color:#bffdf7;opacity:0.9;margin-bottom:12px}
.menu-row{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}
.btn{padding:12px 18px;border-radius:10px;background:linear-gradient(180deg,#0d1116,#081018);border:1px solid rgba(0,255,234,0.06);color:var(--neon);cursor:pointer;font-weight:700;transition: all 0.2s ease;}
.btn:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,255,234,0.1);}
.btn:active{transform:translateY(0px);}
.btn.secondary{color:#ffb3d6;border-color:rgba(255,107,107,0.12)}
.btn.small{padding:8px 10px;font-size:14px}

/* Modals */
.modal{display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:4500;background:rgba(0,0,0,0.8);}
.modal.show{display:flex}
.modal .card{width:min(720px,94%);background:#07090b;padding:18px;border-radius:12px;border:1px solid rgba(0,255,234,0.06)}

/* Game UI - sits above canvas but below menu */
#gameUI{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3000;pointer-events:none}
.panel{background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;border:1px solid rgba(0,255,234,0.04);display:flex;gap:8px;align-items:center;backdrop-filter:blur(6px)}
#hud{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:10px;pointer-events:none}
#healthBar{width:220px;height:14px;background:#111;border-radius:8px;overflow:hidden}
#healthFill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width 0.12s linear}

/* Bottom controls (touch) */
#bottomUI{position:absolute;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;pointer-events:auto;z-index:3200}
.weaponButtons{display:flex;gap:8px}
.wbtn{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(0,255,234,0.04);color:var(--neon);font-weight:700;cursor:pointer;transition: all 0.2s ease;}
.wbtn.active{border-color:rgba(0,255,234,0.6);background:rgba(0,255,234,0.1);}

/* Joystick */
#joystick{position:absolute;left:18px;bottom:18px;width:120px;height:120px;border-radius:50%;background:rgba(0,255,234,0.04);display:none;align-items:center;justify-content:center;pointer-events:auto;z-index:3200;border:2px solid rgba(0,255,234,0.1)}
#joyHandle{width:56px;height:56px;border-radius:50%;background:rgba(0,255,234,0.14);transform:translate(-50%,-50%);position:relative;left:50%;top:50%}

/* Crosshair */
#crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:28px;height:28px;pointer-events:none;z-index:3100}
.crossV{position:absolute;left:50%;transform:translateX(-50%);width:3px;height:28px;background:var(--neon)}
.crossH{position:absolute;top:50%;transform:translateY(-50%);height:3px;width:28px;background:var(--neon)}

/* gameContainer (canvas holder) - below menu, above body */
#gameContainer{position:absolute;inset:0;z-index:2000;pointer-events:none} /* pointer-events none until game starts */

/* Results screen */
#results{position:absolute;inset:0;display:none;z-index:4200;align-items:center;justify-content:center;background:rgba(0,0,0,0.85)}
.results .card{padding:30px;border-radius:12px;background:linear-gradient(180deg,#07080a,#0b0b10);border:1px solid rgba(0,255,234,0.06);color:var(--neon)}

/* small responsive */
@media (max-width:900px){
  #joystick{display:flex}
  #crosshair{display:block}
}
</style>
</head>
<body>
<div id="app">
  <!-- Menu (top) -->
  <div id="menu">
    <div class="menu-overlay">
      <div class="menu-title">Z.E.R.O.</div>
      <div class="menu-sub">LAST BREACH ‚Äî prototype</div>
      <div class="menu-row">
        <button id="startButton" class="btn">üéÆ –ù–ê–ß–ê–¢–¨ –ú–ò–°–°–ò–Æ</button>
        <button id="settingsButton" class="btn">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button id="helpButton" class="btn secondary">üìñ –û–ë–£–ß–ï–ù–ò–ï</button>
      </div>
      <div style="margin-top:12px;color:#98fff8;opacity:0.9">–ù–∏–∑–∫–æ–ø–æ–ª–∏–≥–æ–Ω–∞–ª—å–Ω–∞—è –∞—Ä–µ–Ω–∞ ‚Äî –¥–æ–º–∞/–¥–µ—Ä–µ–≤—å—è, –≤–æ–ª–Ω—ã –∑–æ–º–±–∏, 3 —Ç–∏–ø–∞ –æ—Ä—É–∂–∏—è</div>
    </div>
  </div>

  <!-- Modals -->
  <div id="modalSettings" class="modal">
    <div class="card">
      <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
      <div style="margin:10px 0;">–ì—Ä–æ–º–∫–æ—Å—Ç—å: <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.8"></div>
      <div style="margin:10px 0;">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <input id="sens" type="range" min="0.2" max="2" step="0.05" value="1"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px;"><button id="closeSettings" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
    </div>
  </div>

  <div id="modalHelp" class="modal">
    <div class="card">
      <h3>–û–±—É—á–µ–Ω–∏–µ</h3>
      <p>–î–≤–∏–∂–µ–Ω–∏–µ: WASD / —Å—Ç—Ä–µ–ª–∫–∏ –∏–ª–∏ –¥–∂–æ–π—Å—Ç–∏–∫ (–Ω–∞ –º–æ–±). –°—Ç—Ä–µ–ª—å–±–∞: –º—ã—à—å/–∫–Ω–æ–ø–∫–∞. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ: 1/2/3.</p>
      <div style="display:flex;justify-content:flex-end"><button id="closeHelp" class="btn">–ü–æ–Ω—è—Ç–Ω–æ</button></div>
    </div>
  </div>

  <!-- Game UI -->
  <div id="gameUI">
    <div id="hud">
      <div class="panel"><div style="min-width:80px">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï</div>
        <div id="healthBar"><div id="healthFill"></div></div>
        <div id="hpTxt" style="min-width:60px;text-align:right;font-weight:700">100</div>
      </div>
      <div class="panel">–ü–∞—Ç—Ä–æ–Ω—ã: <div id="ammoTxt" style="margin-left:8px;font-weight:700">‚Äî</div></div>
      <div class="panel">–í–æ–ª–Ω–∞: <div id="waveTxt" style="margin-left:8px;font-weight:700">0</div></div>
    </div>

    <div id="bottomUI">
      <div class="weaponButtons">
        <button class="wbtn active" data-w="0">1 –ü–∏—Å—Ç–æ–ª–µ—Ç</button>
        <button class="wbtn" data-w="1">2 –ê–≤—Ç–æ</button>
        <button class="wbtn" data-w="2">3 –î—Ä–æ–±–æ–≤–∏–∫</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="shootBtn" class="btn">üî´</button>
        <button id="skillBtn" class="btn secondary">‚ö° –ò–º–ø—É–ª—å—Å</button>
        <button id="reloadBtn" class="btn small">‚Üª –ü–µ—Ä–µ–∑–∞—Ä—è–¥</button>
      </div>
    </div>

    <div id="joystick"><div id="joyHandle"></div></div>
    <div id="crosshair"><div class="crossV"></div><div class="crossH"></div></div>
  </div>

  <!-- Results -->
  <div id="results">
    <div class="results card">
      <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2>
      <div id="resultsText"></div>
      <div style="margin-top:12px">
        <button id="resultsToMenu" class="btn">–í –º–µ–Ω—é</button>
        <button id="restartButton" class="btn secondary" style="margin-left:8px">üîÑ –ó–∞–Ω–æ–≤–æ</button>
      </div>
    </div>
  </div>

  <!-- Canvas container -->
  <div id="gameContainer"></div>
</div>

<script>
/* ========= CONFIG & STATE ========= */
const CONFIG = {
  worldSize: 80,
  playerSpeed: 0.08,
  playerRadius: 0.6,
  sfxVol: 0.8,
  sensitivity: 1.0
};

let state = {
  running:false, paused:false, wave:0, score:0, enemies:[], drops:[],
  ammo:[12,30,8], reserve:[60,180,24], currentWeapon:0, playerHP:100, totalKilled:0,
  lastSpawnTime:0, enemiesToSpawn:0
};

/* ========= DOM references ========= */
const menu = document.getElementById('menu');
const gameContainer = document.getElementById('gameContainer');
const gameUI = document.getElementById('gameUI');
const modalSettings = document.getElementById('modalSettings');
const modalHelp = document.getElementById('modalHelp');
const results = document.getElementById('results');
const resultsText = document.getElementById('resultsText');

/* ========= Three.js globals ========= */
let scene, camera, renderer, clock;
let handsGroup, weaponGroup, muzzleLight;
let playerPos = new THREE.Vector3(0,1.6,0);
let playerVel = new THREE.Vector3(); // For joystick movement
let obstacles = []; // array of Box3 obstacles
let animationFrameId = null;

/* ========= Sound System ========= */
class SoundManager {
  constructor() {
    this.sounds = {};
    this.context = null;
    this.masterVolume = 1.0;
    this.init();
  }

  init() {
    try {
      this.context = new (window.AudioContext || window.webkitAudioContext)();
      this.createSounds();
    } catch (e) {
      console.warn("Web Audio API not supported:", e);
    }
  }

  createSounds() {
    // Shoot sounds for different weapons
    this.sounds.shoot_pistol = this.createShootSound(800, 0.1);
    this.sounds.shoot_auto = this.createShootSound(600, 0.08);
    this.sounds.shoot_shotgun = this.createShootSound(400, 0.15);
    
    // Other game sounds
    this.sounds.reload = this.createReloadSound();
    this.sounds.empty = this.createEmptySound();
    this.sounds.hit = this.createHitSound();
    this.sounds.death = this.createDeathSound();
    this.sounds.pickup = this.createPickupSound();
    this.sounds.heal = this.createHealSound();
    this.sounds.skill = this.createSkillSound();
    this.sounds.wave_start = this.createWaveStartSound();
    this.sounds.ui_click = this.createUIClickSound();
  }

  createShootSound(baseFreq, duration) {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(baseFreq, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(baseFreq * 0.5, this.context.currentTime + duration);
      
      gainNode.gain.setValueAtTime(0.3 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
      
      oscillator.type = 'sawtooth';
      oscillator.start();
      oscillator.stop(this.context.currentTime + duration);
    };
  }

  createReloadSound() {
    return () => {
      if (!this.context) return;
      
      const playBeep = (freq, time) => {
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.frequency.setValueAtTime(freq, this.context.currentTime + time);
        gainNode.gain.setValueAtTime(0.2 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime + time);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + time + 0.1);
        
        oscillator.type = 'sine';
        oscillator.start(this.context.currentTime + time);
        oscillator.stop(this.context.currentTime + time + 0.1);
      };
      
      playBeep(800, 0);
      playBeep(1000, 0.1);
      playBeep(1200, 0.2);
    };
  }

  createEmptySound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(200, this.context.currentTime);
      gainNode.gain.setValueAtTime(0.2 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
      
      oscillator.type = 'sine';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.3);
    };
  }

  createHitSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(150, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, this.context.currentTime + 0.2);
      
      gainNode.gain.setValueAtTime(0.3 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
      
      oscillator.type = 'sine';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.2);
    };
  }

  createDeathSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(300, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(100, this.context.currentTime + 0.4);
      
      gainNode.gain.setValueAtTime(0.4 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.4);
      
      oscillator.type = 'sawtooth';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.4);
    };
  }

  createPickupSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(400, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(800, this.context.currentTime + 0.2);
      
      gainNode.gain.setValueAtTime(0.2 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.2);
      
      oscillator.type = 'sine';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.2);
    };
  }

  createHealSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(600, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(800, this.context.currentTime + 0.3);
      
      gainNode.gain.setValueAtTime(0.2 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.3);
      
      oscillator.type = 'sine';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.3);
    };
  }

  createSkillSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(200, this.context.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(600, this.context.currentTime + 0.5);
      
      gainNode.gain.setValueAtTime(0.4 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.5);
      
      oscillator.type = 'sawtooth';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.5);
    };
  }

  createWaveStartSound() {
    return () => {
      if (!this.context) return;
      
      const playTone = (freq, time, duration) => {
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.frequency.setValueAtTime(freq, this.context.currentTime + time);
        gainNode.gain.setValueAtTime(0.3 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime + time);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + time + duration);
        
        oscillator.type = 'sine';
        oscillator.start(this.context.currentTime + time);
        oscillator.stop(this.context.currentTime + time + duration);
      };
      
      playTone(600, 0, 0.2);
      playTone(800, 0.1, 0.2);
      playTone(1000, 0.2, 0.3);
    };
  }

  createUIClickSound() {
    return () => {
      if (!this.context) return;
      
      const oscillator = this.context.createOscillator();
      const gainNode = this.context.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(this.context.destination);
      
      oscillator.frequency.setValueAtTime(800, this.context.currentTime);
      gainNode.gain.setValueAtTime(0.1 * this.masterVolume * CONFIG.sfxVol, this.context.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + 0.05);
      
      oscillator.type = 'sine';
      oscillator.start();
      oscillator.stop(this.context.currentTime + 0.05);
    };
  }

  play(soundName) {
    if (this.sounds[soundName] && CONFIG.sfxVol > 0) {
      // Resume audio context if it's suspended (required by some browsers)
      if (this.context && this.context.state === 'suspended') {
        this.context.resume();
      }
      this.sounds[soundName]();
    }
  }

  setVolume(volume) {
    this.masterVolume = volume;
  }
}

// Initialize sound manager
const soundManager = new SoundManager();

/* ========= Utilities ========= */
function $(id){return document.getElementById(id)}

/* ========= Safe DOM init (menu active) ========= */
function setupUI(){
  // Buttons
  $('startButton').addEventListener('click', ()=> {
    soundManager.play('ui_click');
    startGame();
  });
  $('settingsButton').addEventListener('click', ()=> { 
    soundManager.play('ui_click');
    modalSettings.classList.add('show'); 
  });
  $('closeSettings').addEventListener('click', ()=> { 
    soundManager.play('ui_click');
    modalSettings.classList.remove('show'); 
  });
  $('helpButton').addEventListener('click', ()=> { 
    soundManager.play('ui_click');
    modalHelp.classList.add('show'); 
  });
  $('closeHelp').addEventListener('click', ()=> { 
    soundManager.play('ui_click');
    modalHelp.classList.remove('show'); 
  });

  $('shootBtn').addEventListener('click', ()=> fire());
  $('skillBtn').addEventListener('click', ()=> useSkill());
  $('reloadBtn').addEventListener('click', ()=> reload());

  document.querySelectorAll('.wbtn').forEach(b=>{
    b.addEventListener('click', ()=> {
      soundManager.play('ui_click');
      switchWeapon(parseInt(b.dataset.w));
    });
  });

  $('resultsToMenu').addEventListener('click', ()=>{
    soundManager.play('ui_click');
    results.style.display='none';
    menu.style.display='flex';
    cleanupGame();
  });

  $('restartButton').addEventListener('click', ()=>{
    soundManager.play('ui_click');
    results.style.display='none';
    startGame();
  });

  // settings sliders
  $('sfxVol').addEventListener('input', (e)=> {
    CONFIG.sfxVol = parseFloat(e.target.value);
    soundManager.setVolume(CONFIG.sfxVol);
  });
  $('sens').addEventListener('input', (e)=> CONFIG.sensitivity = parseFloat(e.target.value));
}

/* ========= Start / Stop game ========= */
function startGame(){
  // Hide menu, enable canvas interactions
  menu.style.display='none';
  gameUI.style.pointerEvents='auto';
  gameUI.style.display='block';
  gameContainer.style.pointerEvents='auto'; // now canvas receives touch/mouse
  state.running = true; state.paused = false;
  state.wave = 0; state.score = 0; state.enemies=[]; state.drops=[];
  state.playerHP = 100; state.totalKilled = 0;
  state.ammo = [12,30,8]; state.reserve = [60,180,24]; state.currentWeapon = 0;

  // Initialize three if not yet
  initThree();
  updateHUD();
  highlightWeapon(0);
  nextWave();
  runLoop();
  soundManager.play('wave_start');
}

/* cleanup called when returning to menu */
function cleanupGame(){
  state.running = false;
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  // dispose renderer and scene
  if(renderer){
    try{
      renderer.forceContextLoss();
      if (renderer.domElement && renderer.domElement.parentNode) {
        renderer.domElement.parentNode.removeChild(renderer.domElement);
      }
    }catch(e){}
    renderer = null; scene = null; camera = null;
    gameContainer.innerHTML = '';
  }
  obstacles = [];
  playerVel.set(0, 0, 0);
}

/* ========= Three.js init only on start ========= */
function initThree(){
  // clear previous if any
  cleanupGame();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071017);
  clock = new THREE.Clock();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.copy(playerPos);

  renderer = new THREE.WebGLRenderer({antialias:true,alpha:false});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1.5,1.5));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  gameContainer.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xaaaaaa,0x222244,0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.9); 
  dir.position.set(10,20,10); 
  dir.castShadow = true;
  dir.shadow.mapSize.width = 2048;
  dir.shadow.mapSize.height = 2048;
  scene.add(dir);

  // ground
  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(CONFIG.worldSize*2,CONFIG.worldSize*2), 
    new THREE.MeshStandardMaterial({color:0x0f1216})
  );
  ground.rotation.x = -Math.PI/2; 
  ground.receiveShadow = true; 
  scene.add(ground);

  // fog
  scene.fog = new THREE.FogExp2(0x071017, 0.008);

  // environment: houses + trees (obstacles)
  createEnvironment();

  // hands & weapons (attach to camera)
  createHandsAndWeapons();

  window.addEventListener('resize', onResize);
}

/* ========= Environment creation with obstacles ========= */
function createEnvironment(){
  const houseMat = new THREE.MeshStandardMaterial({color:0x2b2b3a});
  const roofMat = new THREE.MeshStandardMaterial({color:0x553030});
  const treeMat = new THREE.MeshStandardMaterial({color:0x0f8b3a});

  function addHouse(x,z,w,d,h){
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), houseMat);
    mesh.position.set(x,h/2 - 0.1,z); 
    mesh.castShadow = true;
    scene.add(mesh);
    const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w,d)/1.2,1.6,4), roofMat);
    roof.position.set(x,mesh.position.y + h/2 + 0.8,z); 
    roof.rotation.y=Math.random()*Math.PI; 
    roof.castShadow = true;
    scene.add(roof);
    const b = new THREE.Box3().setFromObject(mesh);
    obstacles.push(b);
  }

  function addTree(x,z){
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.28,0.28,2,6), 
      new THREE.MeshStandardMaterial({color:0x5a3827})
    );
    trunk.position.set(x,0.9,z);
    trunk.castShadow = true;
    
    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.6,3,6), treeMat);
    leaves.position.set(0,1.6,0); 
    leaves.castShadow = true;
    trunk.add(leaves);
    scene.add(trunk);
    obstacles.push(new THREE.Box3().setFromObject(trunk));
  }

  // scatter houses and trees but not too close to origin
  for(let i=0;i<12;i++){
    let x = (Math.random()<0.5?-1:1)*(8 + Math.random()* (CONFIG.worldSize-12));
    let z = (Math.random()<0.5?-1:1)*(8 + Math.random()* (CONFIG.worldSize-12));
    addHouse(x,z, 3+Math.random()*4, 3+Math.random()*4, 3+Math.random()*3);
  }
  for(let i=0;i<40;i++){
    let x = (Math.random()<0.5?-1:1)*(2 + Math.random()* (CONFIG.worldSize-6));
    let z = (Math.random()<0.5?-1:1)*(2 + Math.random()* (CONFIG.worldSize-6));
    addTree(x,z);
  }

  // boundary: invisible boxes
  const ext = CONFIG.worldSize + 2;
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,-ext), new THREE.Vector3(-ext+2,50,ext)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(ext-2,-10,-ext), new THREE.Vector3(ext,50,ext)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,-ext), new THREE.Vector3(ext,50,-ext+2)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,ext-2), new THREE.Vector3(ext,50,ext)));
}

/* ========= Hands and weapons ========= */
function createHandsAndWeapons(){
  handsGroup = new THREE.Group();
  weaponGroup = new THREE.Group();

  const handMat = new THREE.MeshStandardMaterial({color:0xd7a98c});
  const hGeom = new THREE.BoxGeometry(0.24,0.36,0.24);
  const left = new THREE.Mesh(hGeom, handMat); left.position.set(-0.26,-0.36,-0.5);
  const right = new THREE.Mesh(hGeom, handMat); right.position.set(0.26,-0.36,-0.5);
  handsGroup.add(left); handsGroup.add(right);

  // pistol (index 0)
  const pistol = new THREE.Group();
  pistol.add(new THREE.Mesh(new THREE.BoxGeometry(0.6,0.18,0.12), new THREE.MeshStandardMaterial({color:0x222222})));
  pistol.position.set(0.12,-0.48,-0.9);

  // auto (index1)
  const auto = new THREE.Group();
  auto.add(new THREE.Mesh(new THREE.BoxGeometry(0.95,0.2,0.14), new THREE.MeshStandardMaterial({color:0x1a1a1a})));
  auto.position.set(0.15,-0.5,-0.95);

  // shotgun (index2)
  const shot = new THREE.Group();
  shot.add(new THREE.Mesh(new THREE.BoxGeometry(1.05,0.24,0.18), new THREE.MeshStandardMaterial({color:0x2a2a2a})));
  shot.position.set(0.12,-0.5,-0.95);

  weaponGroup.add(pistol); weaponGroup.add(auto); weaponGroup.add(shot);

  const fp = new THREE.Group(); fp.add(handsGroup); fp.add(weaponGroup);
  camera.add(fp);
  fp.position.set(0,0,0);

  muzzleLight = new THREE.PointLight(0xfff2c6,0,8);
  camera.add(muzzleLight);
  muzzleLight.position.set(0,-0.5,-1.2);

  updateWeaponVis();
}

/* weapon data */
const WEAPONS = [
  {name:'–ü–∏—Å—Ç–æ–ª–µ—Ç', dmg:18, rpm:350, mag:12, pellets:1, spread:0.03, range:60, reload:1.2},
  {name:'–ê–≤—Ç–æ–º–∞—Ç', dmg:10, rpm:800, mag:30, pellets:1, spread:0.06, range:70, reload:2.2},
  {name:'–î—Ä–æ–±–æ–≤–∏–∫', dmg:26, rpm:90, mag:8, pellets:6, spread:0.18, range:25, reload:2.6}
];

let lastShot = 0;
function fire(){
  if(!state.running || state.paused) return;
  const w = WEAPONS[state.currentWeapon];
  const now = performance.now();
  if(now - lastShot < 60000 / w.rpm) return;
  if(state.ammo[state.currentWeapon] <= 0){ 
    soundManager.play('empty'); 
    return; 
  }
  state.ammo[state.currentWeapon]--;
  lastShot = now;
  // muzzle flash & recoil
  muzzleLight.intensity = 2.5;
  setTimeout(()=> muzzleLight.intensity = 0, 80);
  camera.position.y -= 0.02; setTimeout(()=> camera.position.y += 0.02, 120);
  // raycasts
  for(let i=0;i<w.pellets;i++){
    const spreadX = (Math.random()-0.5) * w.spread;
    const spreadY = (Math.random()-0.5) * w.spread;
    const dir = new THREE.Vector3(0,0,-1);
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), spreadX);
    dir.applyAxisAngle(new THREE.Vector3(1,0,0), spreadY);
    dir.applyQuaternion(camera.quaternion);
    const ray = new THREE.Raycaster(camera.getWorldPosition(new THREE.Vector3()), dir.normalize(), 0.1, w.range);
    const hit = rayHitEnemy(ray);
    if(hit){
      hit.e.userData.hp -= w.dmg;
      hit.e.userData.hitTimer = 0.12;
      if(hit.e.userData.hp <= 0) killEnemy(hit.e);
      else {
        state.score += 2;
        soundManager.play('hit');
      }
    }
  }
  
  // Play appropriate shoot sound
  if (state.currentWeapon === 0) soundManager.play('shoot_pistol');
  else if (state.currentWeapon === 1) soundManager.play('shoot_auto');
  else if (state.currentWeapon === 2) soundManager.play('shoot_shotgun');
  
  updateHUD();
}

function rayHitEnemy(ray){
  let closest=null; let md=Infinity;
  for(const e of state.enemies){
    const box = new THREE.Box3().setFromObject(e.mesh);
    const p = ray.ray.intersectBox(box,new THREE.Vector3());
    if(p){
      const d = p.distanceTo(ray.ray.origin);
      if(d < md){ md=d; closest={e,d}; }
    }
  }
  return closest;
}

/* kill & drop */
function killEnemy(e){
  state.score += 10; state.totalKilled++;
  scene.remove(e.mesh);
  state.enemies = state.enemies.filter(x=>x!==e);
  // spawn drop sometimes
  if(Math.random()<0.45) spawnDrop(e.mesh.position.clone());
  soundManager.play('death');
  updateHUD();
}

function spawnDrop(pos){
  const kind = Math.random() < 0.6 ? 'ammo':'heal';
  const m = new THREE.Mesh(new THREE.SphereGeometry(0.24,6,6), new THREE.MeshStandardMaterial({color: kind==='ammo'?0x8be9ff:0xff9aa2}));
  m.position.copy(pos); m.position.y = 0.4; scene.add(m);
  state.drops.push({mesh:m,kind,t:0});
}

/* ========= Improved Zombie Models ========= */
function createZombieModel(type) {
  const group = new THREE.Group();
  
  // Different colors for zombie types
  let color;
  switch(type) {
    case 0: color = 0x8B4513; break; // Brown - basic zombie
    case 1: color = 0x556B2F; break; // Green - fast zombie
    case 2: color = 0x800000; break; // Maroon - heavy zombie
  }
  
  const bodyMat = new THREE.MeshStandardMaterial({ color: color });
  const limbMat = new THREE.MeshStandardMaterial({ color: 0x654321 }); // Darker for limbs
  
  // Body (cylinder)
  const bodyGeo = new THREE.CylinderGeometry(0.4, 0.3, 1.2, 8);
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.6;
  body.castShadow = true;
  group.add(body);
  
  // Head (cube for more zombie-like look)
  const headGeo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
  const head = new THREE.Mesh(headGeo, limbMat);
  head.position.y = 1.4;
  head.castShadow = true;
  group.add(head);
  
  // Arms
  const armGeo = new THREE.CylinderGeometry(0.1, 0.08, 0.8, 6);
  
  const leftArm = new THREE.Mesh(armGeo, limbMat);
  leftArm.position.set(-0.4, 0.6, 0);
  leftArm.rotation.z = Math.PI / 4;
  leftArm.castShadow = true;
  group.add(leftArm);
  
  const rightArm = new THREE.Mesh(armGeo, limbMat);
  rightArm.position.set(0.4, 0.6, 0);
  rightArm.rotation.z = -Math.PI / 4;
  rightArm.castShadow = true;
  group.add(rightArm);
  
  // Legs
  const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 0.8, 6);
  
  const leftLeg = new THREE.Mesh(legGeo, limbMat);
  leftLeg.position.set(-0.15, 0, 0);
  leftLeg.castShadow = true;
  group.add(leftLeg);
  
  const rightLeg = new THREE.Mesh(legGeo, limbMat);
  rightLeg.position.set(0.15, 0, 0);
  rightLeg.castShadow = true;
  group.add(rightLeg);
  
  // Scale based on type
  if (type === 2) { // Heavy zombie
    group.scale.set(1.3, 1.3, 1.3);
  }
  
  return group;
}

function spawnEnemy(type=0){
  const mesh = createZombieModel(type);
  mesh.position.set(
    (Math.random()<0.5?-1:1)*(20 + Math.random()*30), 
    0, 
    (Math.random()<0.5?-1:1)*(20 + Math.random()*30)
  );
  
  // Add some random rotation for variety
  mesh.rotation.y = Math.random() * Math.PI * 2;
  
  mesh.userData = {
    type, 
    hp: type===2?80:(type===1?18:35), 
    speed: type===2?0.02:(type===1?0.12:0.04), 
    hitTimer:0,
    swayOffset: Math.random() * Math.PI * 2
  };
  
  scene.add(mesh);
  state.enemies.push({mesh, userData:mesh.userData});
}

function updateEnemies(dt){
  for(const e of [...state.enemies]){
    const m = e.mesh; const u = m.userData;
    
    // Sway animation
    m.rotation.y = Math.sin(performance.now()*0.001 + u.swayOffset) * 0.25;
    
    // move toward player
    const dir = new THREE.Vector3().subVectors(playerPos, m.position); dir.y=0;
    const dist = dir.length();
    if(dist > 1.6){
      dir.normalize(); 
      m.position.addScaledVector(dir, u.speed);
      
      // Rotate to face player
      m.rotation.y = Math.atan2(dir.x, dir.z);
      
      // obstacle collision
      const mb = new THREE.Box3().setFromObject(m);
      for(const ob of obstacles){
        if(ob instanceof THREE.Box3){
          if(mb.intersectsBox(ob)){
            m.position.addScaledVector(dir, -u.speed*6);
          }
        }
      }
    } else {
      // attack chance
      if(Math.random() < 0.008) { damagePlayer(6 + (u.type===2?6:0)); }
    }
    
    // hit visual
    if(u.hitTimer){ 
      u.hitTimer -= dt; 
      m.traverse((child) => {
        if (child.isMesh) {
          child.material.emissive = new THREE.Color(0xff4444);
        }
      });
      if(u.hitTimer<=0){ 
        m.traverse((child) => {
          if (child.isMesh) {
            child.material.emissive = new THREE.Color(0x000000);
          }
        });
        u.hitTimer=0; 
      } 
    }
  }
}

/* ========= Player damage/heal ========= */
function damagePlayer(a){
  state.playerHP = Math.max(0, state.playerHP - a);
  soundManager.play('hit');
  if(state.playerHP <= 0) endGame();
  updateHUD();
}
function healPlayer(a){ 
  state.playerHP = Math.min(100, state.playerHP + a); 
  updateHUD(); 
  soundManager.play('heal'); 
}

/* ========= Drops logic ========= */
function updateDrops(dt){
  for(const d of [...state.drops]){
    d.t += dt; d.mesh.rotation.y += dt*1.2;
    if(d.mesh.position.distanceTo(playerPos) < 1.2){
      if(d.kind==='ammo'){ 
        const idx = state.currentWeapon; 
        const give = Math.floor(WEAPONS[idx].mag*1.5); 
        state.reserve[idx]+=give; 
        soundManager.play('pickup'); 
      } else { 
        healPlayer(18); 
      }
      scene.remove(d.mesh); 
      state.drops = state.drops.filter(x=>x!==d);
    } else if(d.t > 40){ 
      scene.remove(d.mesh); 
      state.drops = state.drops.filter(x=>x!==d); 
    }
  }
}

/* ========= Waves management ========= */
function nextWave(){
  state.wave++; 
  const base = 2 + Math.floor(state.wave*0.8);
  state.enemiesToSpawn = base + Math.floor(state.wave*0.6);
  state.lastSpawnTime = performance.now();
  updateHUD();
  soundManager.play('wave_start');
}

/* ========= HUD ========= */
function updateHUD(){
  $('healthFill').style.width = state.playerHP + '%';
  $('hpTxt').textContent = Math.round(state.playerHP);
  const w = WEAPONS[state.currentWeapon]; 
  $('ammoTxt').textContent = `${state.ammo[state.currentWeapon]}/${state.reserve[state.currentWeapon]} (${w.name})`;
  $('waveTxt').textContent = state.wave;
}

/* ========= Weapon & reload ========= */
function switchWeapon(i){
  state.currentWeapon = i; 
  updateWeaponVis(); 
  highlightWeapon(i);
  updateHUD();
}

function highlightWeapon(i){
  const wbtns = document.querySelectorAll('.wbtn');
  wbtns.forEach((btn, index) => {
    if (index === i) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  });
}

function updateWeaponVis(){
  if(!weaponGroup) return;
  weaponGroup.children.forEach((c,idx)=> c.visible = (idx===state.currentWeapon));
}

function reload(){
  const idx = state.currentWeapon; const mag = WEAPONS[idx].mag;
  if(state.ammo[idx] >= mag) return;
  const need = mag - state.ammo[idx]; const take = Math.min(need, state.reserve[idx]);
  if(take <= 0){ 
    soundManager.play('empty'); 
    return; 
  }
  state.reserve[idx] -= take; state.ammo[idx] += take;
  soundManager.play('reload'); 
  updateHUD();
}

/* ========= Skill ========= */
function useSkill(){
  if(!state.running) return;
  const r = 6;
  for(const e of state.enemies){
    const d = e.mesh.position.distanceTo(playerPos);
    if(d < r){
      const push = new THREE.Vector3().subVectors(e.mesh.position, playerPos).normalize();
      e.mesh.position.addScaledVector(push, 4);
      e.mesh.userData.hp -= 8; 
      if(e.mesh.userData.hp <= 0) killEnemy(e);
    }
  }
  soundManager.play('skill');
}

/* ========= Input: keyboard, mouse, touch joystick ========= */
let keys = {}; 
window.addEventListener('keydown', (e)=>{
  keys[e.code]=true; 
  if(e.code==='Space'){ fire(); e.preventDefault(); } 
  if(e.code==='Digit1') switchWeapon(0); 
  if(e.code==='Digit2') switchWeapon(1); 
  if(e.code==='Digit3') switchWeapon(2); 
  if(e.code==='KeyR') reload(); 
});
window.addEventListener('keyup', (e)=>{ keys[e.code]=false; });

/* Simple mouse look (drag on screen right half) */
let isDragging=false, dragId=null, prevX=0, prevY=0;
gameContainer.addEventListener('touchstart', (e)=>{
  for(const t of e.changedTouches){
    if(t.clientX > window.innerWidth/2){
      isDragging=true; dragId=t.identifier; prevX=t.clientX; prevY=t.clientY;
      e.preventDefault();
    }
  }
}, {passive:false});
gameContainer.addEventListener('touchmove', (e)=>{
  if(!isDragging) return;
  for(const t of e.touches){
    if(t.identifier===dragId){
      const dx = (t.clientX - prevX) * 0.01 * CONFIG.sensitivity;
      const dy = (t.clientY - prevY) * 0.01 * CONFIG.sensitivity;
      camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x - dy));
      camera.rotation.y -= dx;
      prevX=t.clientX; prevY=t.clientY;
      e.preventDefault();
      break;
    }
  }
}, {passive:false});
gameContainer.addEventListener('touchend', (e)=>{ 
  for(const t of e.changedTouches) {
    if(t.identifier===dragId) { 
      isDragging=false; 
      dragId=null; 
    }
  }
});

/* Desktop mouse */
let mouseDown=false; 
window.addEventListener('mousedown',(e)=>{ 
  if(e.button===0) {
    mouseDown=true;
    if (e.clientX > window.innerWidth/2) {
      e.preventDefault();
    }
  } 
});
window.addEventListener('mouseup',()=>mouseDown=false);
window.addEventListener('mousemove',(e)=>{
  if(mouseDown && e.clientX > window.innerWidth/2){
    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x - (e.movementY*0.002*CONFIG.sensitivity))); 
    camera.rotation.y -= e.movementX*0.002*CONFIG.sensitivity; 
  }
});

/* Fixed Touch joystick */
let joystickActive = false;
let joystickId = null;
let joystickBaseRect = null;
let joystickCenter = {x: 0, y: 0};
const joystickRadius = 42;

function setupJoystick() {
  const joystick = $('joystick');
  const handle = $('joyHandle');
  
  joystick.addEventListener('touchstart', (e) => {
    if (joystickActive) return;
    
    const touch = e.changedTouches[0];
    joystickActive = true;
    joystickId = touch.identifier;
    joystickBaseRect = joystick.getBoundingClientRect();
    joystickCenter.x = joystickBaseRect.left + joystickBaseRect.width / 2;
    joystickCenter.y = joystickBaseRect.top + joystickBaseRect.height / 2;
    
    updateJoystick(touch.clientX, touch.clientY);
    e.preventDefault();
  }, {passive: false});
  
  joystick.addEventListener('touchmove', (e) => {
    if (!joystickActive) return;
    
    for (let touch of e.touches) {
      if (touch.identifier === joystickId) {
        updateJoystick(touch.clientX, touch.clientY);
        e.preventDefault();
        break;
      }
    }
  }, {passive: false});
  
  joystick.addEventListener('touchend', (e) => {
    for (let touch of e.changedTouches) {
      if (touch.identifier === joystickId) {
        resetJoystick();
        break;
      }
    }
  });
  
  function updateJoystick(clientX, clientY) {
    const dx = clientX - joystickCenter.x;
    const dy = clientY - joystickCenter.y;
    const distance = Math.min(Math.sqrt(dx*dx + dy*dy), joystickRadius);
    const angle = Math.atan2(dy, dx);
    
    const handleX = Math.cos(angle) * distance;
    const handleY = Math.sin(angle) * distance;
    
    handle.style.transform = `translate(calc(-50% + ${handleX}px), calc(-50% + ${handleY}px))`;
    
    // Calculate movement vector relative to camera
    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
    
    // Normalize joystick input
    const inputX = handleX / joystickRadius;
    const inputY = handleY / joystickRadius;
    
    // Create movement vector
    playerVel.set(0, 0, 0);
    playerVel.addScaledVector(right, inputX * CONFIG.playerSpeed);
    playerVel.addScaledVector(forward, inputY * CONFIG.playerSpeed);
  }
  
  function resetJoystick() {
    joystickActive = false;
    joystickId = null;
    handle.style.transform = 'translate(-50%, -50%)';
    playerVel.set(0, 0, 0);
  }
}

/* ========= Main loop ========= */
let spawnAcc = 0;
function runLoop(){
  if (!state.running) return;
  
  animationFrameId = requestAnimationFrame(runLoop);
  const dt = clock.getDelta();
  
  // Player movement
  let moveVector = new THREE.Vector3();
  
  // Keyboard movement (desktop)
  if(window.innerWidth >= 900){
    if(keys['KeyW']||keys['ArrowUp']) moveVector.z -= 1;
    if(keys['KeyS']||keys['ArrowDown']) moveVector.z += 1;
    if(keys['KeyA']||keys['ArrowLeft']) moveVector.x -= 1;
    if(keys['KeyD']||keys['ArrowRight']) moveVector.x += 1;
    
    if(moveVector.length() > 0){
      moveVector.normalize().multiplyScalar(CONFIG.playerSpeed);
      // rotate by camera yaw
      const yaw = camera.rotation.y;
      const dx = moveVector.x * Math.cos(yaw) - moveVector.z * Math.sin(yaw);
      const dz = moveVector.x * Math.sin(yaw) + moveVector.z * Math.cos(yaw);
      playerVel.set(dx, 0, dz);
    } else {
      playerVel.set(0, 0, 0);
    }
  }
  
  // Apply movement with collision detection
  if (playerVel.length() > 0) {
    const candidate = playerPos.clone().add(playerVel);
    if (allowMove(candidate)) {
      playerPos.copy(candidate);
    }
  }
  
  camera.position.copy(playerPos);
  
  // Simple head bob when moving
  if (playerVel.length() > 0 && handsGroup) {
    const bob = Math.sin(performance.now() * 0.01) * 0.01;
    handsGroup.position.y = bob;
    weaponGroup.position.y = bob;
  } else if (handsGroup) {
    handsGroup.position.y = 0;
    weaponGroup.position.y = 0;
  }

  // spawn logic
  if(state.running && !state.paused){
    if(state.enemiesToSpawn > 0){
      spawnAcc += dt;
      if(spawnAcc > 0.6){
        spawnAcc = 0;
        const t = Math.random() < 0.12 + state.wave*0.01 ? 2 : (Math.random()<0.3?1:0);
        spawnEnemy(t);
        state.enemiesToSpawn--;
      }
    } else {
      if(state.enemies.length === 0 && performance.now() - state.lastSpawnTime > 1200){
        nextWave();
      }
    }
    updateEnemies(dt); 
    updateDrops(dt);
  }

  if (renderer && scene && camera) {
    renderer.render(scene, camera);
  }
}

/* ========= Collision check for player movement ========= */
function allowMove(candidate){
  // bounding box around player
  const b = new THREE.Box3(
    new THREE.Vector3(candidate.x - CONFIG.playerRadius, candidate.y-1, candidate.z - CONFIG.playerRadius),
    new THREE.Vector3(candidate.x + CONFIG.playerRadius, candidate.y+1, candidate.z + CONFIG.playerRadius)
  );
  
  for(const ob of obstacles){
    if(ob instanceof THREE.Box3){
      if(b.intersectsBox(ob)) return false;
    }
  }
  
  if(Math.abs(candidate.x) > CONFIG.worldSize || Math.abs(candidate.z) > CONFIG.worldSize) return false;
  return true;
}

/* ========= End game & results ========= */
function endGame(){
  state.running = false;
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  
  resultsText.innerHTML = `
    <div style="margin:10px 0;">‚≠ê –û—á–∫–∏: ${state.score}</div>
    <div style="margin:10px 0;">üéØ –£–±–∏–π—Å—Ç–≤: ${state.totalKilled}</div>
    <div style="margin:10px 0;">üåä –í–æ–ª–Ω –ø—Ä–æ–π–¥–µ–Ω–æ: ${state.wave}</div>
  `;
  
  results.style.display='flex';
  gameContainer.style.pointerEvents='none';
  gameUI.style.pointerEvents='none';
  
  // try send to TG
  try{ 
    if(window.Telegram && Telegram.WebApp){ 
      Telegram.WebApp.sendData(JSON.stringify({
        score:state.score,
        kills:state.totalKilled,
        wave:state.wave
      })); 
    } 
  }catch(e){}
}

/* ========= Resize ========= */
function onResize(){ 
  if(camera && renderer){ 
    camera.aspect = window.innerWidth/window.innerHeight; 
    camera.updateProjectionMatrix(); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
  } 
}

/* ========= Startup ========= */
window.addEventListener('load', ()=> {
  // Ensure menu/canvas ordering correct:
  // menu z-index is higher; canvas pointer-events disabled until startGame
  gameContainer.style.pointerEvents = 'none';
  gameUI.style.display = 'block'; 
  gameUI.style.pointerEvents = 'none';
  $('joystick').style.display = (window.innerWidth < 900) ? 'flex' : 'none';

  setupUI();
  setupJoystick();

  // Weapon hotkeys UI highlight
  document.addEventListener('keydown', (e)=>{ 
    if(e.code==='Digit1') highlightWeapon(0); 
    if(e.code==='Digit2') highlightWeapon(1); 
    if(e.code==='Digit3') highlightWeapon(2); 
  });

  console.log("UI ready");
  try{ 
    if(window.Telegram && Telegram.WebApp){ 
      Telegram.WebApp.ready(); 
      Telegram.WebApp.expand(); 
      console.log("Telegram WebApp ready"); 
    } 
  }catch(e){}
});
</script>
</body>
</html>
