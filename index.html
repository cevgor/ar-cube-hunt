<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Z.E.R.O.: Last Breach</title>

<!-- Telegram + Three.js -->
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
:root{
  --neon:#00ffea; --accent:#ff6b6b; --bg:#05060a;
}
*{box-sizing:border-box;margin:0;padding:0;user-select:none;-webkit-user-select:none}
html,body,#app{height:100%}
body{background:linear-gradient(180deg,#030305,#0b0b10);font-family:Arial,Helvetica,sans-serif;color:var(--neon);overflow:hidden}
#app{position:relative;width:100vw;height:100vh}

/* Menu sits on top */
#menu{
  position:absolute;inset:0;display:flex;align-items:center;justify-content:center;
  z-index:4000; /* high - menu always clickable */
  pointer-events:auto;
}
.menu-overlay{
  width:min(820px,94%);background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));
  border:1px solid rgba(0,255,234,0.07);padding:28px;border-radius:14px;text-align:center;backdrop-filter:blur(6px)
}
.menu-title{font-size:44px;letter-spacing:3px;background:linear-gradient(90deg,var(--neon),#5cc9ff);-webkit-background-clip:text;color:transparent;margin-bottom:6px}
.menu-sub{color:#bffdf7;opacity:0.9;margin-bottom:12px}
.menu-row{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}
.btn{padding:12px 18px;border-radius:10px;background:linear-gradient(180deg,#0d1116,#081018);border:1px solid rgba(0,255,234,0.06);color:var(--neon);cursor:pointer;font-weight:700}
.btn.secondary{color:#ffb3d6;border-color:rgba(255,107,107,0.12)}
.btn.small{padding:8px 10px;font-size:14px}

/* Modals */
.modal{display:none;position:fixed;inset:0;align-items:center;justify-content:center;z-index:4500}
.modal.show{display:flex}
.modal .card{width:min(720px,94%);background:#07090b;padding:18px;border-radius:12px;border:1px solid rgba(0,255,234,0.06)}

/* Game UI - sits above canvas but below menu */
#gameUI{position:absolute;top:0;left:0;width:100%;height:100%;z-index:3000;pointer-events:none}
.panel{background:rgba(0,0,0,0.6);padding:10px;border-radius:10px;border:1px solid rgba(0,255,234,0.04);display:flex;gap:8px;align-items:center;backdrop-filter:blur(6px)}
#hud{position:absolute;left:12px;top:12px;display:flex;flex-direction:column;gap:10px;pointer-events:none}
#healthBar{width:220px;height:14px;background:#111;border-radius:8px;overflow:hidden}
#healthFill{height:100%;width:100%;background:linear-gradient(90deg,#ff6b6b,#ff2b2b);transition:width 0.12s linear}

/* Bottom controls (touch) */
#bottomUI{position:absolute;right:12px;bottom:12px;display:flex;flex-direction:column;gap:8px;pointer-events:auto;z-index:3200}
.weaponButtons{display:flex;gap:8px}
.wbtn{padding:8px 10px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(0,255,234,0.04);color:var(--neon);font-weight:700;cursor:pointer}

/* Joystick */
#joystick{position:absolute;left:18px;bottom:18px;width:120px;height:120px;border-radius:50%;background:rgba(0,255,234,0.04);display:none;align-items:center;justify-content:center;pointer-events:auto;z-index:3200}
#joyHandle{width:56px;height:56px;border-radius:50%;background:rgba(0,255,234,0.14);transform:translate(-50%,-50%);position:relative;left:50%;top:50%}

/* Crosshair */
#crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:28px;height:28px;pointer-events:none;z-index:3100}
.crossV{position:absolute;left:50%;transform:translateX(-50%);width:3px;height:28px;background:var(--neon)}
.crossH{position:absolute;top:50%;transform:translateY(-50%);height:3px;width:28px;background:var(--neon)}

/* gameContainer (canvas holder) - below menu, above body */
#gameContainer{position:absolute;inset:0;z-index:2000;pointer-events:none} /* pointer-events none until game starts */

/* Results screen */
#results{position:absolute;inset:0;display:none;z-index:4200;align-items:center;justify-content:center;background:rgba(0,0,0,0.85)}
.results .card{padding:30px;border-radius:12px;background:linear-gradient(180deg,#07080a,#0b0b10);border:1px solid rgba(0,255,234,0.06);color:var(--neon)}

/* small responsive */
@media (max-width:900px){
  #joystick{display:flex}
  #crosshair{display:block}
}
</style>
</head>
<body>
<div id="app">
  <!-- Menu (top) -->
  <div id="menu">
    <div class="menu-overlay">
      <div class="menu-title">Z.E.R.O.</div>
      <div class="menu-sub">LAST BREACH ‚Äî prototype</div>
      <div class="menu-row">
        <button id="startButton" class="btn">üéÆ –ù–ê–ß–ê–¢–¨ –ú–ò–°–°–ò–Æ</button>
        <button id="settingsButton" class="btn">‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button id="helpButton" class="btn secondary">üìñ –û–ë–£–ß–ï–ù–ò–ï</button>
        <button id="resumeButton" class="btn small" style="display:none">üîô –í–ï–†–ù–£–¢–¨–°–Ø</button>
      </div>
      <div style="margin-top:12px;color:#98fff8;opacity:0.9">–ù–∏–∑–∫–æ–ø–æ–ª–∏–≥–æ–Ω–∞–ª—å–Ω–∞—è –∞—Ä–µ–Ω–∞ ‚Äî –¥–æ–º–∞/–¥–µ—Ä–µ–≤—å—è, –≤–æ–ª–Ω—ã –∑–æ–º–±–∏, 3 —Ç–∏–ø–∞ –æ—Ä—É–∂–∏—è</div>
    </div>
  </div>

  <!-- Modals -->
  <div id="modalSettings" class="modal">
    <div class="card">
      <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
      <div style="margin:10px 0;">–ì—Ä–æ–º–∫–æ—Å—Ç—å: <input id="sfxVol" type="range" min="0" max="1" step="0.01" value="0.8"></div>
      <div style="margin:10px 0;">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: <input id="sens" type="range" min="0.2" max="2" step="0.05" value="1"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px;"><button id="closeSettings" class="btn">–ó–∞–∫—Ä—ã—Ç—å</button></div>
    </div>
  </div>

  <div id="modalHelp" class="modal">
    <div class="card">
      <h3>–û–±—É—á–µ–Ω–∏–µ</h3>
      <p>–î–≤–∏–∂–µ–Ω–∏–µ: WASD / —Å—Ç—Ä–µ–ª–∫–∏ –∏–ª–∏ –¥–∂–æ–π—Å—Ç–∏–∫ (–Ω–∞ –º–æ–±). –°—Ç—Ä–µ–ª—å–±–∞: –º—ã—à—å/–∫–Ω–æ–ø–∫–∞. –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ: 1/2/3.</p>
      <div style="display:flex;justify-content:flex-end"><button id="closeHelp" class="btn">–ü–æ–Ω—è—Ç–Ω–æ</button></div>
    </div>
  </div>

  <!-- Game UI -->
  <div id="gameUI">
    <div id="hud">
      <div class="panel"><div style="min-width:80px">‚ù§Ô∏è –ó–î–û–†–û–í–¨–ï</div>
        <div id="healthBar"><div id="healthFill"></div></div>
        <div id="hpTxt" style="min-width:60px;text-align:right;font-weight:700">100</div>
      </div>
      <div class="panel">–ü–∞—Ç—Ä–æ–Ω—ã: <div id="ammoTxt" style="margin-left:8px;font-weight:700">‚Äî</div></div>
      <div class="panel">–í–æ–ª–Ω–∞: <div id="waveTxt" style="margin-left:8px;font-weight:700">0</div></div>
    </div>

    <div id="bottomUI">
      <div class="weaponButtons">
        <button class="wbtn" data-w="0">1 –ü–∏—Å—Ç–æ–ª–µ—Ç</button>
        <button class="wbtn" data-w="1">2 –ê–≤—Ç–æ</button>
        <button class="wbtn" data-w="2">3 –î—Ä–æ–±–æ–≤–∏–∫</button>
      </div>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button id="shootBtn" class="btn">üî´</button>
        <button id="skillBtn" class="btn secondary">‚ö° –ò–º–ø—É–ª—å—Å</button>
        <button id="reloadBtn" class="btn small">‚Üª –ü–µ—Ä–µ–∑–∞—Ä—è–¥</button>
      </div>
    </div>

    <div id="joystick"><div id="joyHandle"></div></div>
    <div id="crosshair"><div class="crossV crossV"></div><div class="crossH crossH"></div></div>
  </div>

  <!-- Results -->
  <div id="results"><div class="results card"><h2>–†–µ–∑—É–ª—å—Ç–∞—Ç—ã</h2><div id="resultsText"></div><div style="margin-top:12px"><button id="resultsToMenu" class="btn">–í –º–µ–Ω—é</button></div></div></div>

  <!-- Canvas container -->
  <div id="gameContainer"></div>
</div>

<script>
/* ========= CONFIG & STATE ========= */
const CONFIG = {
  worldSize: 80,
  playerSpeed: 0.08,
  playerRadius: 0.6,
  sfxVol: 0.8,
  sensitivity: 1.0
};

let state = {
  running:false, paused:false, wave:0, score:0, enemies:[], drops:[],
  ammo:[12,30,8], reserve:[60,180,24], currentWeapon:0, playerHP:100, totalKilled:0,
  lastSpawnTime:0, enemiesToSpawn:0
};

/* ========= DOM references ========= */
const menu = document.getElementById('menu');
const gameContainer = document.getElementById('gameContainer');
const gameUI = document.getElementById('gameUI');
const modalSettings = document.getElementById('modalSettings');
const modalHelp = document.getElementById('modalHelp');
const results = document.getElementById('results');
const resultsText = document.getElementById('resultsText');

/* ========= Three.js globals ========= */
let scene, camera, renderer, clock;
let handsGroup, weaponGroup, muzzleLight;
let playerPos = new THREE.Vector3(0,1.6,0);
let obstacles = []; // array of Box3 obstacles
let animationFrameId = null;

/* ========= Utilities ========= */
function $(id){return document.getElementById(id)}
function playTone(freq,dur=0.07,vol=0.02){
  try{
    const ctx = window.__sfxCtx || (window.__sfxCtx = new (window.AudioContext||window.webkitAudioContext)());
    const o = ctx.createOscillator(); const g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    g.gain.value = vol * (CONFIG.sfxVol ?? 0.8);
    o.frequency.value = freq; o.type='sine';
    o.start(); o.stop(ctx.currentTime + dur);
  }catch(e){}
}

/* ========= Safe DOM init (menu active) ========= */
function setupUI(){
  // Buttons
  $('startButton').addEventListener('click', ()=> {
    startGame();
  });
  $('settingsButton').addEventListener('click', ()=> { modalSettings.classList.add('show'); });
  $('closeSettings').addEventListener('click', ()=> { modalSettings.classList.remove('show'); });
  $('helpButton').addEventListener('click', ()=> { modalHelp.classList.add('show'); });
  $('closeHelp').addEventListener('click', ()=> { modalHelp.classList.remove('show'); });

  $('shootBtn').addEventListener('click', ()=> fire());
  $('skillBtn').addEventListener('click', ()=> useSkill());
  $('reloadBtn').addEventListener('click', ()=> reload());

  document.querySelectorAll('.wbtn').forEach(b=>{
    b.addEventListener('click', ()=> switchWeapon(parseInt(b.dataset.w)));
  });

  $('resultsToMenu').addEventListener('click', ()=>{
    results.style.display='none';
    menu.style.display='flex';
  });

  // settings sliders
  $('sfxVol').addEventListener('input', (e)=> CONFIG.sfxVol = parseFloat(e.target.value));
  $('sens').addEventListener('input', (e)=> CONFIG.sensitivity = parseFloat(e.target.value));
}

/* ========= Start / Stop game ========= */
function startGame(){
  // Hide menu, enable canvas interactions
  menu.style.display='none';
  gameUI.style.pointerEvents='auto';
  gameUI.style.display='block';
  gameContainer.style.pointerEvents='auto'; // now canvas receives touch/mouse
  state.running = true; state.paused = false;
  state.wave = 0; state.score = 0; state.enemies=[]; state.drops=[];
  state.playerHP = 100; state.totalKilled = 0;
  state.ammo = [12,30,8]; state.reserve = [60,180,24]; state.currentWeapon = 0;

  // Initialize three if not yet
  initThree();
  updateHUD();
  nextWave();
  runLoop();
  playTone(440,0.06,0.04);
}

/* cleanup called when returning to menu */
function cleanupGame(){
  state.running = false;
  cancelAnimationFrame(animationFrameId);
  animationFrameId = null;
  // dispose renderer and scene
  if(renderer){
    try{
      renderer.forceContextLoss();
      renderer.domElement.remove();
    }catch(e){}
    renderer = null; scene = null; camera = null;
    gameContainer.innerHTML = '';
  }
  obstacles = [];
}

/* ========= Three.js init only on start ========= */
function initThree(){
  // clear previous if any
  cleanupGame();

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x071017);
  clock = new THREE.Clock();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.copy(playerPos);

  renderer = new THREE.WebGLRenderer({antialias:true,alpha:false});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1.5,1.5));
  renderer.shadowMap.enabled = true;
  gameContainer.appendChild(renderer.domElement);

  const hemi = new THREE.HemisphereLight(0xaaaaaa,0x222244,0.6); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xffffff,0.9); dir.position.set(10,20,10); scene.add(dir);

  // ground
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.worldSize*2,CONFIG.worldSize*2), new THREE.MeshStandardMaterial({color:0x0f1216}));
  ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

  // fog
  scene.fog = new THREE.FogExp2(0x071017, 0.008);

  // environment: houses + trees (obstacles)
  createEnvironment();

  // hands & weapons (attach to camera)
  createHandsAndWeapons();

  window.addEventListener('resize', onResize);
}

/* ========= Environment creation with obstacles ========= */
function createEnvironment(){
  const houseMat = new THREE.MeshStandardMaterial({color:0x2b2b3a});
  const roofMat = new THREE.MeshStandardMaterial({color:0x553030});
  const treeMat = new THREE.MeshStandardMaterial({color:0x0f8b3a});

  function addHouse(x,z,w,d,h){
    const mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), houseMat);
    mesh.position.set(x,h/2 - 0.1,z); scene.add(mesh);
    const roof = new THREE.Mesh(new THREE.ConeGeometry(Math.max(w,d)/1.2,1.6,4), roofMat);
    roof.position.set(x,mesh.position.y + h/2 + 0.8,z); roof.rotation.y=Math.random()*Math.PI; scene.add(roof);
    const b = new THREE.Box3().setFromObject(mesh);
    obstacles.push(b);
  }

  function addTree(x,z){
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.28,0.28,2,6), new THREE.MeshStandardMaterial({color:0x5a3827}));
    trunk.position.set(x,0.9,z);
    const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.6,3,6), treeMat);
    leaves.position.set(0,1.6,0); trunk.add(leaves);
    scene.add(trunk);
    obstacles.push(new THREE.Box3().setFromObject(trunk));
  }

  // scatter houses and trees but not too close to origin
  for(let i=0;i<12;i++){
    let x = (Math.random()<0.5?-1:1)*(8 + Math.random()* (CONFIG.worldSize-12));
    let z = (Math.random()<0.5?-1:1)*(8 + Math.random()* (CONFIG.worldSize-12));
    addHouse(x,z, 3+Math.random()*4, 3+Math.random()*4, 3+Math.random()*3);
  }
  for(let i=0;i<40;i++){
    let x = (Math.random()<0.5?-1:1)*(2 + Math.random()* (CONFIG.worldSize-6));
    let z = (Math.random()<0.5?-1:1)*(2 + Math.random()* (CONFIG.worldSize-6));
    addTree(x,z);
  }

  // boundary: invisible boxes
  const ext = CONFIG.worldSize + 2;
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,-ext), new THREE.Vector3(-ext+2,50,ext)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(ext-2,-10,-ext), new THREE.Vector3(ext,50,ext)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,-ext), new THREE.Vector3(ext,50,-ext+2)));
  obstacles.push(new THREE.Box3(new THREE.Vector3(-ext,-10,ext-2), new THREE.Vector3(ext,50,ext)));
}

/* ========= Hands and weapons ========= */
function createHandsAndWeapons(){
  handsGroup = new THREE.Group();
  weaponGroup = new THREE.Group();

  const handMat = new THREE.MeshStandardMaterial({color:0xd7a98c});
  const hGeom = new THREE.BoxGeometry(0.24,0.36,0.24);
  const left = new THREE.Mesh(hGeom, handMat); left.position.set(-0.26,-0.36,-0.5);
  const right = new THREE.Mesh(hGeom, handMat); right.position.set(0.26,-0.36,-0.5);
  handsGroup.add(left); handsGroup.add(right);

  // pistol (index 0)
  const pistol = new THREE.Group();
  pistol.add(new THREE.Mesh(new THREE.BoxGeometry(0.6,0.18,0.12), new THREE.MeshStandardMaterial({color:0x222222})));
  pistol.position.set(0.12,-0.48,-0.9);

  // auto (index1)
  const auto = new THREE.Group();
  auto.add(new THREE.Mesh(new THREE.BoxGeometry(0.95,0.2,0.14), new THREE.MeshStandardMaterial({color:0x1a1a1a})));
  auto.position.set(0.15,-0.5,-0.95);

  // shotgun (index2)
  const shot = new THREE.Group();
  shot.add(new THREE.Mesh(new THREE.BoxGeometry(1.05,0.24,0.18), new THREE.MeshStandardMaterial({color:0x2a2a2a})));
  shot.position.set(0.12,-0.5,-0.95);

  weaponGroup.add(pistol); weaponGroup.add(auto); weaponGroup.add(shot);

  const fp = new THREE.Group(); fp.add(handsGroup); fp.add(weaponGroup);
  camera.add(fp);
  fp.position.set(0,0,0);

  muzzleLight = new THREE.PointLight(0xfff2c6,0,8);
  camera.add(muzzleLight);
  muzzleLight.position.set(0,-0.5,-1.2);

  updateWeaponVis();
}

/* weapon data */
const WEAPONS = [
  {name:'–ü–∏—Å—Ç–æ–ª–µ—Ç', dmg:18, rpm:350, mag:12, pellets:1, spread:0.03, range:60, reload:1.2},
  {name:'–ê–≤—Ç–æ–º–∞—Ç', dmg:10, rpm:800, mag:30, pellets:1, spread:0.06, range:70, reload:2.2},
  {name:'–î—Ä–æ–±–æ–≤–∏–∫', dmg:26, rpm:90, mag:8, pellets:6, spread:0.18, range:25, reload:2.6}
];

let lastShot = 0;
function fire(){
  if(!state.running || state.paused) return;
  const w = WEAPONS[state.currentWeapon];
  const now = performance.now();
  if(now - lastShot < 60000 / w.rpm) return;
  if(state.ammo[state.currentWeapon] <= 0){ playTone(200,0.08,0.02); return; }
  state.ammo[state.currentWeapon]--;
  lastShot = now;
  // muzzle flash & recoil
  muzzleLight.intensity = 2.5;
  setTimeout(()=> muzzleLight.intensity = 0, 80);
  camera.position.y -= 0.02; setTimeout(()=> camera.position.y += 0.02, 120);
  // raycasts
  for(let i=0;i<w.pellets;i++){
    const spreadX = (Math.random()-0.5) * w.spread;
    const spreadY = (Math.random()-0.5) * w.spread;
    const dir = new THREE.Vector3(0,0,-1);
    dir.applyAxisAngle(new THREE.Vector3(0,1,0), spreadX);
    dir.applyAxisAngle(new THREE.Vector3(1,0,0), spreadY);
    dir.applyQuaternion(camera.quaternion);
    const ray = new THREE.Raycaster(camera.getWorldPosition(new THREE.Vector3()), dir.normalize(), 0.1, w.range);
    const hit = rayHitEnemy(ray);
    if(hit){
      hit.e.userData.hp -= w.dmg;
      hit.e.userData.hitTimer = 0.12;
      if(hit.e.userData.hp <= 0) killEnemy(hit.e);
      else state.score += 2;
    }
  }
  playTone(900,0.05,0.04);
  updateHUD();
}

function rayHitEnemy(ray){
  let closest=null; let md=Infinity;
  for(const e of state.enemies){
    const box = new THREE.Box3().setFromObject(e.mesh);
    const p = ray.ray.intersectBox(box,new THREE.Vector3());
    if(p){
      const d = p.distanceTo(ray.ray.origin);
      if(d < md){ md=d; closest={e,d}; }
    }
  }
  return closest;
}

/* kill & drop */
function killEnemy(e){
  state.score += 10; state.totalKilled++;
  scene.remove(e.mesh);
  state.enemies = state.enemies.filter(x=>x!==e);
  // spawn drop sometimes
  if(Math.random()<0.45) spawnDrop(e.mesh.position.clone());
  playTone(80,0.12,0.06);
  updateHUD();
}

function spawnDrop(pos){
  const kind = Math.random() < 0.6 ? 'ammo':'heal';
  const m = new THREE.Mesh(new THREE.SphereGeometry(0.24,6,6), new THREE.MeshStandardMaterial({color: kind==='ammo'?0x8be9ff:0xff9aa2}));
  m.position.copy(pos); m.position.y = 0.4; scene.add(m);
  state.drops.push({mesh:m,kind,t:0});
}

/* ========= Enemies ========= */
function spawnEnemy(type=0){
  const color = type===0?0xff6b6b:(type===1?0xffd56b:0xb46bff);
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(type===2?1.05:0.85,8,8), new THREE.MeshStandardMaterial({color}));
  mesh.position.set((Math.random()<0.5?-1:1)*(20 + Math.random()*30), 0.6, (Math.random()<0.5?-1:1)*(20 + Math.random()*30));
  mesh.userData = {type, hp: type===2?80:(type===1?18:35), speed: type===2?0.02:(type===1?0.12:0.04), hitTimer:0};
  scene.add(mesh);
  state.enemies.push({mesh, userData:mesh.userData});
}

function updateEnemies(dt){
  for(const e of [...state.enemies]){
    const m = e.mesh; const u = m.userData;
    m.rotation.y = Math.sin(performance.now()*0.001 + (m.userData._sway||0)) * 0.25;
    // move toward player
    const dir = new THREE.Vector3().subVectors(playerPos, m.position); dir.y=0;
    const dist = dir.length();
    if(dist > 1.6){
      dir.normalize(); m.position.addScaledVector(dir, u.speed);
      // obstacle collision simple: if inside obstacle push back
      const mb = new THREE.Box3().setFromObject(m);
      for(const ob of obstacles){
        if(ob instanceof THREE.Box3){
          if(mb.intersectsBox(ob)){
            m.position.addScaledVector(dir, -u.speed*6);
          }
        }
      }
    } else {
      // attack chance
      if(Math.random() < 0.008) { damagePlayer(6 + (u.type===2?6:0)); }
    }
    // hit visual
    if(u.hitTimer){ u.hitTimer -= dt; m.material.emissive = new THREE.Color(0xffaaaa); if(u.hitTimer<=0){ m.material.emissive.set(0x000000); u.hitTimer=0 } }
  }
}

/* ========= Player damage/heal ========= */
function damagePlayer(a){
  state.playerHP = Math.max(0, state.playerHP - a);
  playTone(140,0.06,0.06);
  if(state.playerHP <= 0) endGame();
  updateHUD();
}
function healPlayer(a){ state.playerHP = Math.min(100, state.playerHP + a); updateHUD(); playTone(720,0.06,0.04); }

/* ========= Drops logic ========= */
function updateDrops(dt){
  for(const d of [...state.drops]){
    d.t += dt; d.mesh.rotation.y += dt*1.2;
    if(d.mesh.position.distanceTo(playerPos) < 1.2){
      if(d.kind==='ammo'){ const idx = state.currentWeapon; const give = Math.floor(WEAPONS[idx].mag*1.5); state.reserve[idx]+=give; playTone(1200,0.06,0.04); }
      else { healPlayer(18) }
      scene.remove(d.mesh); state.drops = state.drops.filter(x=>x!==d);
    } else if(d.t > 40){ scene.remove(d.mesh); state.drops = state.drops.filter(x=>x!==d); }
  }
}

/* ========= Waves management ========= */
function nextWave(){
  state.wave++; const base = 2 + Math.floor(state.wave*0.8);
  state.enemiesToSpawn = base + Math.floor(state.wave*0.6);
  state.lastSpawnTime = performance.now();
  updateHUD();
}

/* ========= HUD ========= */
function updateHUD(){
  $('healthFill').style.width = state.playerHP + '%';
  $('hpTxt').textContent = Math.round(state.playerHP);
  const w = WEAPONS[state.currentWeapon]; $('ammoTxt').textContent = `${state.ammo[state.currentWeapon]}/${state.reserve[state.currentWeapon]} (${w.name})`;
  $('waveTxt').textContent = state.wave;
}

/* ========= Weapon & reload ========= */
function switchWeapon(i){
  state.currentWeapon = i; updateWeaponVis(); playTone(220,0.04,0.03); updateHUD();
}
function updateWeaponVis(){
  if(!weaponGroup) return;
  weaponGroup.children.forEach((c,idx)=> c.visible = (idx===state.currentWeapon));
}
function reload(){
  const idx = state.currentWeapon; const mag = WEAPONS[idx].mag;
  if(state.ammo[idx] >= mag) return;
  const need = mag - state.ammo[idx]; const take = Math.min(need, state.reserve[idx]);
  if(take <= 0){ playTone(200,0.06,0.02); return; }
  state.reserve[idx] -= take; state.ammo[idx] += take;
  playTone(440,0.12,0.04); updateHUD();
}

/* ========= Skill ========= */
function useSkill(){
  if(!state.running) return;
  const r = 6;
  for(const e of state.enemies){
    const d = e.mesh.position.distanceTo(playerPos);
    if(d < r){
      const push = new THREE.Vector3().subVectors(e.mesh.position, playerPos).normalize();
      e.mesh.position.addScaledVector(push, 4);
      e.mesh.userData.hp -= 8; if(e.mesh.userData.hp <= 0) killEnemy(e);
    }
  }
  playTone(560,0.12,0.06);
}

/* ========= Ray-based utility already above ========= */

/* ========= Input: keyboard, mouse, touch joystick ========= */
let keys = {}; window.addEventListener('keydown', (e)=>{ keys[e.code]=true; if(e.code==='Space'){ fire(); e.preventDefault() } if(e.code==='Digit1') switchWeapon(0); if(e.code==='Digit2') switchWeapon(1); if(e.code==='Digit3') switchWeapon(2); if(e.code==='KeyR') reload(); });
window.addEventListener('keyup', (e)=>{ keys[e.code]=false });

/* Simple mouse look (drag on screen right half) */
let isDragging=false, dragId=null, prevX=0, prevY=0;
gameContainer.addEventListener('touchstart', (e)=>{
  for(const t of e.changedTouches){
    if(t.clientX > window.innerWidth/2){
      isDragging=true; dragId=t.identifier; prevX=t.clientX; prevY=t.clientY;
    }
  }
}, {passive:false});
gameContainer.addEventListener('touchmove', (e)=>{
  if(!isDragging) return;
  for(const t of e.touches){
    if(t.identifier===dragId){
      const dx = (t.clientX - prevX) * 0.01 * CONFIG.sensitivity;
      const dy = (t.clientY - prevY) * 0.01 * CONFIG.sensitivity;
      camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x - dy));
      camera.rotation.y -= dx;
      prevX=t.clientX; prevY=t.clientY;
      break;
    }
  }
}, {passive:false});
gameContainer.addEventListener('touchend', (e)=>{ for(const t of e.changedTouches) if(t.identifier===dragId) { isDragging=false; dragId=null } });

/* Desktop mouse */
let mouseDown=false; window.addEventListener('mousedown',(e)=>{ if(e.button===0) mouseDown=true; });
window.addEventListener('mouseup',()=>mouseDown=false);
window.addEventListener('mousemove',(e)=>{ if(mouseDown){ camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x - (e.movementY*0.002*CONFIG.sensitivity))); camera.rotation.y -= e.movementX*0.002*CONFIG.sensitivity } });

/* Touch joystick */
(function joystickInit(){
  const joystick = $('joystick'), handle = $('joyHandle');
  let id=null, base=null, center={x:0,y:0}, radius=42;
  function start(t){ id=t.identifier;base=joystick.getBoundingClientRect(); center.x=base.left+base.width/2; center.y=base.top+base.height/2; move(t.clientX,t.clientY) }
  function move(cx,cy){ const dx = cx-center.x; const dy = cy-center.y; const dist = Math.min(Math.sqrt(dx*dx+dy*dy),radius); const ang = Math.atan2(dy,dx); const hx = Math.cos(ang)*dist; const hy = Math.sin(ang)*dist; handle.style.transform=`translate(calc(-50% + ${hx}px), calc(-50% + ${hy}px))`; // set player pos change in local space (camera forward)
    // compute forward vector from camera
    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion);
    const mv = new THREE.Vector3(); mv.addScaledVector(right, (hx/radius) * CONFIG.playerSpeed); mv.addScaledVector(forward, (hy/radius) * CONFIG.playerSpeed * -1);
    playerPos.add(mv);
  }
  function end(){ handle.style.transform='translate(-50%,-50%)'; id=null }
  joystick.addEventListener('touchstart',(e)=>{ start(e.changedTouches[0]); },{passive:false});
  joystick.addEventListener('touchmove',(e)=>{ for(const t of e.changedTouches) if(t.identifier===id || id===null) { move(t.clientX,t.clientY); break } },{passive:false});
  joystick.addEventListener('touchend',(e)=>{ for(const t of e.changedTouches) if(t.identifier===id) { end(); break } },{passive:false});
})();

/* ========= Main loop ========= */
let spawnAcc = 0;
function runLoop(){
  animationFrameId = requestAnimationFrame(runLoop);
  const dt = clock.getDelta();
  // movement keyboard (desktop)
  if(window.innerWidth >= 900){
    let mv = new THREE.Vector3();
    if(keys['KeyW']||keys['ArrowUp']) mv.z -= 1;
    if(keys['KeyS']||keys['ArrowDown']) mv.z += 1;
    if(keys['KeyA']||keys['ArrowLeft']) mv.x -= 1;
    if(keys['KeyD']||keys['ArrowRight']) mv.x += 1;
    if(mv.length()>0){
      mv.normalize().multiplyScalar(CONFIG.playerSpeed);
      // rotate by camera yaw
      const yaw = camera.rotation.y;
      const dx = mv.x * Math.cos(yaw) - mv.z * Math.sin(yaw);
      const dz = mv.x * Math.sin(yaw) + mv.z * Math.cos(yaw);
      const candidate = playerPos.clone().add(new THREE.Vector3(dx,0,dz));
      if(allowMove(candidate)) playerPos.copy(candidate);
    }
  }
  camera.position.copy(playerPos);

  // spawn logic
  if(state.running && !state.paused){
    if(state.enemiesToSpawn > 0){
      spawnAcc += dt;
      if(spawnAcc > 0.6){
        spawnAcc = 0;
        const t = Math.random() < 0.12 + state.wave*0.01 ? 2 : (Math.random()<0.3?1:0);
        spawnEnemy(t);
        state.enemiesToSpawn--;
      }
    } else {
      if(state.enemies.length === 0 && performance.now() - state.lastSpawnTime > 1200){
        nextWave();
      }
    }
    updateEnemies(dt); updateDrops(dt);
  }

  renderer.render(scene, camera);
}

/* ========= Collision check for player movement ========= */
function allowMove(candidate){
  // bounding box around player
  const b = new THREE.Box3(new THREE.Vector3(candidate.x - CONFIG.playerRadius, candidate.y-1, candidate.z - CONFIG.playerRadius),
                           new THREE.Vector3(candidate.x + CONFIG.playerRadius, candidate.y+1, candidate.z + CONFIG.playerRadius));
  for(const ob of obstacles){
    if(ob instanceof THREE.Box3){
      if(b.intersectsBox(ob)) return false;
    }
  }
  if(Math.abs(candidate.x) > CONFIG.worldSize || Math.abs(candidate.z) > CONFIG.worldSize) return false;
  return true;
}

/* ========= End game & results ========= */
function endGame(){
  state.running = false;
  cancelAnimationFrame(animationFrameId);
  resultsText.innerHTML = `–û—á–∫–∏: ${state.score}<br>–£–±–∏–π—Å—Ç–≤: ${state.totalKilled}<br>–í–æ–ª–Ω –ø—Ä–æ–π–¥–µ–Ω–æ: ${state.wave}`;
  results.style.display='flex';
  gameContainer.style.pointerEvents='none';
  gameUI.style.pointerEvents='none';
  // try send to TG
  try{ if(window.Telegram && Telegram.WebApp){ Telegram.WebApp.sendData(JSON.stringify({score:state.score,kills:state.totalKilled,wave:state.wave})) } }catch(e){}
}

/* ========= Resize ========= */
function onResize(){ if(camera && renderer){ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } }

/* ========= Spawn initial enemies helper ========= */
function spawnEnemy(type=0){
  const color = type===0?0xff6b6b:(type===1?0xffd56b:0xb46bff);
  const geo = new THREE.SphereGeometry(type===2?1.05:0.85,8,8);
  const mat = new THREE.MeshStandardMaterial({color});
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set((Math.random()<0.5?-1:1)*(20 + Math.random()*30), 0.6, (Math.random()<0.5?-1:1)*(20 + Math.random()*30));
  mesh.userData = {hp: type===2?80:(type===1?18:35), speed: type===2?0.02:(type===1?0.12:0.04), hitTimer:0};
  scene.add(mesh);
  state.enemies.push({mesh});
}

/* ========= Drop & pickup handled above in updateDrops ========= */

/* ========= Startup ========= */
window.addEventListener('load', ()=> {
  // Ensure menu/canvas ordering correct:
  // menu z-index is higher; canvas pointer-events disabled until startGame
  gameContainer.style.pointerEvents = 'none';
  gameUI.style.display = 'block'; gameUI.style.pointerEvents = 'none';
  $('joystick').style.display = (window.innerWidth < 900) ? 'flex' : 'none';

  setupUI();

  // Weapon hotkeys UI highlight
  document.addEventListener('keydown', (e)=>{ if(e.code==='Digit1') highlightWB(0); if(e.code==='Digit2') highlightWB(1); if(e.code==='Digit3') highlightWB(2); });

  function highlightWB(i){
    const list = document.querySelectorAll('.wbtn'); list.forEach((b,idx)=> b.style.borderColor = (idx===i?'rgba(0,255,234,0.6)':'rgba(0,255,234,0.04)'));
    setTimeout(()=> list.forEach(b=> b.style.borderColor='rgba(0,255,234,0.04)'),300);
  }

  console.log("UI ready");
  try{ if(window.Telegram && Telegram.WebApp){ Telegram.WebApp.ready(); Telegram.WebApp.expand(); console.log("Telegram WebApp ready"); } }catch(e){}
});
</script>
</body>
</html>
