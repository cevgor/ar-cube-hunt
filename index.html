<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Z.E.R.O.: Last Breach</title>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<style>
:root {
  --neon: #00ffea;
  --accent: #ff6b6b;
  --bg: #05060a;
  --text: #ffffff;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
}

body {
  background: var(--bg);
  color: var(--text);
  font-family: 'Arial', sans-serif;
  overflow: hidden;
  width: 100vw;
  height: 100vh;
  touch-action: none;
}

#app {
  width: 100%;
  height: 100%;
  position: relative;
}

/* ========= SCREENS ========= */
.screen {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.screen.active {
  display: flex;
}

/* ========= MAIN MENU ========= */
#mainMenu {
  background: linear-gradient(135deg, #0a0b14 0%, #15182a 100%);
}

.menu-container {
  text-align: center;
  padding: 2rem;
  background: rgba(0, 0, 0, 0.7);
  border-radius: 20px;
  border: 2px solid var(--neon);
  box-shadow: 0 0 30px rgba(0, 255, 234, 0.3);
  backdrop-filter: blur(10px);
}

.game-title {
  font-size: 4rem;
  background: linear-gradient(45deg, var(--neon), #ff00ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 1rem;
  text-shadow: 0 0 20px rgba(0, 255, 234, 0.5);
}

.game-subtitle {
  font-size: 1.2rem;
  color: var(--neon);
  margin-bottom: 2rem;
  opacity: 0.8;
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  width: 300px;
}

.menu-btn {
  padding: 1rem 2rem;
  font-size: 1.2rem;
  background: linear-gradient(45deg, #1a1f38, #2d3758);
  border: 2px solid var(--neon);
  color: var(--neon);
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 2px;
}

.menu-btn:hover {
  background: linear-gradient(45deg, #2d3758, #1a1f38);
  box-shadow: 0 0 20px rgba(0, 255, 234, 0.5);
  transform: translateY(-2px);
}

/* ========= GAME SCREEN ========= */
#gameScreen {
  background: #000;
}

#gameCanvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: block;
}

/* ========= GAME UI ========= */
#gameUI {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 500;
}

/* Health Bar */
.health-container {
  position: absolute;
  top: 20px;
  left: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid var(--neon);
}

.health-bar {
  width: 200px;
  height: 20px;
  background: #333;
  border-radius: 10px;
  overflow: hidden;
  margin-bottom: 5px;
}

.health-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff6b6b, #ff2b2b);
  transition: width 0.3s ease;
  width: 100%;
}

.health-text {
  color: var(--neon);
  font-size: 1.1rem;
}

/* Ammo & Wave */
.stats-container {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px 20px;
  border-radius: 10px;
  border: 2px solid var(--neon);
  text-align: right;
}

.ammo-text, .wave-text {
  color: var(--neon);
  font-size: 1.1rem;
  margin-bottom: 5px;
}

/* Weapon Selector */
.weapon-selector {
  position: absolute;
  bottom: 120px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  background: rgba(0, 0, 0, 0.7);
  padding: 10px;
  border-radius: 10px;
  border: 2px solid var(--neon);
}

.weapon-btn {
  width: 60px;
  height: 60px;
  background: #1a1f38;
  border: 2px solid transparent;
  border-radius: 8px;
  color: var(--neon);
  cursor: pointer;
  pointer-events: auto;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: 0.8rem;
  transition: all 0.3s ease;
}

.weapon-btn.active {
  border-color: var(--neon);
  box-shadow: 0 0 10px rgba(0, 255, 234, 0.5);
}

/* Controls */
.controls-container {
  position: absolute;
  bottom: 20px;
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 20px;
}

/* Right Controls (Actions) */
.right-controls {
  display: flex;
  gap: 10px;
  align-items: flex-end;
}

.action-btn {
  width: 80px;
  height: 80px;
  background: rgba(255, 107, 107, 0.2);
  border: 2px solid var(--accent);
  border-radius: 50%;
  color: var(--accent);
  font-size: 1.8rem;
  cursor: pointer;
  pointer-events: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.action-btn:active {
  background: rgba(255, 107, 107, 0.4);
  transform: scale(0.95);
}

.reload-btn {
  width: 60px;
  height: 60px;
  background: rgba(255, 255, 255, 0.2);
  border: 2px solid var(--text);
  color: var(--text);
}

/* Joystick */
.joystick-container {
  position: absolute;
  left: 30px;
  bottom: 30px;
  width: 120px;
  height: 120px;
  pointer-events: auto;
}

.joystick-base {
  width: 100%;
  height: 100%;
  background: rgba(0, 255, 234, 0.1);
  border: 2px solid var(--neon);
  border-radius: 50%;
  position: relative;
}

.joystick-handle {
  width: 50px;
  height: 50px;
  background: rgba(0, 255, 234, 0.3);
  border: 2px solid var(--neon);
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: transform 0.1s ease;
}

/* Crosshair */
.crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  pointer-events: none;
}

.crosshair::before,
.crosshair::after {
  content: '';
  position: absolute;
  background: var(--neon);
}

.crosshair::before {
  width: 2px;
  height: 20px;
  left: 50%;
  transform: translateX(-50%);
}

.crosshair::after {
  width: 20px;
  height: 2px;
  top: 50%;
  transform: translateY(-50%);
}

/* Item Popup */
.item-popup {
  position: absolute;
  bottom: 200px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid var(--neon);
  border-radius: 10px;
  padding: 10px 20px;
  color: var(--neon);
  font-size: 1.1rem;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.item-popup.show {
  opacity: 1;
}

/* Mobile Responsive */
@media (max-width: 768px) {
  .game-title {
    font-size: 2.5rem;
  }
  
  .action-btn {
    width: 70px;
    height: 70px;
    font-size: 1.5rem;
  }
  
  .weapon-btn {
    width: 50px;
    height: 50px;
    font-size: 0.7rem;
  }
  
  .joystick-container {
    width: 100px;
    height: 100px;
    left: 20px;
    bottom: 20px;
  }
  
  .joystick-handle {
    width: 40px;
    height: 40px;
  }
}
</style>
</head>
<body>
<div id="app">
  <!-- Main Menu -->
  <div id="mainMenu" class="screen active">
    <div class="menu-container">
      <h1 class="game-title">Z.E.R.O.</h1>
      <p class="game-subtitle">LAST BREACH</p>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="startGame()">–ù–ê–ß–ê–¢–¨ –ò–ì–†–£</button>
        <button class="menu-btn" onclick="showScreen('settingsMenu')">–ù–ê–°–¢–†–û–ô–ö–ò</button>
        <button class="menu-btn" onclick="showAchievements()">–î–û–°–¢–ò–ñ–ï–ù–ò–Ø</button>
      </div>
    </div>
  </div>

  <!-- Game Screen -->
  <div id="gameScreen" class="screen">
    <canvas id="gameCanvas"></canvas>
    
    <!-- Game UI -->
    <div id="gameUI">
      <!-- Health -->
      <div class="health-container">
        <div class="health-bar">
          <div class="health-fill" id="healthFill"></div>
        </div>
        <div class="health-text" id="healthText">100 HP</div>
      </div>

      <!-- Stats -->
      <div class="stats-container">
        <div class="ammo-text" id="ammoText">12/60</div>
        <div class="wave-text" id="waveText">–í–æ–ª–Ω–∞: 1</div>
      </div>

      <!-- Weapon Selector -->
      <div class="weapon-selector">
        <div class="weapon-btn active" data-weapon="0" onclick="switchWeapon(0)">
          <span>üî´</span>
          <span>–ü–∏—Å—Ç–æ–ª–µ—Ç</span>
        </div>
        <div class="weapon-btn" data-weapon="1" onclick="switchWeapon(1)">
          <span>üî´</span>
          <span>–ê–≤—Ç–æ–º–∞—Ç</span>
        </div>
        <div class="weapon-btn" data-weapon="2" onclick="switchWeapon(2)">
          <span>üî´</span>
          <span>–î—Ä–æ–±–æ–≤–∏–∫</span>
        </div>
      </div>

      <!-- Joystick -->
      <div class="joystick-container">
        <div class="joystick-base">
          <div class="joystick-handle" id="joystickHandle"></div>
        </div>
      </div>

      <!-- Controls -->
      <div class="controls-container">
        <!-- Right Controls -->
        <div class="right-controls">
          <div class="action-btn reload-btn" onclick="reloadWeapon()">‚Üª</div>
          <div class="action-btn" onclick="shoot()">üî´</div>
          <div class="action-btn" onclick="useSpecialAbility()">‚ö°</div>
        </div>
      </div>

      <!-- Crosshair -->
      <div class="crosshair"></div>

      <!-- Item Popup -->
      <div class="item-popup" id="itemPopup"></div>
    </div>
  </div>

  <!-- Pause Menu -->
  <div id="pauseMenu" class="screen">
    <div class="menu-container">
      <h2>–ü–ê–£–ó–ê</h2>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="resumeGame()">–ü–†–û–î–û–õ–ñ–ò–¢–¨</button>
        <button class="menu-btn" onclick="showScreen('mainMenu')">–í –ú–ï–ù–Æ</button>
      </div>
    </div>
  </div>

  <!-- Settings Menu -->
  <div id="settingsMenu" class="screen">
    <div class="settings-container">
      <h2>–ù–ê–°–¢–†–û–ô–ö–ò</h2>
      <div class="setting-item">
        <span class="setting-label">–ì—Ä–æ–º–∫–æ—Å—Ç—å</span>
        <input type="range" class="setting-slider" id="volumeSlider" min="0" max="1" step="0.1" value="0.8">
      </div>
      <div class="setting-item">
        <span class="setting-label">–ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å</span>
        <input type="range" class="setting-slider" id="sensitivitySlider" min="0.1" max="2" step="0.1" value="1">
      </div>
      <div class="menu-buttons">
        <button class="menu-btn" onclick="saveSettings()">–°–û–•–†–ê–ù–ò–¢–¨</button>
        <button class="menu-btn" onclick="showScreen('mainMenu')">–ù–ê–ó–ê–î</button>
      </div>
    </div>
  </div>
</div>

<script>
// ========= GAME STATE =========
const GameState = {
    currentScreen: 'mainMenu',
    isRunning: false,
    isPaused: false,
    player: {
        health: 100,
        maxHealth: 100,
        position: new THREE.Vector3(0, 1.6, 0),
        rotation: new THREE.Vector2(0, 0)
    },
    weapons: [
        { type: 'pistol', ammo: 12, maxAmmo: 60, damage: 25, fireRate: 500, name: '–ü–∏—Å—Ç–æ–ª–µ—Ç' },
        { type: 'rifle', ammo: 30, maxAmmo: 180, damage: 15, fireRate: 100, name: '–ê–≤—Ç–æ–º–∞—Ç' },
        { type: 'shotgun', ammo: 8, maxAmmo: 32, damage: 40, fireRate: 800, name: '–î—Ä–æ–±–æ–≤–∏–∫' }
    ],
    currentWeapon: 0,
    wave: 1,
    enemies: [],
    items: [],
    score: 0,
    achievements: new Set()
};

// ========= THREE.JS VARIABLES =========
let scene, camera, renderer, canvas;
let playerMesh, weaponMesh, leftHandMesh, rightHandMesh;
let enemies = [];
let items = [];
let obstacles = [];
let clock = new THREE.Clock();

// ========= JOYSTICK =========
let joystickActive = false;
let joystickVector = new THREE.Vector2(0, 0);

// ========= INITIALIZATION =========
function initGame() {
    console.log("Initializing game...");
    
    if (!initThreeJS()) {
        console.error("Three.js initialization failed!");
        return;
    }
    
    initEventListeners();
    loadSettings();
    loadAchievements();
    
    console.log("Game initialized successfully");
}

function initThreeJS() {
    try {
        console.log("Initializing Three.js...");
        
        // Get canvas element
        canvas = document.getElementById('gameCanvas');
        if (!canvas) {
            console.error("Canvas element not found!");
            return false;
        }

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0b14);
        scene.fog = new THREE.FogExp2(0x0a0b14, 0.01);

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ 
            canvas: canvas,
            antialias: true,
            alpha: false
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        console.log("Three.js core components created");

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);

        console.log("Lighting setup complete");

        // Create environment
        createEnvironment();
        createPlayer();
        
        console.log("Three.js initialized successfully");
        return true;

    } catch (error) {
        console.error(`Three.js init error: ${error}`);
        return false;
    }
}

function createEnvironment() {
    console.log("Creating environment...");
    
    // Ground
    const groundGeometry = new THREE.PlaneGeometry(200, 200);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2d5a27,
        roughness: 0.8,
        metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Create houses and trees
    createHouses();
    createTrees();
    createBoundaryWalls();
    
    console.log("Environment created");
}

function createHouses() {
    const houseColors = [0x8B4513, 0xA0522D, 0xCD853F];
    const roofColors = [0x8B0000, 0xA52A2A, 0xB22222];
    
    for (let i = 0; i < 15; i++) {
        const width = 5 + Math.random() * 5;
        const height = 3 + Math.random() * 4;
        const depth = 5 + Math.random() * 5;
        
        // House body
        const houseGeometry = new THREE.BoxGeometry(width, height, depth);
        const houseMaterial = new THREE.MeshStandardMaterial({ 
            color: houseColors[Math.floor(Math.random() * houseColors.length)]
        });
        const house = new THREE.Mesh(houseGeometry, houseMaterial);
        
        house.position.set(
            (Math.random() - 0.5) * 180,
            height / 2,
            (Math.random() - 0.5) * 180
        );
        
        house.castShadow = true;
        house.receiveShadow = true;
        scene.add(house);
        obstacles.push(house);
        
        // Roof
        const roofGeometry = new THREE.ConeGeometry(width * 0.8, 2, 4);
        const roofMaterial = new THREE.MeshStandardMaterial({ 
            color: roofColors[Math.floor(Math.random() * roofColors.length)]
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.position.set(0, height, 0);
        roof.rotation.y = Math.PI / 4;
        house.add(roof);
    }
}

function createTrees() {
    for (let i = 0; i < 30; i++) {
        const treeGroup = new THREE.Group();
        
        // Trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
        const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1;
        trunk.castShadow = true;
        treeGroup.add(trunk);
        
        // Leaves
        const leavesGeometry = new THREE.SphereGeometry(1.5, 8, 6);
        const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
        leaves.position.y = 2.5;
        leaves.castShadow = true;
        treeGroup.add(leaves);
        
        treeGroup.position.set(
            (Math.random() - 0.5) * 180,
            0,
            (Math.random() - 0.5) * 180
        );
        
        scene.add(treeGroup);
        obstacles.push(treeGroup);
    }
}

function createBoundaryWalls() {
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    
    const walls = [
        { position: [0, 5, -100], size: [200, 10, 2] },
        { position: [0, 5, 100], size: [200, 10, 2] },
        { position: [-100, 5, 0], size: [2, 10, 200] },
        { position: [100, 5, 0], size: [2, 10, 200] }
    ];

    walls.forEach(wallData => {
        const geometry = new THREE.BoxGeometry(...wallData.size);
        const wall = new THREE.Mesh(geometry, wallMaterial);
        wall.position.set(...wallData.position);
        scene.add(wall);
        obstacles.push(wall);
    });
}

function createPlayer() {
    // Player body (invisible, just for collision)
    const playerGeometry = new THREE.CapsuleGeometry(0.5, 1.5, 4, 8);
    const playerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x00ff00,
        visible: false // Make player invisible
    });
    playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
    playerMesh.position.set(0, 1, 0);
    scene.add(playerMesh);

    // Create hands and weapon (first person view)
    createFirstPersonView();
}

function createFirstPersonView() {
    const handGroup = new THREE.Group();
    
    // Left hand
    const leftHandGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
    const leftHandMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
    leftHandMesh = new THREE.Mesh(leftHandGeometry, leftHandMaterial);
    leftHandMesh.position.set(-0.2, -0.3, -0.5);
    handGroup.add(leftHandMesh);
    
    // Right hand
    const rightHandGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.1);
    const rightHandMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
    rightHandMesh = new THREE.Mesh(rightHandGeometry, rightHandMaterial);
    rightHandMesh.position.set(0.2, -0.3, -0.5);
    handGroup.add(rightHandMesh);
    
    // Weapon
    const weaponGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
    const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    weaponMesh = new THREE.Mesh(weaponGeometry, weaponMaterial);
    weaponMesh.position.set(0.1, -0.4, -0.7);
    handGroup.add(weaponMesh);
    
    camera.add(handGroup);
}

// ========= GAME LOGIC =========
function startGame() {
    console.log("Starting game...");
    
    showScreen('gameScreen');
    GameState.isRunning = true;
    GameState.isPaused = false;
    GameState.wave = 1;
    GameState.player.health = 100;
    GameState.score = 0;
    
    // Clear previous enemies and items
    enemies.forEach(enemy => {
        if (enemy.mesh && scene) {
            scene.remove(enemy.mesh);
        }
    });
    enemies = [];
    
    items.forEach(item => {
        if (item.mesh && scene) {
            scene.remove(item.mesh);
        }
    });
    items = [];
    
    // Reset player position
    playerMesh.position.set(0, 1, 0);
    camera.position.set(0, 1.6, 0);
    camera.rotation.set(0, 0, 0);
    
    // Update UI
    updateHealthBar();
    updateAmmoDisplay();
    document.getElementById('waveText').textContent = `–í–æ–ª–Ω–∞: ${GameState.wave}`;
    
    // Spawn initial items
    spawnItems();
    
    // Start first wave
    spawnWave();
    
    // Start game loop
    gameLoop();
    
    console.log("Game started successfully");
}

function spawnWave() {
    const enemyCount = Math.min(GameState.wave + 2, 8); // Max 8 enemies per wave
    console.log(`Spawning wave ${GameState.wave} with ${enemyCount} enemies`);
    
    for (let i = 0; i < enemyCount; i++) {
        setTimeout(() => {
            if (GameState.isRunning && !GameState.isPaused) {
                spawnEnemy();
            }
        }, i * 1000);
    }
}

function spawnEnemy() {
    const enemyGroup = new THREE.Group();
    
    // Body
    const bodyGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
    const bodyMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x228B22, // Green zombie
        roughness: 0.8
    });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.castShadow = true;
    enemyGroup.add(body);
    
    // Head
    const headGeometry = new THREE.SphereGeometry(0.3, 8, 6);
    const headMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x32CD32, // Lighter green
        roughness: 0.7
    });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 0.8;
    head.castShadow = true;
    enemyGroup.add(head);
    
    // Arms
    const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.8, 6);
    const armMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 });
    
    const leftArm = new THREE.Mesh(armGeometry, armMaterial);
    leftArm.position.set(-0.5, 0, 0);
    leftArm.rotation.z = Math.PI / 2;
    enemyGroup.add(leftArm);
    
    const rightArm = new THREE.Mesh(armGeometry, armMaterial);
    rightArm.position.set(0.5, 0, 0);
    rightArm.rotation.z = -Math.PI / 2;
    enemyGroup.add(rightArm);
    
    // Random position around player but not too close
    let position;
    let attempts = 0;
    do {
        const angle = Math.random() * Math.PI * 2;
        const distance = 15 + Math.random() * 10;
        position = new THREE.Vector3(
            Math.cos(angle) * distance,
            0,
            Math.sin(angle) * distance
        );
        attempts++;
    } while (position.distanceTo(playerMesh.position) < 10 && attempts < 10);
    
    enemyGroup.position.copy(position);
    enemyGroup.position.y = 1;
    
    scene.add(enemyGroup);
    
    const enemy = {
        mesh: enemyGroup,
        health: 30 + (GameState.wave * 5),
        speed: 0.01 + (Math.random() * 0.01), // Slower speed
        damage: 10,
        lastAttack: 0,
        attackCooldown: 1000, // 1 second between attacks
        walkAnimation: 0
    };
    
    enemies.push(enemy);
}

function updateEnemies() {
    const currentTime = Date.now();
    
    enemies.forEach((enemy, index) => {
        if (!enemy.mesh) return;
        
        // Walk animation
        enemy.walkAnimation += 0.1;
        const armSwing = Math.sin(enemy.walkAnimation) * 0.5;
        enemy.mesh.children[2].rotation.x = armSwing; // Left arm
        enemy.mesh.children[3].rotation.x = -armSwing; // Right arm
        
        // Move towards player
        const direction = new THREE.Vector3()
            .subVectors(playerMesh.position, enemy.mesh.position)
            .normalize();
        
        enemy.mesh.position.addScaledVector(direction, enemy.speed);
        
        // Rotate to face player
        enemy.mesh.lookAt(
            playerMesh.position.x,
            enemy.mesh.position.y,
            playerMesh.position.z
        );
        
        // Check collision with player
        const distance = enemy.mesh.position.distanceTo(playerMesh.position);
        if (distance < 1.5) {
            // Attack player
            if (currentTime - enemy.lastAttack > enemy.attackCooldown) {
                takeDamage(enemy.damage);
                enemy.lastAttack = currentTime;
                
                // Attack animation
                enemy.mesh.children[2].rotation.x = 1.0; // Left arm forward
                enemy.mesh.children[3].rotation.x = -1.0; // Right arm forward
                setTimeout(() => {
                    if (enemy.mesh) {
                        enemy.mesh.children[2].rotation.x = 0; // Reset
                        enemy.mesh.children[3].rotation.x = 0; // Reset
                    }
                }, 200);
            }
        }
        
        // Enemy death
        if (enemy.health <= 0) {
            scene.remove(enemy.mesh);
            enemies.splice(index, 1);
            GameState.score += 25;
            
            // Chance to drop item
            if (Math.random() < 0.3) {
                spawnItem(enemy.mesh.position.clone());
            }
            
            checkAchievements();
        }
    });
    
    // Check if wave is complete
    if (enemies.length === 0 && GameState.isRunning) {
        GameState.wave++;
        document.getElementById('waveText').textContent = `–í–æ–ª–Ω–∞: ${GameState.wave}`;
        
        if (GameState.wave === 3) {
            unlockAchievement('first_boss');
        }
        
        // Spawn more items between waves
        spawnItems();
        
        setTimeout(spawnWave, 3000);
    }
}

function spawnItems() {
    // Spawn random items around the map
    for (let i = 0; i < 5; i++) {
        const position = new THREE.Vector3(
            (Math.random() - 0.5) * 180,
            0.5,
            (Math.random() - 0.5) * 180
        );
        spawnItem(position);
    }
}

function spawnItem(position) {
    const types = ['health', 'ammo'];
    const type = types[Math.floor(Math.random() * types.length)];
    
    let geometry, material, color;
    
    if (type === 'health') {
        geometry = new THREE.SphereGeometry(0.3, 8, 6);
        color = 0xff0000;
    } else {
        geometry = new THREE.BoxGeometry(0.3, 0.3, 0.6);
        color = 0xffff00;
    }
    
    material = new THREE.MeshStandardMaterial({ 
        color: color,
        emissive: color,
        emissiveIntensity: 0.3
    });
    
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(position);
    mesh.castShadow = true;
    scene.add(mesh);
    
    const item = {
        mesh: mesh,
        type: type,
        value: type === 'health' ? 25 : 30
    };
    
    items.push(item);
}

function updateItems() {
    items.forEach((item, index) => {
        if (!item.mesh) return;
        
        // Rotate item
        item.mesh.rotation.y += 0.02;
        
        // Float animation
        item.mesh.position.y = 0.5 + Math.sin(Date.now() * 0.002) * 0.2;
        
        // Check collision with player
        const distance = item.mesh.position.distanceTo(playerMesh.position);
        if (distance < 1.5) {
            collectItem(item, index);
        }
    });
}

function collectItem(item, index) {
    if (item.type === 'health') {
        GameState.player.health = Math.min(GameState.player.maxHealth, GameState.player.health + item.value);
        updateHealthBar();
        showItemPopup("+25 HP");
    } else if (item.type === 'ammo') {
        const weapon = GameState.weapons[GameState.currentWeapon];
        weapon.maxAmmo += item.value;
        updateAmmoDisplay();
        showItemPopup("+30 –ü–∞—Ç—Ä–æ–Ω–æ–≤");
    }
    
    scene.remove(item.mesh);
    items.splice(index, 1);
}

function showItemPopup(text) {
    const popup = document.getElementById('itemPopup');
    popup.textContent = text;
    popup.classList.add('show');
    
    setTimeout(() => {
        popup.classList.remove('show');
    }, 2000);
}

function takeDamage(amount) {
    GameState.player.health -= amount;
    updateHealthBar();
    
    // Visual feedback
    camera.position.y += 0.1;
    setTimeout(() => camera.position.y -= 0.1, 100);
    
    // Screen flash effect
    document.body.style.backgroundColor = '#ff0000';
    setTimeout(() => {
        document.body.style.backgroundColor = '';
    }, 100);
    
    if (GameState.player.health <= 0) {
        gameOver();
    }
}

function updateHealthBar() {
    const healthFill = document.getElementById('healthFill');
    const healthText = document.getElementById('healthText');
    const healthPercent = (GameState.player.health / GameState.player.maxHealth) * 100;
    
    healthFill.style.width = `${healthPercent}%`;
    healthText.textContent = `${Math.max(0, Math.round(GameState.player.health))} HP`;
}

function shoot() {
    if (!GameState.isRunning || GameState.isPaused) return;
    
    const weapon = GameState.weapons[GameState.currentWeapon];
    
    if (weapon.ammo <= 0) {
        showItemPopup("–ù–µ—Ç –ø–∞—Ç—Ä–æ–Ω–æ–≤!");
        return;
    }
    
    weapon.ammo--;
    updateAmmoDisplay();
    
    // Weapon animation
    weaponMesh.position.z = -0.9;
    leftHandMesh.position.z = -0.7;
    rightHandMesh.position.z = -0.7;
    
    setTimeout(() => {
        weaponMesh.position.z = -0.7;
        leftHandMesh.position.z = -0.5;
        rightHandMesh.position.z = -0.5;
    }, 100);
    
    // Muzzle flash effect
    const muzzleFlash = new THREE.PointLight(0xffff00, 2, 10);
    muzzleFlash.position.set(0.1, -0.4, -1.2);
    camera.add(muzzleFlash);
    setTimeout(() => camera.remove(muzzleFlash), 50);
    
    // Check for hits
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    
    const intersects = raycaster.intersectObjects(enemies.map(e => e.mesh));
    
    if (intersects.length > 0) {
        const enemyMesh = intersects[0].object;
        const enemy = enemies.find(e => e.mesh === enemyMesh.parent || e.mesh === enemyMesh);
        if (enemy) {
            enemy.health -= weapon.damage;
            
            // Hit effect
            enemy.mesh.traverse((child) => {
                if (child.isMesh) {
                    child.material.emissive.set(0xff0000);
                }
            });
            
            setTimeout(() => {
                if (enemy.mesh) {
                    enemy.mesh.traverse((child) => {
                        if (child.isMesh) {
                            child.material.emissive.set(0x000000);
                        }
                    });
                }
            }, 100);
        }
    }
}

function reloadWeapon() {
    const weapon = GameState.weapons[GameState.currentWeapon];
    const ammoNeeded = weapon.maxAmmo - weapon.ammo;
    
    if (ammoNeeded > 0) {
        // Reload animation
        weaponMesh.rotation.x = -Math.PI / 2;
        leftHandMesh.rotation.x = -Math.PI / 4;
        rightHandMesh.rotation.x = -Math.PI / 4;
        
        setTimeout(() => {
            weapon.ammo = weapon.maxAmmo;
            updateAmmoDisplay();
            weaponMesh.rotation.x = 0;
            leftHandMesh.rotation.x = 0;
            rightHandMesh.rotation.x = 0;
            showItemPopup("–ü–µ—Ä–µ–∑–∞—Ä—è–¥–∫–∞!");
        }, 1000);
    }
}

function useSpecialAbility() {
    if (!GameState.isRunning || GameState.isPaused) return;
    
    // Shockwave ability - push back all enemies and damage them
    enemies.forEach(enemy => {
        const direction = new THREE.Vector3()
            .subVectors(enemy.mesh.position, playerMesh.position)
            .normalize();
        
        enemy.mesh.position.addScaledVector(direction, 5);
        enemy.health -= 20;
    });
    
    // Visual effect
    const shockwaveGeometry = new THREE.SphereGeometry(1, 16, 16);
    const shockwaveMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ffff,
        transparent: true,
        opacity: 0.5
    });
    const shockwave = new THREE.Mesh(shockwaveGeometry, shockwaveMaterial);
    shockwave.position.copy(playerMesh.position);
    scene.add(shockwave);
    
    setTimeout(() => {
        scene.remove(shockwave);
    }, 500);
    
    showItemPopup("–®–æ–∫–æ–≤–∞—è –≤–æ–ª–Ω–∞!");
}

// ========= ACHIEVEMENTS =========
function loadAchievements() {
    const saved = localStorage.getItem('zero_achievements');
    if (saved) {
        GameState.achievements = new Set(JSON.parse(saved));
    }
}

function saveAchievements() {
    localStorage.setItem('zero_achievements', JSON.stringify([...GameState.achievements]));
}

function unlockAchievement(id) {
    if (!GameState.achievements.has(id)) {
        GameState.achievements.add(id);
        saveAchievements();
        showAchievementPopup(id);
        
        if (window.Telegram && Telegram.WebApp) {
            Telegram.WebApp.sendData(JSON.stringify({ achievement: id }));
        }
    }
}

function showAchievementPopup(id) {
    const achievements = {
        'first_kill': { title: '–ü–µ—Ä–≤—ã–π –∫—Ä–æ–≤—å!', desc: '–£–±–µ–π—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –∑–æ–º–±–∏' },
        'first_boss': { title: '–û—Ö–æ—Ç–Ω–∏–∫ –Ω–∞ –±–æ—Å—Å–æ–≤', desc: '–ü–æ–±–µ–¥–∏—Ç–µ –ø–µ—Ä–≤–æ–≥–æ –±–æ—Å—Å–∞' },
        'wave_5': { title: '–ù–µ—É–¥–µ—Ä–∂–∏–º—ã–π', desc: '–î–æ–π–¥–∏—Ç–µ –¥–æ 5 –≤–æ–ª–Ω—ã' },
        'item_collector': { title: '–ö–æ–ª–ª–µ–∫—Ü–∏–æ–Ω–µ—Ä', desc: '–°–æ–±–µ—Ä–∏—Ç–µ 10 –ø—Ä–µ–¥–º–µ—Ç–æ–≤' }
    };
    
    const achievement = achievements[id];
    if (achievement) {
        showItemPopup(`–î–æ—Å—Ç–∏–∂–µ–Ω–∏–µ: ${achievement.title}`);
    }
}

function checkAchievements() {
    if (GameState.score >= 50 && !GameState.achievements.has('first_kill')) {
        unlockAchievement('first_kill');
    }
    
    if (GameState.wave >= 5 && !GameState.achievements.has('wave_5')) {
        unlockAchievement('wave_5');
    }
}

function showAchievements() {
    let achievementsText = "–í–∞—à–∏ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è:\n";
    GameState.achievements.forEach(achievement => {
        achievementsText += `‚Ä¢ ${achievement}\n`;
    });
    
    if (GameState.achievements.size === 0) {
        achievementsText = "–£ –≤–∞—Å –ø–æ–∫–∞ –Ω–µ—Ç –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π!";
    }
    
    alert(achievementsText);
}

// ========= UI MANAGEMENT =========
function showScreen(screenName) {
    document.querySelectorAll('.screen').forEach(screen => {
        screen.classList.remove('active');
    });
    
    document.getElementById(screenName).classList.add('active');
    GameState.currentScreen = screenName;
}

function switchWeapon(index) {
    if (index < 0 || index >= GameState.weapons.length) return;
    
    GameState.currentWeapon = index;
    
    // Update UI
    document.querySelectorAll('.weapon-btn').forEach((btn, i) => {
        btn.classList.toggle('active', i === index);
    });
    
    updateAmmoDisplay();
}

function updateAmmoDisplay() {
    const weapon = GameState.weapons[GameState.currentWeapon];
    document.getElementById('ammoText').textContent = 
        `${weapon.ammo}/${weapon.maxAmmo} (${weapon.name})`;
}

// ========= SETTINGS =========
function loadSettings() {
    const saved = localStorage.getItem('zero_settings');
    if (saved) {
        const settings = JSON.parse(saved);
        document.getElementById('volumeSlider').value = settings.volume || 0.8;
        document.getElementById('sensitivitySlider').value = settings.sensitivity || 1;
    }
}

function saveSettings() {
    const settings = {
        volume: parseFloat(document.getElementById('volumeSlider').value),
        sensitivity: parseFloat(document.getElementById('sensitivitySlider').value)
    };
    
    localStorage.setItem('zero_settings', JSON.stringify(settings));
    showScreen('mainMenu');
}

// ========= INPUT HANDLING =========
function initEventListeners() {
    // Window resize
    window.addEventListener('resize', onWindowResize);
    
    // Touch controls
    initTouchControls();
    
    // Keyboard for desktop testing
    initKeyboardControls();
    
    console.log("Event listeners initialized");
}

function initTouchControls() {
    // Joystick
    const joystickBase = document.querySelector('.joystick-base');
    const joystickHandle = document.getElementById('joystickHandle');
    
    let touchId = null;
    
    joystickBase.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (touchId === null) {
            touchId = e.changedTouches[0].identifier;
            joystickActive = true;
        }
    });
    
    joystickBase.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!joystickActive) return;
        
        for (let touch of e.touches) {
            if (touch.identifier === touchId) {
                const rect = joystickBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const deltaX = touch.clientX - centerX;
                const deltaY = touch.clientY - centerY;
                
                const distance = Math.min(Math.sqrt(deltaX * deltaX + deltaY * deltaY), rect.width / 2);
                const angle = Math.atan2(deltaY, deltaX);
                
                const handleX = Math.cos(angle) * distance;
                const handleY = Math.sin(angle) * distance;
                
                joystickHandle.style.transform = `translate(calc(-50% + ${handleX}px), calc(-50% + ${handleY}px))`;
                
                // Normalize joystick vector
                joystickVector.x = deltaX / (rect.width / 2);
                joystickVector.y = -deltaY / (rect.height / 2);
                
                break;
            }
        }
    });
    
    joystickBase.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let touch of e.changedTouches) {
            if (touch.identifier === touchId) {
                joystickActive = false;
                touchId = null;
                joystickVector.set(0, 0);
                joystickHandle.style.transform = 'translate(-50%, -50%)';
                break;
            }
        }
    });
    
    // Camera look
    let lookTouchId = null;
    let lastLookX = 0;
    let lastLookY = 0;
    
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (lookTouchId === null) {
            lookTouchId = e.changedTouches[0].identifier;
            lastLookX = e.changedTouches[0].clientX;
            lastLookY = e.changedTouches[0].clientY;
        }
    });
    
    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (lookTouchId === null) return;
        
        for (let touch of e.touches) {
            if (touch.identifier === lookTouchId) {
                const deltaX = touch.clientX - lastLookX;
                const deltaY = touch.clientY - lastLookY;
                
                camera.rotation.y -= deltaX * 0.01;
                camera.rotation.x = Math.max(-Math.PI/3, Math.min(Math.PI/3, camera.rotation.x - deltaY * 0.01));
                
                lastLookX = touch.clientX;
                lastLookY = touch.clientY;
                break;
            }
        }
    });
    
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        for (let touch of e.changedTouches) {
            if (touch.identifier === lookTouchId) {
                lookTouchId = null;
                break;
            }
        }
    });
}

function initKeyboardControls() {
    // For desktop testing
    document.addEventListener('keydown', (e) => {
        if (e.key === ' ') {
            shoot();
            e.preventDefault();
        }
        if (e.key === 'r') {
            reloadWeapon();
        }
        if (e.key === 'e') {
            useSpecialAbility();
        }
        if (e.key >= '1' && e.key <= '3') {
            switchWeapon(parseInt(e.key) - 1);
        }
        if (e.key === 'Escape') {
            togglePause();
        }
    });
}

// ========= GAME LOOP =========
function gameLoop() {
    if (!GameState.isRunning || GameState.isPaused) {
        return;
    }
    
    const delta = clock.getDelta();
    
    updatePlayerMovement(delta);
    updateEnemies();
    updateItems();
    
    // Render the scene
    if (renderer && scene && camera) {
        renderer.render(scene, camera);
    }
    
    requestAnimationFrame(gameLoop);
}

function updatePlayerMovement(delta) {
    if (!joystickActive) return;
    
    const moveSpeed = 5 * delta;
    const moveVector = new THREE.Vector3(joystickVector.x, 0, joystickVector.y);
    
    // Apply camera rotation to movement
    moveVector.applyEuler(new THREE.Euler(0, camera.rotation.y, 0));
    
    // Simple collision detection
    const newPosition = playerMesh.position.clone().add(moveVector.multiplyScalar(moveSpeed));
    let canMove = true;
    
    obstacles.forEach(obstacle => {
        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
        const playerBox = new THREE.Box3().setFromCenterAndSize(
            newPosition, 
            new THREE.Vector3(1, 2, 1)
        );
        
        if (obstacleBox.intersectsBox(playerBox)) {
            canMove = false;
        }
    });
    
    // Boundary check
    if (Math.abs(newPosition.x) > 95 || Math.abs(newPosition.z) > 95) {
        canMove = false;
    }
    
    if (canMove) {
        playerMesh.position.add(moveVector.multiplyScalar(moveSpeed));
        camera.position.add(moveVector.multiplyScalar(moveSpeed));
    }
}

function togglePause() {
    GameState.isPaused = !GameState.isPaused;
    
    if (GameState.isPaused) {
        showScreen('pauseMenu');
    } else {
        showScreen('gameScreen');
        gameLoop();
    }
}

function resumeGame() {
    GameState.isPaused = false;
    showScreen('gameScreen');
    gameLoop();
}

function gameOver() {
    GameState.isRunning = false;
    const message = `–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n–í–∞—à —Å—á–µ—Ç: ${GameState.score}\n–ü—Ä–æ–π–¥–µ–Ω–æ –≤–æ–ª–Ω: ${GameState.wave}`;
    console.log(message);
    alert(message);
    showScreen('mainMenu');
}

function onWindowResize() {
    if (camera && renderer) {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
}

// ========= INITIALIZE GAME =========
window.addEventListener('load', () => {
    console.log("Window loaded, initializing game...");
    
    // Initialize Telegram WebApp if available
    if (window.Telegram && Telegram.WebApp) {
        Telegram.WebApp.ready();
        Telegram.WebApp.expand();
        console.log("Telegram WebApp initialized");
    }
    
    // Initialize game
    initGame();
});
</script>
</body>
</html>
