<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Хроники падающих звёзд | Хардкор</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            color: #0ff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }
        
        #gameContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.2rem;
            text-shadow: 0 0 5px #0ff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
        }
        
        .resources {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2rem;
            text-shadow: 0 0 5px #0ff;
            text-align: right;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
        }
        
        .controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 1px solid #0ff;
            font-size: 0.9rem;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid #f00;
            text-align: center;
            display: none;
        }
        
        .btn {
            background: transparent;
            color: #0ff;
            border: 2px solid #0ff;
            padding: 10px 20px;
            margin: 10px;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }
        
        .btn:hover {
            background: rgba(0, 255, 255, 0.2);
        }
        
        .scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0) 0%,
                rgba(255,255,255,0.03) 50%,
                rgba(255,255,255,0) 100%
            );
            background-size: 100% 4px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div id="ui">
        <div class="scanlines"></div>
        
        <div class="hud">
            <div>ЗДОРОВЬЕ: <span id="healthValue">100</span>%</div>
            <div>ЭНЕРГИЯ: <span id="energyValue">100</span>%</div>
            <div>СКОРОСТЬ: <span id="speedValue">0</span></div>
            <div>ЩИТ: <span id="shieldValue">100</span>%</div>
        </div>
        
        <div class="resources">
            <div>ЗВЁЗДЫ: <span id="starsValue">0</span></div>
            <div>ОБЛОМКИ: <span id="fragmentsValue">0</span></div>
            <div>ОЧКИ: <span id="scoreValue">0</span></div>
        </div>
        
        <div class="controls-info">
            УПРАВЛЕНИЕ: WASD/СТРЕЛКИ - движение, ПРОБЕЛ - щит
        </div>
        
        <div id="gameOver" class="game-over">
            <h2>КОРАБЛЬ УНИЧТОЖЕН</h2>
            <p style="margin: 20px 0; font-size: 1.2rem;">Счёт: <span id="finalScore">0</span></p>
            <button class="btn" onclick="restartGame()">НОВАЯ ИГРА</button>
        </div>
    </div>

    <script>
        // Инициализация Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        
        // Настройка рендерера
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011, 1);
        renderer.shadowMap.enabled = true;
        document.getElementById('gameContainer').appendChild(renderer.domElement);
        
        // Освещение
        const ambientLight = new THREE.AmbientLight(0x333355);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Звёздное небо
        const starGeometry = new THREE.BufferGeometry();
        const starCount = 5000;
        const starPositions = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount * 3; i += 3) {
            starPositions[i] = (Math.random() - 0.5) * 2000;
            starPositions[i + 1] = (Math.random() - 0.5) * 2000;
            starPositions[i + 2] = (Math.random() - 0.5) * 2000;
        }
        
        starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
        
        const starMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            sizeAttenuation: true
        });
        
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);
        
        // Корабль игрока
        const shipGeometry = new THREE.ConeGeometry(3, 10, 4);
        const shipMaterial = new THREE.MeshPhongMaterial({
            color: 0x00aaff,
            shininess: 100,
            emissive: 0x002266
        });
        
        const ship = new THREE.Mesh(shipGeometry, shipMaterial);
        ship.rotation.x = Math.PI / 2;
        ship.position.z = 15;
        ship.castShadow = true;
        scene.add(ship);
        
        // Массивы для объектов
        let asteroids = [];
        let enemyShips = [];
        let starFields = [];
        let blackHoles = [];
        
        // Игровые переменные
        let gameState = {
            health: 100,
            energy: 100,
            stars: 0,
            fragments: 0,
            score: 0,
            speed: 0,
            maxSpeed: 0.5,
            acceleration: 0.01,
            rotationSpeed: 0.05,
            isShieldActive: false,
            shieldEnergy: 100,
            gameActive: true,
            keys: {}
        };
        
        // Процедурная генерация астероидов
        function generateAsteroids(count) {
            for (let i = 0; i < count; i++) {
                const size = Math.random() * 5 + 1;
                const geometry = new THREE.IcosahedronGeometry(size, 0);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x888888,
                    shininess: 30
                });
                
                const asteroid = new THREE.Mesh(geometry, material);
                
                asteroid.position.x = (Math.random() - 0.5) * 200;
                asteroid.position.y = (Math.random() - 0.5) * 200;
                asteroid.position.z = ship.position.z - 100 - Math.random() * 500;
                
                asteroid.rotation.x = Math.random() * Math.PI;
                asteroid.rotation.y = Math.random() * Math.PI;
                
                asteroid.userData = {
                    rotationSpeed: {
                        x: (Math.random() - 0.5) * 0.02,
                        y: (Math.random() - 0.5) * 0.02,
                        z: (Math.random() - 0.5) * 0.02
                    },
                    speed: Math.random() * 0.5 + 0.1
                };
                
                asteroid.castShadow = true;
                scene.add(asteroid);
                asteroids.push(asteroid);
            }
        }
        
        // Процедурная генерация вражеских кораблей
        function generateEnemyShips(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.OctahedronGeometry(3, 0);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xff3300,
                    shininess: 100,
                    emissive: 0x330000
                });
                
                const enemyShip = new THREE.Mesh(geometry, material);
                
                enemyShip.position.x = (Math.random() - 0.5) * 150;
                enemyShip.position.y = (Math.random() - 0.5) * 150;
                enemyShip.position.z = ship.position.z - 200 - Math.random() * 400;
                
                enemyShip.userData = {
                    speed: Math.random() * 0.3 + 0.2,
                    health: 30
                };
                
                enemyShip.castShadow = true;
                scene.add(enemyShip);
                enemyShips.push(enemyShip);
            }
        }
        
        // Процедурная генерация полей звёзд (ресурсы)
        function generateStarFields(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(2, 8, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xffff00,
                    shininess: 100,
                    emissive: 0x444400
                });
                
                const starField = new THREE.Mesh(geometry, material);
                
                starField.position.x = (Math.random() - 0.5) * 180;
                starField.position.y = (Math.random() - 0.5) * 180;
                starField.position.z = ship.position.z - 150 - Math.random() * 450;
                
                starField.userData = {
                    rotationSpeed: (Math.random() - 0.5) * 0.05,
                    collected: false
                };
                
                starField.castShadow = true;
                scene.add(starField);
                starFields.push(starField);
            }
        }
        
        // Процедурная генерация чёрных дыр
        function generateBlackHoles(count) {
            for (let i = 0; i < count; i++) {
                const geometry = new THREE.SphereGeometry(8, 32, 32);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x000000,
                    emissive: 0x220022
                });
                
                const blackHole = new THREE.Mesh(geometry, material);
                
                blackHole.position.x = (Math.random() - 0.5) * 100;
                blackHole.position.y = (Math.random() - 0.5) * 100;
                blackHole.position.z = ship.position.z - 250 - Math.random() * 300;
                
                blackHole.userData = {
                    gravityStrength: 0.05
                };
                
                blackHole.castShadow = true;
                scene.add(blackHole);
                blackHoles.push(blackHole);
            }
        }
        
        // Обновление игрового состояния
        function updateGameState() {
            if (!gameState.gameActive) return;
            
            // Управление кораблем
            if (gameState.keys['ArrowUp'] || gameState.keys['w']) {
                gameState.speed = Math.min(gameState.speed + gameState.acceleration, gameState.maxSpeed);
            } else if (gameState.keys['ArrowDown'] || gameState.keys['s']) {
                gameState.speed = Math.max(gameState.speed - gameState.acceleration * 2, 0);
            } else {
                gameState.speed = Math.max(gameState.speed - gameState.acceleration * 0.5, 0);
            }
            
            if (gameState.keys['ArrowLeft'] || gameState.keys['a']) {
                ship.rotation.z += gameState.rotationSpeed;
            }
            if (gameState.keys['ArrowRight'] || gameState.keys['d']) {
                ship.rotation.z -= gameState.rotationSpeed;
            }
            
            // Движение корабля вперед
            ship.position.x -= Math.sin(ship.rotation.z) * gameState.speed;
            ship.position.y += Math.cos(ship.rotation.z) * gameState.speed;
            
            // Обновление позиции камеры
            camera.position.x = ship.position.x;
            camera.position.y = ship.position.y;
            camera.position.z = ship.position.z + 20;
            camera.lookAt(ship.position.x, ship.position.y, ship.position.z - 10);
            
            // Обновление астероидов
            asteroids.forEach((asteroid, index) => {
                asteroid.position.z += asteroid.userData.speed;
                asteroid.rotation.x += asteroid.userData.rotationSpeed.x;
                asteroid.rotation.y += asteroid.userData.rotationSpeed.y;
                asteroid.rotation.z += asteroid.userData.rotationSpeed.z;
                
                // Проверка столкновения с кораблем
                const distance = Math.sqrt(
                    Math.pow(asteroid.position.x - ship.position.x, 2) +
                    Math.pow(asteroid.position.y - ship.position.y, 2) +
                    Math.pow(asteroid.position.z - ship.position.z, 2)
                );
                
                if (distance < 10) {
                    if (gameState.isShieldActive) {
                        gameState.shieldEnergy -= 20;
                    } else {
                        gameState.health -= 10;
                    }
                    
                    scene.remove(asteroid);
                    asteroids.splice(index, 1);
                    generateAsteroids(1);
                }
                
                if (asteroid.position.z > ship.position.z + 50) {
                    scene.remove(asteroid);
                    asteroids.splice(index, 1);
                    generateAsteroids(1);
                }
            });
            
            // Обновление вражеских кораблей
            enemyShips.forEach((enemy, index) => {
                enemy.position.z += enemy.userData.speed;
                
                if (enemy.position.x < ship.position.x) {
                    enemy.position.x += 0.1;
                } else {
                    enemy.position.x -= 0.1;
                }
                
                if (enemy.position.y < ship.position.y) {
                    enemy.position.y += 0.1;
                } else {
                    enemy.position.y -= 0.1;
                }
                
                const distance = Math.sqrt(
                    Math.pow(enemy.position.x - ship.position.x, 2) +
                    Math.pow(enemy.position.y - ship.position.y, 2) +
                    Math.pow(enemy.position.z - ship.position.z, 2)
                );
                
                if (distance < 8) {
                    if (gameState.isShieldActive) {
                        gameState.shieldEnergy -= 15;
                    } else {
                        gameState.health -= 15;
                    }
                    
                    scene.remove(enemy);
                    enemyShips.splice(index, 1);
                    gameState.fragments += 5;
                    generateEnemyShips(1);
                }
                
                if (enemy.position.z > ship.position.z + 50) {
                    scene.remove(enemy);
                    enemyShips.splice(index, 1);
                    generateEnemyShips(1);
                }
            });
            
            // Обновление полей звёзд
            starFields.forEach((star, index) => {
                star.rotation.y += star.userData.rotationSpeed;
                
                const distance = Math.sqrt(
                    Math.pow(star.position.x - ship.position.x, 2) +
                    Math.pow(star.position.y - ship.position.y, 2) +
                    Math.pow(star.position.z - ship.position.z, 2)
                );
                
                if (distance < 7 && !star.userData.collected) {
                    star.userData.collected = true;
                    gameState.stars += 1;
                    gameState.score += 10;
                    
                    star.scale.set(0.1, 0.1, 0.1);
                    
                    setTimeout(() => {
                        scene.remove(star);
                        starFields.splice(index, 1);
                        generateStarFields(1);
                    }, 300);
                }
                
                if (star.position.z > ship.position.z + 50) {
                    scene.remove(star);
                    starFields.splice(index, 1);
                    generateStarFields(1);
                }
            });
            
            // Обновление чёрных дыр
            blackHoles.forEach((blackHole, index) => {
                const dx = blackHole.position.x - ship.position.x;
                const dy = blackHole.position.y - ship.position.y;
                const dz = blackHole.position.z - ship.position.z;
                
                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                if (distance < 30) {
                    const force = blackHole.userData.gravityStrength / (distance * distance);
                    ship.position.x += dx * force;
                    ship.position.y += dy * force;
                    ship.position.z += dz * force;
                    
                    if (distance < 15) {
                        gameState.health -= 0.5;
                    }
                }
                
                if (blackHole.position.z > ship.position.z + 50) {
                    scene.remove(blackHole);
                    blackHoles.splice(index, 1);
                    generateBlackHoles(1);
                }
            });
            
            // Восстановление энергии щита
            if (!gameState.isShieldActive && gameState.shieldEnergy < 100) {
                gameState.shieldEnergy = Math.min(gameState.shieldEnergy + 0.1, 100);
            }
            
            // Обновление UI
            updateUI();
            
            // Проверка окончания игры
            if (gameState.health <= 0) {
                gameOver();
            }
            
            // Увеличение счёта со временем
            gameState.score += gameState.speed * 0.1;
        }
        
        // Обновление интерфейса
        function updateUI() {
            document.getElementById('healthValue').textContent = Math.max(0, Math.round(gameState.health));
            document.getElementById('energyValue').textContent = Math.round(gameState.energy);
            document.getElementById('speedValue').textContent = Math.round(gameState.speed * 100);
            document.getElementById('shieldValue').textContent = Math.round(gameState.shieldEnergy);
            document.getElementById('starsValue').textContent = gameState.stars;
            document.getElementById('fragmentsValue').textContent = gameState.fragments;
            document.getElementById('scoreValue').textContent = Math.round(gameState.score);
        }
        
        // Активация щита
        function activateShield() {
            if (gameState.shieldEnergy >= 20 && !gameState.isShieldActive) {
                gameState.isShieldActive = true;
                
                const shieldGeometry = new THREE.SphereGeometry(6, 16, 16);
                const shieldMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.3,
                    wireframe: true
                });
                
                const shield = new THREE.Mesh(shieldGeometry, shieldMaterial);
                ship.add(shield);
                
                setTimeout(() => {
                    if (shield.parent) {
                        ship.remove(shield);
                    }
                    gameState.isShieldActive = false;
                }, 3000);
            }
        }
        
        // Конец игры
        function gameOver() {
            gameState.gameActive = false;
            document.getElementById('finalScore').textContent = Math.round(gameState.score);
            document.getElementById('gameOver').style.display = 'block';
        }
        
        // Новая игра
        function restartGame() {
            gameState.health = 100;
            gameState.energy = 100;
            gameState.stars = 0;
            gameState.fragments = 0;
            gameState.score = 0;
            gameState.speed = 0;
            gameState.isShieldActive = false;
            gameState.shieldEnergy = 100;
            gameState.gameActive = true;
            
            ship.position.x = 0;
            ship.position.y = 0;
            ship.position.z = 15;
            ship.rotation.z = 0;
            
            asteroids.forEach(asteroid => scene.remove(asteroid));
            enemyShips.forEach(enemy => scene.remove(enemy));
            starFields.forEach(star => scene.remove(star));
            blackHoles.forEach(blackHole => scene.remove(blackHole));
            
            asteroids = [];
            enemyShips = [];
            starFields = [];
            blackHoles = [];
            
            generateAsteroids(15);
            generateEnemyShips(5);
            generateStarFields(8);
            generateBlackHoles(2);
            
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
        }
        
        // Обработчики событий
        function setupEventListeners() {
            document.addEventListener('keydown', (e) => {
                gameState.keys[e.key] = true;
                
                if (e.key === ' ' && gameState.gameActive) {
                    activateShield();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.key] = false;
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Игровой цикл
        function gameLoop() {
            updateGameState();
            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }
        
        // Инициализация игры
        function init() {
            setupEventListeners();
            
            // Генерация начальных объектов
            generateAsteroids(15);
            generateEnemyShips(5);
            generateStarFields(8);
            generateBlackHoles(2);
            
            updateUI();
            gameLoop();
        }
        
        // Запуск игры после загрузки страницы
        window.addEventListener('load', init);
    </script>
</body>
</html>